<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
      
    
    
      
    
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">







  <meta name="google-site-verification" content="GNI8KNzHxdOObg1xzQwHXPStlrnPJHC4Cw1iZMCCe9U">














  
  
  
  

  

  

  

  

  

  






  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.0.0',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'LEJ8JV9ZSY',
      apiKey: '9572d9f139c3c642cdbaaa2caf3123c9',
      indexName: 'searchIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Java, Char with UTF-16, C++, 数组，">
<meta name="keywords" content="Java,C++,Char with UTF-16">
<meta property="og:type" content="article">
<meta property="og:title" content="Java1_Core10Note">
<meta property="og:url" content="http://www.taoblog.cn/post/2a1ddb5b/index.html">
<meta property="og:site_name" content="TaoBlog">
<meta property="og:description" content="Java, Char with UTF-16, C++, 数组，">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==">
<meta property="og:updated_time" content="2019-09-17T08:31:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java1_Core10Note">
<meta name="twitter:description" content="Java, Char with UTF-16, C++, 数组，">
<meta name="twitter:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==">



  <link rel="alternate" href="/atom.xml" title="TaoBlog" type="application/atom+xml">




  <link rel="canonical" href="http://www.taoblog.cn/post/2a1ddb5b/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java1_Core10Note | TaoBlog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">TaoBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Sharing makes us better</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">50</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">17</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">23</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-message">

    
    
    
      
    

    
      
    

    <a href="/message/" rel="section"><i class="menu-item-icon fa fa-fw fa-comment"></i> <br>留言板</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.taoblog.cn/post/2a1ddb5b/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吴涛涛">
      <meta itemprop="description" content="wutaotao personal blog">
      <meta itemprop="image" content="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/maya.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TaoBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java1_Core10Note

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-12 20:10:28 20:10:28" itemprop="dateCreated datePublished" datetime="2019-05-12T20:10:28+08:00">2019-05-12 20:10:28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-17 16:31:05 16:31:05" itemprop="dateModified" datetime="2019-09-17T16:31:05+08:00">2019-09-17 16:31:05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/post/2a1ddb5b/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/post/2a1ddb5b/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/post/2a1ddb5b/" class="leancloud_visitors" data-flag-title="Java1_Core10Note">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">55k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">50 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Java, Char with UTF-16, C++, 数组，<br><a id="more"></a></p>
<p><strong>以下是阅读javaCore第10版中文版pdf的笔记，看熟2卷后可以再翻看第11版，因为11目前没找到<br>中文版&gt;_&lt;</strong></p>
<h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><p>安装后将jdk安装目录/bin加入到path环境变量即可,不用设置其他。</p>
<h2 id="基本程序设计结构"><a href="#基本程序设计结构" class="headerlink" title="基本程序设计结构"></a>基本程序设计结构</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java有8种基本类型，4种整型，2种浮点型，1个unicode字符类型char,1个boolean类型.</p>
<ol>
<li><p>整型<br>java需要保证不同机器上相同程序运行结果相同，所以java的数据取值范围是固定的<br>（C,C++在不同机器上数据取值范围不同，如在16位处理器上整型占2个字节，32位处理器上<br>整型占4个字节，java没有无符号形式的数据类型unsigned）<br>byte 1个字节 -127 ~ 127<br>short 2个字节 -3万2 ~ 3万2<br>int 4个字节  -21亿 ～ 21亿<br>long 8个字节  -9（共19位） ～ 9（共19位）</p>
<p>long类型有后缀L/l, 十六进制前缀0x/0X,八进制前缀0</p>
<p>从java7开始，二进制可以加前缀0b/0B, 数字字面量可以加下划线，编译器会自动去除，如<br><code>10_00_1</code>代表数字10001。</p>
</li>
<li><p>浮点类型<br>float 4字节   有效位数6～7位（后缀f/F)<br>double 8字节  有效位数15位(无后缀或后缀D/d)</p>
<p>有3个特殊的浮点数，正无穷大，负无穷大，NaN<br>Double中分别为<code>Double.POSITIVE_INFINITY,Double_NEGATIVE_INFINITY,Double_NaN</code></p>
<p>在整型中1/0会抛出算数异常，但1.0/0则会得到<code>Double.POSITIVE_INFINITY</code>,由于所有非<br>数值都认为是不相等的，所以<code>1.0/0 == Double.POSITIVE_INFINITY</code>永远是false,可以<br>这样判断Double.isInfinite(1.0/0),同理可以这样判断x是否是一个数字Double.isNaN(x)</p>
<p>由于浮点数由二进制表示，所以它无法精确表示0.1,就像十进制中无法精确表示1/3一样，所以<br>如果需要精确表示，需要用到bigDecimal.</p>
</li>
<li><p>char<br>char字面量用单引号括起来，它的值可以表示为十六进制,范围是\u0000到\Uffff<br>\u可以在引号外使用，它会在编译前转换为对应的符号，所以在注释中使用\u容易引起报错<br>如<code>\\ C:\users\</code>会报错非法的unicode转义 因为\u后不是4位16进制数<br>还有其他转义字符如’\n’，’\t’可以在引号内使用代表特殊含义。</p>
<p>编码：<br>UTF-16原来是定长16位的，但后来字符总数超过了65536（2^16)个，所以它变成了变长，<br>原字符集为基本字符集，多的字符集称为增补字符集。</p>
<p>unicode码点（code point)指编码表中与某个字符对应的代码值，用16进制数字表示，加上前缀U+<br>码点可以分为不同的代码级别(code plane)，分基本多语言级别和其他级别;<br>UTF-16使用变长长度来表示不同的unicode码点，针对基本多语言级别，使用16位表示一个字符，<br>这也称为一个代码单元(code unit)，其他级别使用2个代码单元来表示该字符。</p>
<p>java char类型表示UTF-16编码中的一个代码单元。<br>由此可知：</p>
<ol>
<li>大部分unicode字符可以用一个char值表示（基本多语言级别），少部分特殊字符（增补字符）<br>需要用2个char值表示。</li>
<li>1 byte = 8 bit, 1个字节代表8位，说明char类型是占用2个字节的。</li>
</ol>
<p>注： </p>
<ol>
<li>UTF-8是变长编码，它用1到4个字节表示不同区间的代码点。</li>
<li>增补字符集用2个代码单元表示一个字符，其范围是U+D800到U+DFFF,这个范围内的码点值没有<br>分配给任何字符，所以可以通过一个代码单元的码点值来判断它是基本字符还是增补字符的高/低位。</li>
</ol>
<p>show the code:<br><code>System.out.println(&quot;𐐷&quot;.length());</code> 输出2</p>
<p>最佳实践：不要在程序中使用char类型，尽量使用String类型。</p>
</li>
<li><p>boolean类型<br>java的布尔类型和整数值之间无法转换，而C++中数值或指针都可以代替布尔值，0代表false,非<br>0代表true.如下java代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 11;</span><br><span class="line">System.out.println(x = 0); // 输出0</span><br><span class="line">if (x = 1) &#123;&#125; // 编译报错incompatible types,即表达式值为1时，它不会自动转换成bool值true.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量由字母开头，由字母和数字构成，字母和数字的范围很大。字母包括<code>a-z,A-Z,_,$和其他表示字母
unicode字符</code>,数字也包括0-9和其他表示数字unicode字符。</p>
<p>c,c++中变量的声明和定义是不同的，java中则不区分，声明和定义是一个意思。<br>java使用final定义常量，常量名全大写。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>像前面说的一样，整数除以0会产生异常，浮点数除0得到无穷大或NaN.<br>由于数学上默认余数都要大于0,但是-6%4表达式执行结果为-2,可以用Math.floorMod(-6,4)来得到正<br>数的结果。<br>不同数值类型之间转换可能会产生精度丢失。如int-&gt;float,long-&gt;float,long-&gt;double等。<br>强制类型转换是直接截断小数部分，如(int)9.99999的结果是9,如果需要四舍五入，可以使用<br>Math.round方法。<br>注：将boolean类型和数值类型进行转换会产生错误，应使用三目运算符。</p>
<p>自增自减运算符与c,c++相同，不建议在表达式中使用该运算符，容易产生bug.</p>
<p>位运算<br>可以使用掩码技术来得到某个数二进制表示的某一位是0还是1,如<code>(15&amp;0b1000)/0b1000</code>结果为1代表15<br>右起第4位是1，同理<code>(24&amp;0b1000)/0b1000</code>也是1,注意括号不可少，限制了运算符顺序。<br>&lt;&lt;表示位模式左移,&gt;&gt;表示右移，具体来说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10&lt;&lt;2等同于0b1010 数字左移，其后补0变为0b101000 = 40.</span><br><span class="line">10&gt;&gt;2等同于ob1010数字右移，高位补符号位，变为0b0010 = 2.</span><br><span class="line">-10&gt;&gt;2 结果为-3,高位补符号位1</span><br><span class="line">-10&gt;&gt;&gt;2 结果为1073741821,高位补0</span><br><span class="line">注： 二进制和十进制转换</span><br><span class="line">System.out.println(0b1010);  //10</span><br><span class="line">System.out.println(Integer.toBinaryString(-10));//111111...补码，反码......</span><br></pre></td></tr></table></figure></p>
<p>java中没有逗号运算符</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>子串： substring(0,3)包头不包尾，包括0,1,2,这样子串长度可以很容易的由3-0=3得出。<br>拼接： 2个或较少的字符串拼接可以用’+’，多个字符串用一个指定分隔符拼接可以用String.join<br>      方法，如String.join(“/“, “A”, “B”,”C”);为A/B/C.<br>不可变字符串： 因为实际字符串修改需求较少，而且共享字符串的性能提高比拼接的耗费要多很多。<br>注：java字符串不等同于c中的字符数组，而是类似于<code>char*</code>指针。</p>
<p>比较字符串：因为只有字符串常量是共享的，其他如+或substring是不共享的，所以无法用==来判断<br>字符串相等，而因使用equals方法。<br>空串””与null串</p>
<p>码点与代码单元： char代表采用UTF-16编码一个码点需要的代码单元，string.length()方法返回的<br>就是字符串需要的代码单元个数，这样也就解释了”𐐷”.length() = 2，这个字符需要2个代码单元。<br>同时”𐐷”.codePointCount(0,2)返回了码点个数，即实际的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">码点和代码单元都是从0开始（和C一样）。</span><br><span class="line">使用&quot;XXX&quot;.codePointAt(i)来得到第i个码点的值</span><br><span class="line">如遍历字符串&quot;𐐷 is good&quot;,无论使用toCharArray还是使用&quot;𐐷 is good&quot;.charAt(i)遍历得到的都是</span><br><span class="line">2个代码单元，可以使用如下的条件判断来遍历输出字符串的各个码点。</span><br><span class="line">for(int i = 0; i &lt; test.length() - 1;) &#123;</span><br><span class="line">  int cp = test.codePointAt(i);</span><br><span class="line">  System.out.print(cp+&quot;,&quot;);</span><br><span class="line">  if (Character.isSupplementaryCodePoint(cp)) &#123;</span><br><span class="line">    i += 2;   // 补充字符占用2个代码单元</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">更简单的方法，使用intstream流。</span><br><span class="line">int codePoints = test.codePoints().toArray();</span><br><span class="line">for(int codePoint: codePoints) &#123;</span><br><span class="line">  System.out.print((char)codePoint + &quot;,&quot;);  //转换得到另一个特殊字符...</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.print(new String(codePoints, 0, codePoints.length())); //由数组反转得到字符串成功</span><br></pre></td></tr></table></figure></p>
<p>构建字符串<br>StringBuffer是多线程安全的，但性能不如StringBuilder,单线程时应使用StringBuilder.</p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>读取输入：可以使用System.console对象来从控制台获取密码<br>printf格式化输出：<br>% 1 $ , 8.2 f<br>参数索引 标志(用,区分3位) 宽度.精度 转换符号<br>注： 经测试(负数用括号括起与宽度标志冲突，只能使用一个。</p>
<p>文件输入与输出：<br>Scanner in = new Scanner(Paths.get(“D:\a.txt”)), “utf-8”);<br>PrintWriter out = new PrintWriter(“D:\b.txt”, “utf-8”);</p>
<h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>java break语句可以带标签，从而实现从内层循环跳出，C语言中使用goto语句，java没有goto.<br>另外java有foreach循环，C,C++没有。</p>
<p>块：<br>大括号内的内容叫做块，java不允许在嵌套块内重复定义相同变量，C++可以，它允许内层块覆盖外<br>层块的变量。</p>
<p>while语句的循环体可能一次也不执行，如果想循环体至少执行一次，可以使用<br>do{…}while(…)语句。</p>
<p>switch语句可能会导致执行多个case语句（在没有break语句的时候），所以一般程序中不使用switch<br>语句。（jdk 7之后case语句中可以为String类型）</p>
<p>带标签的break与continue语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label&#123;</span><br><span class="line">  ...</span><br><span class="line">  if(condition) break label;  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注： break与continue是可选的，完全可以避免使用它们（使用合理的判断条件即可）</p>
<h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><p>BigInteger和BigDecimal<br>可以使用valueOf将基本类型数值转换为bigInteger或bigDecimal类型</p>
<p>这2个对象加法用add方法，乘法用multiply方法…<br>注： C++可以自定义重载运算符，Java只重载了+号，它没有并且不允许程序员自己重定义重载运算符。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>java允许数组长度为0，长度为0的数组也是一个对象，可以用来作为方法返回值，避免返回null，造成<br>空指针。<br>数组扩容可以使用<br><code>luckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length);</code></p>
<p>java数组与C++数组指针基本一致，但它没有指针运算，即不能通过a加1得到数组的下一个元素。</p>
<p>数组排序可以使用Arrays.sort方法，它使用了快速排序算法，<br>使用Arrays.binarySearch方法实现二分查找<br>使用Arrays.fill方法将所有元素值设置为统一值<br>使用Arrays.equals方法比较两个数组是否相同</p>
<p>反转数组：</p>
<ol>
<li>面试时的回答<br>先Arrays.sort升序排列，再将第一个元素和最后一个元素互换，直到指针小于length/2(索引从0开始)</li>
<li><p>实际工作使用</p>
<ol>
<li><p>将数组转换为List,再用Collections.reverse(list)方法反转，最后用list.toArray(newArray)来<br>得到反转后的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer[] c = new Integer[5];</span><br><span class="line">c[0] = 8;</span><br><span class="line">c[1] = 3;</span><br><span class="line">c[2] = 6;</span><br><span class="line">c[3] = 5;</span><br><span class="line">c[4] = 2;</span><br><span class="line">Arrays.sort(c);</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br><span class="line">List&lt;Integer&gt; blist = Arrays.asList(c);</span><br><span class="line">Collections.reverse(blist);</span><br><span class="line">Integer[] newC = new Integer[c.length];</span><br><span class="line">blist.toArray(newC);</span><br><span class="line">System.out.println(Arrays.toString(newC));</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用commons.lang3包中的ArrayUtils工具类，支持int,float,object.<br>通过查看源码可见，它也是使用了前后元素交换的算法实现的</p>
</li>
</ol>
</li>
</ol>
<p>随机打乱数组：</p>
<ol>
<li><p>网上说比较经典的方法是用Arrays.sort(array, comparator)，其中comparator的compare方法<br>使用Math.random()来实现在比较时随机产生正负数从而实现乱序，但由于sort排序底层实现中无论是<br>插入还是快排的比较次数都做了优化，达不到全部元素两两比较的绝对乱序要求。下面是sort的java<br>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> Integer[] c = new Integer[5];</span><br><span class="line"> c[0] = 8;</span><br><span class="line"> c[1] = 3;</span><br><span class="line"> c[2] = 6;</span><br><span class="line"> c[3] = 5;</span><br><span class="line"> c[4] = 2;</span><br><span class="line"> System.out.println(Arrays.toString(c));</span><br><span class="line"></span><br><span class="line"> // Arrays.sort(c, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"> //         @Override</span><br><span class="line"> //         public int compare(Integer x, Integer y) &#123;</span><br><span class="line"> //                 double i = 0.5 - Math.random();</span><br><span class="line"> //                 int flag = i &lt; 0 ? -1 : (i &gt; 0 ? 1 : 0);</span><br><span class="line"> //                 System.out.print(flag + &quot;,&quot;);</span><br><span class="line"> //                 return flag;</span><br><span class="line"> //         &#125;</span><br><span class="line"> // &#125;);</span><br><span class="line"> Arrays.sort(c, (x, y) -&gt; &#123;</span><br><span class="line">   double i = 0.5 - Math.random();</span><br><span class="line">   int flag = i &lt; 0 ? -1 : (i &gt; 0 ? 1 : 0);</span><br><span class="line">   System.out.print(flag + &quot;,&quot;);</span><br><span class="line">   return flag;</span><br><span class="line"> &#125;);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure>
</li>
<li><p>想实现绝对乱序，每个元素都参与比较，可以使用Fisher-Yates shuffle算法，基本思路是通过<br>随机数得到一个随机索引，将索引的元素值和最后一个元素进行交换，然后是倒数第二个元素，依次<br>进行即可，这样每个元素都得到了比较和交换的机会，实现了绝对乱序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Integer[] c = new Integer[5];</span><br><span class="line">c[0] = 8;</span><br><span class="line">c[1] = 3;</span><br><span class="line">c[2] = 6;</span><br><span class="line">c[3] = 5;</span><br><span class="line">c[4] = 2;</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br><span class="line"></span><br><span class="line">int i = c.length;</span><br><span class="line">while (i &gt; 1) &#123;   // i = 1时picked和后面的i都为0，交换自身可省略,选随机数次数为c.length-1</span><br><span class="line">  int picked = new Double(Math.floor(Math.random() * i--)).intValue();</span><br><span class="line">  System.out.print(picked + &quot;,&quot;);</span><br><span class="line">  int tmp = c[i];</span><br><span class="line">  c[i] = c[picked];</span><br><span class="line">  c[picked] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注： javaCore书中的抽彩游戏算法与这里的洗牌算法思路相同，不同的是它不是原地排序，而是<br>将抽中的数字放到一个新数组中。</p>
<p>多维数组的快速打印可以使用Arrays.deepToString(array)方法</p>
<h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><p>必须是一个数组或一个实现Iterable接口的集合，才能使用foreach循环</p>
<h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><p>面向对象的程序设计过程</p>
<ol>
<li>识别类<br>简单的将名词作为类，动词作为方法<br>注：根据设计模式的解析，类的作用应该是封装变化，应将变化的部分作为一个类</li>
<li>绘制UML图确定类之间的关系</li>
</ol>
<h3 id="使用jdk包中预定义类"><a href="#使用jdk包中预定义类" class="headerlink" title="使用jdk包中预定义类"></a>使用jdk包中预定义类</h3><ol>
<li><p>对象与对象变量<br>java对象变量等同于C++中的对象指针<br>C++对象拷贝可以在类的内部进行，但Java只能通过clone方法。</p>
</li>
<li><p>访问器方法和更改器方法<br>Java更改器方法会修改类的对象状态，如set方法，而访问器方法不改变当前对象，如get方法。<br>C++中访问器方法有const后缀，而java中没有语法区别。</p>
</li>
<li><p>date<br>jdk8引入了LocalDate类，可以操作时间<br>常用api有now(),of(int year,int month,int day),getYear(),getMonthValue(),getDayOfMonth(),<br>getDayOfWeek(),plusDays(),minusDays(),进一步用法在卷2里有。</p>
</li>
</ol>
<h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><p>C++构造器可以省略new关键字正常运行，但Java不可以</p>
<p>C++可以在类的外部定义方法，在类内部定义的方法自动成为内联方法（直接用方法体替换方法调用<br>代码的操作为内联），Java方法是否内联需要由jvm决定，需要内联时首先方法必须为final修饰，<br>即时编译器才会判断是否需要内联。</p>
<p>LocalDate没有更改器方法，无法改变对象状态，Date有一个setTime方法，可以改变对象状态，<br>实际上破坏了对象的封装性。如get方法返回Date对象，实际上可以拿到这个date引用对原对象状态<br>进行改变从而带来危险。<br>所以，访问器方法应避免返回一个可变对象的引用，若无法避免，应当clone后再返回，从而保护<br>原对象的封装性。<br>注：java.time.LocalDate是一个不可变的，线程安全的类。</p>
<p>基于类的访问权限<br>一个类的方法可以访问所属类的所有对象的私有属性，这在C++中同样适用。</p>
<p>私有方法<br>如果不想自己的方法被他人调用，应当将方法设置为private,这样当以后删除该方法时就不用担心<br>有其他地方调用该方法了。</p>
<h3 id="静态域与静态方法"><a href="#静态域与静态方法" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h3><p>静态域<br>private static修饰一个域时，它也被称为类域，可以修改,但该域无法被其他类访问到(private)，<br>用public static final修饰常量时，因为常量不可变（final控制），所以可以用public修饰供其他<br>类使用，同时不用担心封装性被破坏。</p>
<p>注：private限制的是访问范围，static限制的是类变量-无需实例化即可使用。</p>
<p>静态方法<br>静态方法可以认为是没有this参数的方法，有2种情况使用它</p>
<ol>
<li>不需要对象状态，只需要显式参数。</li>
<li>只需要访问静态域的方法。<br>注： C++使用::访问自身作用域之外的静态域和静态方法。<br>C++与java中static关键字的意义是一样的：即属于类且不属于类对象的变量与函数。</li>
</ol>
<p>静态工厂优点</p>
<ol>
<li>因为构造器必须与类名相同，静态工厂不受此限制，相当于带名字的构造器。</li>
<li>构造器没有返回值，它构造的对象类型就是当前类，静态工厂可以构造当前类的子类对象返回，<br>更加灵活。</li>
</ol>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>值传递 call by value<br>引用传递 call by reference<br>java只有值传递，针对基本数据类型很好理解，被传的参数值无法被改变;针对对象引用类型，java<br>会拷贝一份该对象的引用，该引用和原参数对象引用指向同一个对象，改变其中一个另外一个引用也受到<br>了影响，从而实现了改变对象的目的。</p>
<p>证明java是值传递-即拷贝了引用的值，而不是引用传递-传递对象地址的是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">  public void main(String[] args)&#123;</span><br><span class="line">    P a = new P(1);</span><br><span class="line">    P b = new P(2);</span><br><span class="line">    swap(a,b);     </span><br><span class="line">     //执行可以发现swap没有生效，因为swap内交换了拷贝的引用，对原来的a,b对象引用无影响</span><br><span class="line">    System.out.println(a.getId());</span><br><span class="line">    System.out.println(b.getId());</span><br><span class="line">  &#125;  </span><br><span class="line">  public static void swap(P x, P y)&#123;</span><br><span class="line">     P tmp = x;</span><br><span class="line">     x = y;</span><br><span class="line">     y = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class P&#123;</span><br><span class="line">  private int id;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个程序可以总结出下面这个关键的结论：<br><strong>一个java方法不能让参数对象指向一个新的引用，它在方法内始终是以拷贝的形式存在的。</strong></p>
<p>这一点从以下代码片段看的更清楚：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">  public void main(String[] args)&#123;</span><br><span class="line">    P a = new P(1);</span><br><span class="line">    newP(a);</span><br><span class="line">    System.out.println(a.getId());  //还是打印1</span><br><span class="line">  &#125;  </span><br><span class="line">  public static void newP(P x)&#123;</span><br><span class="line">    x = new P(888);    // 对传递进来的a对象无影响</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class P&#123;</span><br><span class="line">  private int id;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>方法无法改变基本类型的参数对象。</li>
<li>方法可以改变引用类型对象的状态。</li>
<li>方法无法将引用类型参数对象指向一个新的引用。</li>
</ol>
<p>注：C++有值传递和引用传递，引用参数使用&amp;来进行标识。</p>
<h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><p>重载<br>方法签名不能重复，它包括方法名和参数类型，返回值不是签名的一部分</p>
<p>域初始化<br>java可以直接初始化各个域，C++不行，C++只能在构造器中对域进行设值，但它有特殊语法连续调用<br>多个构造器。</p>
<p>参数名<br>C++通常对实例域加上特定的前缀<code>_</code>,x,m等，java没有。</p>
<p>调用另一个构造器<br>java可以使用this(…)来调用另一个构造器,这样可以使得公共构造器编写一次即可。<br>C++无法进行构造器间调用,必须将公共部分编写成一个独立的方法。</p>
<p>构造器执行顺序</p>
<ol>
<li>所有域被初始化成默认值。</li>
<li>按照声明顺序依次执行域初始化语句和初始化块。</li>
<li>如果第一行调用了其他构造器，执行其他构造器。</li>
<li>执行接下来的构造器主体。</li>
</ol>
<p>注：jdk 6以前可以使用静态初始化块来打印hello world，jdk7以后则会先检查是否有main方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line"> static &#123;</span><br><span class="line">  System.out.println(&quot;hello world&quot;); //类第一次加载的时候会进行静态域的初始化</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++有显式的析构器方法，Java因为有自动垃圾回收机制，所以不需要手动回收内存。<br>finalize方法会在垃圾回收器清除对象前被调用，但无法确定时间,所以不推荐使用它。</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包名层级通常是域名的倒序。以前没有注意过这一点，这样我写的代码包应为cn.taoblog</p>
<p>一个类可以使用所属包中的其他类和其他包中的公有类。<br>由此可知，同私有方法一样，如果不想外界调用该类，可以将其设置为私有类，仅供同包的其他类使用。<br>这种情况该私有类一般作为内部类。</p>
<p>静态导入<br>import是导入一个类，import static可以导入静态方法和静态域，如使用<br><code>import static java.lang.System.*</code>之后可以将<br><code>System.out.println(...)</code>直接写为<code>out.println(...)</code></p>
<p>不过实际这样写不好理解，可以针对特定类使用，如<br><code>sqrt(pow(x,2) + pow(y,2))</code>比<br><code>Math.sqrt(Math.pow(x,2) + Math.pow(y,2))</code>要清晰很多。</p>
<p>编译器不会检查目录结构，即如果package声明错误，如果该类没有依赖其他包，编译不会报错，<br>程序可以正常执行…<br>(经实际测试，比如一个在目录com.demo下的类Test，如果包声明为com,编译后可以发现它的class<br>文件是出现在target/com目录下的。同样的javac命令指定-d选项时它也是根据包声明来生成字节码<br>文件目录的(如javac -d . Test.java)，这样如果Test类中需要引用com.demo包下的其他类时，<br>同样需要import语句，这就违反了目录和包的一致性，造成程序理解困难和隐藏问题，<br>所以包声明报错虽然不影响程序编译和运行，但可能会需要不必要的import和其他潜在问题)</p>
<p>类或域如果没有public，private修饰，默认是同一个包内的方法可以访问到（default).<br>而默认情况下，包是可见的，即任何人都可以向一个包中添加更多的类，如在自定义的类中修改<br>package声明，并将该类放置在对应目录下即可访问目标包中的其他类。</p>
<p>jdk本身由于修改了类加载器，禁止加载用户自定义的，包名以java.开始的包来达到安全防范的目的，<br>但用户自己的包没有这个特性，不过可以通过包密封(package sealing)机制来解决这个问题。<br>包被密封之后，就不能再向这个包中添加类了。<br>(经实际测试，自定义一个包java.mypack,实例化其中的类编译成功，运行报错<br>java.lang.SecurityException: Prohibited package name: java.mypack,<br>说明了自定义包不能以java开头)</p>
<p>可以使用jdk自带的jar工具来生成自己需要的jar包。可以使用如下命令来指定Manifest文件：<br>先新建一个名为manifest.txt的文件，内容可以为<br><code>Sealed: true</code> // 需要一个回车才能生效<br>然后执行命令<br><code>jar cvfm  XXX.jar .\manifest.txt .</code>(可以查看jar –help)</p>
<p>而jar包是否密封可以通过Manifest中的<code>Sealed: true</code>进行配置，可以指定多个包或整个jar包<br>进行密封，如果包密封后发现有相同包在不同类中的情况出现，会抛出sealing violation异常。<br>主要有以下2种情况：</p>
<p>(在URLClassLoader类的源码中可以看见)</p>
<ol>
<li>尝试加载一个已经被密封的包,报错sealing violation: package is sealed.</li>
<li>尝试密封一个已经被加载的包，触发安全异常，报错sealing violation: already loaded.</li>
</ol>
<p>这样，包密封增强了版本的一致性和安全性。<br>(查看spring和mybatis的jar包可以发现它们都没有进行包密封，应该是开源的原因，不过目前都是<br>统一由maven或gradle统一管理jar包，也不用担心这个问题，自己的项目产品还是应注意这个问题。)</p>
<p><a href="https://dev.tencent.com/u/wutaotao/p/mybatis-demo/git/tree/master/self-stuff/src/main/java/com" target="_blank" rel="noopener"><strong>密封性测试代码地址</strong></a></p>
<p>测试时先将Test1,Test2打成jar包(注意检查生成的jar包的包目录结构和MANIFEST.MF文件内容)，<br>然后注释掉相应代码，运行TestSealException类来进行测试，因为类加载后无法卸载，所有需要<br>一个个案例单独测试。<br>结论在代码中已指出：</p>
<ol>
<li>sealing violation: package is sealed.</li>
<li>sealing violation: already loaded.</li>
<li>sealed package不包括被密封的父类包</li>
<li>sealed package不包括被密封的子类包</li>
</ol>
<p>关于jar和包密封性在javacore version10的第13章，书中说第9章，也算一个小错误。</p>
<h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><p>类路径是所有包含类的路径的集合。<br>windows中用;分隔，unix下中用:分隔。<br>(刚学java时配置环境变量我们被要求配置classpath变量(这是不好的行为)，其值类似为<br><code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code>，其中.代表当前目录，默认的类路径中包含了<br>当前目录，如果自定义的类路径中少了.,会导致类编译通过，运行失败，具体测试如下：<br>使用javac命令进行编译时注意包结构，如以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javac .\com\demo\Test.java</span><br><span class="line">java com.demo.Test   //测试成功</span><br><span class="line">java -classpath %JAVA_HOME%\lib com.demo.Test   //运行失败，报错找不到或无法加载主类Test</span><br><span class="line">java -classpath %JAVA_HOME%\lib;. com.demo.Test   //加上当前目录后运行成功</span><br></pre></td></tr></table></figure></p>
<p>)<br>虚拟机搜寻一个类时，首先查看jdk自带的lib中是否包含，若未找到，再根据类路径进行逐个查找。</p>
<p>注：java -jar运行jar包时会屏蔽环境变量和命令行中的classpath，可以使用下列方法来引用其他的<br>jar包：</p>
<ol>
<li>-Xbootclasspath/a: 后缀。将classpath添加在核心class搜索路径后面。常用!!</li>
<li>在jar包内的MANIFEST.MF文件中添加<code>Class-Path: XXX.jar</code>,路径为该jar包对当前jar包的<br>相对路径。</li>
</ol>
<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>只需要对公有域(静态常量)建立注释<br>生成javadoc文档<br><code>javadoc -d D:\javadoc\ com.demo</code><br>若想生成的文档详细，文档注释需要很详细</p>
<h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ol>
<li>保证数据私有<br>即不要破坏封装性，如访问器方法返回一个可变对象显然不行，应clone后再返回。</li>
<li>明确初始化数据</li>
<li>不要使用过多基本类型<br>可以将部分域分离为另外一个类，实现类的单一职责和灵活性</li>
<li>不是所有域都需要get和set方法</li>
<li>职责过多的类分解<br>同3</li>
<li>类名和方法名要体现职责<br>命名明确</li>
<li>优先使用不可变的类<br>同1保护封装性原则</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>is-a关系是继承的一个明显特征。<br>注： java中所有继承都是共有继承，没有C++中的私有继承和保护继承。</p>
<p>子类虽然继承了父类的域和方法，但由于域的私有性，子类中不能直接访问这些域，所以它需要通过<br>访问器来访问这些域，如调用<code>super.getId()</code>来获取。<br>注：C++中使用父类名::方法名来获取父类域的值，如<code>Parent::getId</code>.</p>
<p>同样的，子类的构造器也无法直接访问这些私有的父类域，所以需要通过如<code>super(id,name)</code>调用<br>父类的构造器来对这些域进行初始化。<br>注： 调用其他构造器的语句必须是第一条语句，如<code>this(xxx,xxx)</code>,<code>super(xxx,xxx)</code>.</p>
<p>如果没有这样显式的调用父类构造器时，默认调用父类的无参构造器，如找不到编译器会报错。<br>注：C++不使用super调用父类构造器，它使用初始化列表，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manager::Manager(String name,int salary)</span><br><span class="line">: Employee(name, salary)</span><br><span class="line">&#123;</span><br><span class="line">  bonus = 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注： 经测试，子类会继承父类实现的接口，如父类实现了记号接口RandomAccess,子类对象使用<br>instanceof关键字可以测试出子类也实现了RandomAccess接口。另外，子类中与父类的同名属性<br>不会覆盖父类的属性，它们可以拥有不同的值。</p>
<p>多态： 一个变量可以指示多种实际类型的现象叫多态。<br>动态绑定： 运行时能自动选择调用哪个方法的现象叫动态绑定。<br>注： java中动态绑定是默认行为，不用声明为虚拟方法(C++中需要),可以声明为final来取消虚拟特征。</p>
<p>子类和父类数组转换问题<br>有如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">&#125; </span><br><span class="line">class Child extend Parent&#123;</span><br><span class="line">&#125; </span><br><span class="line">public class Test &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">     </span><br><span class="line">   Child[] cs = new Child[];</span><br><span class="line">   Parent[] ps = cs;   // 子类元素数组向上转型为父类元素</span><br><span class="line">   ps[0] = new Parent();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上代码编译成功，但运行时报错java.lang.ArrayStoreException,因为ps[0]和cs[0]指向的是<br>同一个对象，ps[0] = new Parent()就相当于cs[0] = new Parent(),父类转化为子类，从而引起<br>了数组存储异常。因编译器无法检查出这个问题，所以当使用数组时，需要牢记它的元素类型，只<br>向其中存储能够转化为该元素类型的元素。</p>
<p>对象调用过程x.f(args)</p>
<ol>
<li>查找对象x类型和方法名f</li>
<li>重载解析(子类重写方法返回值可以为父类方法的子类型，称为具有可协变的返回值类型，同时<br>重写的子类方法的可见性(public,private等)不能低于父类方法.</li>
</ol>
<p>经测试，父类私有(private)的方法不能被重写(破坏了封装性),其他default,protected,public可以<br>被重写，如果子类的可见性更低，如父类是protected,子类是private,那么根据替换原则(子类可以替代<br>所有父类对象出现的地方)子类可见性更低可能会导致原代码无法访问的情况，所以重写的方法需要<br>可见性更强来避免这个问题，这种情况编译器会报错：attempting to assign weaker access privileges.)<br>这样看，public access privilege is strongest.</p>
<ol start="3">
<li>如果方法是private, static,final修饰或构造器，则编译器可以准确找到需要调用的方法，这<br>称为静态绑定，相反，调用方法依赖于对象x的实际类型称为动态绑定(多态)。</li>
<li>动态绑定时，会从最接近x实际类型的方法开始匹配，如子类无该方法，会在它的父类去查找，<br>依次类推。</li>
</ol>
<p>为了加快方法查找过程，虚拟机会为每个类生成一个方法表，列出它的所有方法(包含继承自父类的<br>方法)。即在查找需要调用的方法时，虚拟机根据实际对象类型调出对应类的方法表，在该表中查找<br>对应的方法并进行调用即可。</p>
<p>阻止继承：final类<br>使用final修饰的类无法被继承(public final class A{}),<br>使用final修饰的方法无法被重写(public final void B(){}),<br>由于final类无法被继承，它里面的方法都是final方法，没有子类，没有重写,final修饰符不用<br>写明。但是它的域没有自动变为final，实例化后还是可以改变值的。<br>(经测试，声明域为final后，编译器会检查是否有赋予初始值，可以在域声明后赋予初始值，也可以<br>在无参构造器中赋值，只在有参构造器中赋值无效，同时如果有对该域的set方法存在，编译器同样<br>会报错: cannot assign value to final variable)</p>
<p>注：C++和C#中，所有方法默认都没有多态性，相当于默认全都加了final修饰，无法被重写。</p>
<p>早期的时候，使用final修饰一个方法，编译器检测到该方法没有被覆盖并且很简短，编译器就会对它<br>进行内联处理。<br>现在即时编译器处理能力强很多，如果方法简短，频繁被调用并且没有被覆盖，它会自动进行内联处理，<br>如果虚拟机加载了另一个类，它有覆盖该内联的方法，虚拟机又会取消内联。</p>
<p>向下转型<br>父类对象可以强制转换为子类对象，如果转换不成功，会抛出ClassCastException.<br>应养成判断的习惯(if xxx instanceof yyy)<br>另外，如果强转类型不是子类，编译器会报错。<br>注： null instanceof XXX 是false,不会产生空指针异常<br>注2： 如果碰到需要强制转型的情况，应考虑父类的设计是否合理。<br>注3： 强制转型类似于C++中的<code>dynamic_cast</code>操作，只是如果转换失败，它不会抛出异常，而是生成<br>一个null对象。类型测试和转换代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child* ch = dynamic_cast&lt;Parent*&gt;(pa);</span><br><span class="line">if (ch != null) &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象类<br>有一个或多个抽象方法的类必须被声明为抽象类。<br>反过来，抽象类中可以没有抽象方法。<br>抽象类无法被实例化，但可以作为变量引用非抽象子类的实例。<br>注：C++中用尾部 = 0的方式来标记一个抽象方法，称为纯虚函数。<br>有纯虚函数即为抽象类，C++中没有抽象类的关键字。</p>
<p>受保护访问<br>protected访问范围是所有子类以及同包的其他类，这与C++的保护机制不同。<br>protected域由于可以被子类直接访问到，变动父类时需要通知子类，违反了封装性。protected方法<br>适用性强一点。</p>
<p>Object<br>Object是所有类的超类，包括基本数据类型和引用类型的数组！如<code>Object obj = new int[3];</code><br>只有基本类型(数值，字符，布尔)不是对象——通过自动装箱技术它们会转成对应的包装类。<br>注：C++没有超类，但指针都可以转成<code>void*</code>.</p>
<p>equals方法<br>Object的equals方法只有一句<code>return this==obj</code>,它只比较2个对象的地址。<br>如果想要调用this或obj的equals方法进行自定义比较，可以使用<code>java.util.Objects</code>(jdk7引入)的<br>equals方法<code>return （a == b) || (a != null &amp;&amp; a.equals(b))</code>.</p>
<p>(经测试，如Child类继承Parent类，则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child ch = new Child();</span><br><span class="line">if (ch instanceof Parent) &#123;...&#125;  // 表达式为true</span><br></pre></td></tr></table></figure></p>
<p>即instanceof是检测对象是否是后者的实例或子类实例，在equals方法中检验2个对象的类型是否相同，<br>以前是使用instanceof来进行检验，但根据equals要求的对称性(x.equals(y)与y.equals(x)结果相同)<br>, 当parent.equals(child)为真时，child.equals(parent)也为真，这样就使得Child类中的equals方法<br>无法对Child类扩展的域进行检验的问题，这个问题本质还是出在instanceof关键字允许子类也为真的<br>情况上。<br>针对这个问题，有2种情况，一个是子类的扩展域不影响相等性，即不进入比较的话，可以使用<br>instanceof关键字，另一个是如果扩展域也需要比较的话，就不能使用instanceof关键字，可以使用<br>getClass()来明确指定类必须相同;所以如果一个类的equals方法使用了instanceof关键字，那么<br>它的子类重写equals方法就几乎没有意义了，因为如果它比较了扩展域，就违反了对称性原则，所以<br>一般应该将instanceof与final修饰符配合使用，反之则使用getClass()方法)</p>
<p>注：该问题具体案例可见jdk源码中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类： java.util.Date  其中的equals(Object obj)方法使用了instanceof</span><br><span class="line">子类： java.sql.Timestamp  其中equals(Object obj)方法中注释指明了这一点</span><br><span class="line">&quot;Note: This method is not symmetric with respect to the equals method in the base class&quot;</span><br></pre></td></tr></table></figure></p>
<p>注：equals方法应满足自反性，对称性，传递性，一致性。</p>
<p>完美equals方法建议:方法签名为equals(Object otherObject)</p>
<ol>
<li>if (this == otherObject) return true; 是否是同一个对象</li>
<li>if (otherObject == null) return false; 是否为null</li>
<li>if (getClass() != otherObject.getClass()) return false; // 不用instanceof<br>或 if(!(otherObject instanceof  ClassName)) return false;<br>// 建议方法更改为final，final可以与@Override共存</li>
<li>若使用了instanceof，将其强制转换类型</li>
<li>return 各个域的比较结果，基本类型使用==，引用类型使用java.util.Objects的equals方法，<br>它可以进行null值判断和调用域自身的equals方法，数组类型使用Arrays.equals方法。</li>
</ol>
<p>hashCode方法<br>Object的hashCode方法默认是对象的存储地址。<br>一般来说：</p>
<ol>
<li>将对象放入容器中，需要重写equals方法，可以通过比较对象内容来进行判定业务上对象相等。</li>
<li>将对象放入散列表中(如HashMap,HashSet等),需要重写hashCode方法，以保证equals相等的2个<br>对象在散列表中对应着同一个键！</li>
<li>将对象放入有序列表中，需要实现Comparable接口，重写compareTo(T o)方法，或者自定义一个外部<br>比较器Comparator,重写compare(T o1, T o2)方法。</li>
</ol>
<p>针对多个域的hashCode计算可以调用java.util.Objects.hashCode(Object… values)方法，其中有<br>对null值的处理。<br>如上面总结的一样，equals方法返回true时，hashCode方法也必须返回true.<br>具体表现为equals处理的域必须出现在hashCode方法中。<br>注： 数组类型的域可以使用Arrays.hashCode方法。</p>
<p>toString方法<br>查看Object的toString源码可见toString方法为<br><code>return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</code><br>可以看出对象默认输出的是类名+哈希码的16进制表示，数组也是Object类型，<br>只不过它前面的类名比较特别，如[I表示的是整型数组，[Lcom.demo.Test;@XXX表示的是对象Test数组</p>
<p>泛型数组列表-ArrayList<br>java5以后提供了泛型，使用时可以省略右边的泛型参数<br><code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(100);</code><br>ArrayList默认大小是10。<br>注：arraylist类似于C++中的vector,vector可以使用[]来访问元素，因为它重载了[]运算符，<br>另外vector a = b;语句会重新拷贝一个vector赋给a,而ArrayList a = b;只是让a,b指向同一个<br>引用。</p>
<p>arraylist使用add,set,get方法来对元素进行控制，某些情况下转换成数组更加方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;P&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(new P(1));</span><br><span class="line">list.add(new P(2));</span><br><span class="line"></span><br><span class="line">P[] pa = new P[list.size()];</span><br><span class="line">list.toArray(pa);</span><br></pre></td></tr></table></figure></p>
<p>泛型仅在编译时有效，编译成的字节码中没有任何泛型参数，即类型擦除。<br>这个特性会造成以下问题：</p>
<ol>
<li>泛型重载无效(编译报错)，</li>
<li>泛型类中静态域共享(不同泛型类对应同一个类),</li>
<li>捕捉异常catch语句内泛型参数无效(java运行时处理异常)</li>
</ol>
<p>自动装箱<br>所有的对象包装器类都是不可变，无法继承(final)的。<br>通过反编译代码<code>Integer a = 100</code>编译后的字节码，可以发现对于自动装箱，编译器会自动调用<br><code>Integer.valueOf(100)</code>方法，同理自动调用<code>i.intValue()</code>方法。<br>即自动装箱和泛型参数一样，属于编译器层面的操作，与虚拟机无关，可以看作语法糖。</p>
<p>自动装箱规范要求boolean,byte,char&lt;=127, short and int between -128 to 127这之间的数值<br>被包装到固定的对象中，所有有以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 100;</span><br><span class="line">Integer b = 100;</span><br><span class="line">Integer c = 1000;</span><br><span class="line">Integer d = 1000;</span><br><span class="line">System.out.println(a == b); // true: same wrapping objects</span><br><span class="line">System.out.println(c == d);  // false: different wrapping objects</span><br><span class="line">Character e = (char)128;</span><br><span class="line">Character f = (char)128;</span><br><span class="line">System.out.println(e == f);  // false: different wrapping objects</span><br><span class="line">Character g = (char)127;</span><br><span class="line">Character h = (char)127;</span><br><span class="line">System.out.println(g == h); // true: same wrapping objects</span><br></pre></td></tr></table></figure></p>
<p>自动装箱在运算符中也能自动进行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 10;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure></p>
<p>包装器内还包含了如<code>int i = Integer.parseInt(string)</code>这样对于不同类型间转换的静态方法。</p>
<p>注：包装器是不可变的，所以方法参数值传递也无法通过包装器对象来改变值，可以使用如IntHolder<br>类（jdk自带）来变更基本类型的值，它的域value是public访问权限，这样通过改变参数对象状态来<br>改变基本类型值。</p>
<p>可变参数<br>可变参数也是编译器层面的语法糖，它将实际传入的多个参数转化为对应的数组。<br>反过来，如果原来代码的最后一个参数是数组类型，就可以将它变为可变参数，这样对生成的字节码<br>文件没有任何变化。如<code>public static void main(String[] args){}</code>可变为<code>public static void
main(String... args){}</code>.</p>
<p>枚举<br>枚举也是编译器层面的语法糖，它将枚举类编译成一个继承了Enum类的final类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Size&#123;</span><br><span class="line"></span><br><span class="line">  SMALL(&quot;s&quot;), MEDIUM(&quot;m&quot;), LARGE(&quot;l&quot;); // 调用构造器创建多个枚举实例</span><br><span class="line"></span><br><span class="line">  private String abbr;   // 自定义域</span><br><span class="line">  private Size(String abbr)&#123;//私有构造器</span><br><span class="line">     this.abbr = abbr;</span><br><span class="line">  &#125;  </span><br><span class="line">  public String getAbbr()&#123;return abbr;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译后使用<code>javap Size.class</code>进行反编译可以看到生成的枚举类。<br>上面例子中S,M,L都是Size类的public static final实例，<br>可以使用<code>Size size = Size.S</code>直接得到一个枚举值。<br><code>size.toString()</code>得到枚举常量名，<code>Size s = Enum.valueOf(Size.class, &quot;S&quot;);</code>可以通过字符串<br>得到枚举值。<code>Size.values()</code>返回一个包含所有枚举值的数组，(Enum类中的valueOf与枚举类中参数<br>不同，并且Enum也没有values方法，它们应该是编译器自动添加的),Enum和枚举类都有ordinal()方法<br>返回枚举的索引值，从0开始。compareTo方法比较的即为2个枚举的索引大小。</p>
<p>反射<br>获取class对象</p>
<ol>
<li>object.getClass();</li>
<li>Class.forName(“XXX”);</li>
<li>T.class (如Random.class, int.class, Double[].class)<br>Class类实际是一个泛型类，如String.class类型为<code>Class&lt;String&gt;</code>，大多数时候可以忽略这个泛型<br>参数，直接使用原始class类。<br>可以使用==来比较2个class对象是否相同，使用<code>Class.forName(&quot;XXX&quot;).newInstance()</code>来根据字符串<br>调用无参构造器得到一个对象。(调用有参构造器需要Constructor类)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class P&#123;</span><br><span class="line">  private int id;</span><br><span class="line">  public P(int id)&#123;this.id = id;&#125;</span><br><span class="line">  public int getId()&#123;return id;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   Class pc = P.class;</span><br><span class="line">   try&#123;</span><br><span class="line">     Constructor con = pc.getConstructor(int.class);  // 获取构造器，带上参数类型</span><br><span class="line">     P p = con.newInstance(667);  // 调用有参构造器</span><br><span class="line">     System.out.println(p.getId());</span><br><span class="line">   &#125;catch(Exception e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>捕获异常<br>异常分2种，已检查异常(需要使用try-catch捕获)和未检查异常(如空指针等)<br>对于已检查异常，如果没有进行捕获，编译器会报错：unhandled exception.</p>
<p>利用反射分析类<br>Class类的getFields,getMethods,getConstructors方法返回类提供的公有域，方法，构造器(fields和<br>methods会包含父类的公共域和方法，构造器只会显示本类构造器，另外不会显示未写明的默认无参构造器),<br>getDeclaredFields,…Methods,…Constrcutors方法会返回类声明的所有域，方法和构造器，包括<br>私有和保护成员(它们都只针对本类，不包括父类信息)。<br>(getDeclaredFields如果class是基本类型或数组类型，或者没有任何域，它将返回一个长度为0的数组。)</p>
<p>Field, Method, Constructor常用方法<br>all.getName(),<br>F.getType(),<br>M&amp;C.getParameterTypes(),<br>M.getReturnType(),<br>all.getModifiers()    // 返回int值以指示修饰符</p>
<p>注：使用Modifier.toString(int i)可以获得修饰符的字符串表示。<br>Modifier.isFinal(int i)可以判断修饰符是否是final，其他方法同理。</p>
<p>利用反射分析对象<br>对于编译时无法确定域值的对象(如外界传递过来的参数对象)可以利用反射得到它的域值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line"> private int bonus;</span><br><span class="line"> public C(int bonus) &#123;this.bonus = bonus;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">   C c = new C(1000);</span><br><span class="line">   Field[] fields = c.getDeclaredFields();</span><br><span class="line">   for(Field f : fields) &#123;</span><br><span class="line">     System.out.println(f.get(c)); //编译器报错unhandled exception:IllegalAccessException</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为bonus是私有的，所以无法直接访问，即反射受到访问权限限制。<br>这时需要调用Field,Method,Constructor共同父类AccessibleObject中的一个方法<br><code>setAccessible(true)</code><br>来解除限制。这里f.get(c)返回的是object类型，进行了自动装箱，如果想返回int，<br>可以使用getInt()方法，同理getDouble()等。</p>
<p>ObjectAnalyzer程序分析：<br>class.isArray()  判断class类型是否是数组<br>class.isPrimitive()   判断class类型是否是基本类型：<br>   boolean,character,byte,short,integer,long,float,double,void(java.lang.Void)<br>class.getComponentType()  返回数组元素类型，如果不是数组class返回null</p>
<p>Array.getLength()   java.reflect.Array类中的方法，返回数组长度<br>Array.get(Object, int) java.reflect.Array类中的方法，返回数组中第i个元素值<br>AccessibleObject.setAccessible(AccessibleObject[], boolean) 对AccessibleObject数组统一赋予<br>   访问权限，其子类包括Constructor, Field, Method<br>Modifier.isStatic()  判断是否是static修饰符，程序中不打印静态域<br>field.getType()  获取域类型，程序中判断是否是基本类型<br>field.get(Object) 获取域的值对象<br>field.set(Object classObj, Object newvalue)  使用新值替换object中的当前域</p>
<p>class.getSuperclass()  获取当前class类的父类 </p>
<p>注：程序执行是先打印本类的非静态域类型和值，然后是逐层向上，查看父类的非静态域值，所以可以<br>看到每个类后都至少有一个<code>[]</code>(因为java.lang.Object类无域);<br>同时可以看到它把ArrayList的初始值10个后面未用到的null值元素都打印出来了;<br>实现循环引用很简单，在类中定义一个自身的实例指向this即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line"> private C c = this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用反射编写泛型数组<br>使用<code>System.arrayCopy(oldArray, startIdx, newArray, startIdx, length)</code>来扩充数组时，在编写<br>泛型化时，由于Object[]无法强转为具体的数组类型，所以需要通过java.reflect.Array来获取具体的<br>数组元素类型并进行初始化，主要用到以下三个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class.isArray()  判断class类型是否是数组</span><br><span class="line">class.getComponentType()  返回数组元素类型，如果不是数组class返回null</span><br><span class="line">Array.getLength()   java.reflect.Array类中的方法，返回数组长度</span><br><span class="line">Array.newInstance(Class componentType, int length)  元素类型和数组长度(一维) </span><br><span class="line">Array.newInstance(Class componentType, int... dimensions)  元素类型和数组长度(多维)</span><br></pre></td></tr></table></figure></p>
<p>newInstance方法可以让我们动态的创建一个与原数组相同类型的空数组，这样再使用System.arrayCopy()<br>方法即可以获得一个可以进行强转的数组了。<br>(基本类型数组拷贝需要方法的参数和返回值为Object,因为如int[]可以转成Object,无法转成Object[]，<br>反过来这样Object也可以强转为int[])</p>
<p>方法指针<br>可以通过<br><code>class.getMethod(String methodName, Class... parameterTypes)</code><br>指定方法名和参数类型列表(完整方法签名区别重载)来获得方法指针，再通过<br><code>method.invoke(Object implicitObject, Object... parameters)</code><br>指定调用的隐式和显式参数来调用该方法。<br>通过invoke方法进行回调比直接调用速度要慢一些，所以一般不推荐使用，建议使用接口或lambda表达式。</p>
<p>继承设计技巧</p>
<ol>
<li>公共操作和域放在超类中</li>
<li><p>不要使用protected域<br>protected域子类和同包类都能访问，破坏了封装性。<br>protected方法适用于不能作为公共public接口，同时需要在子类中重新定义的方法<br>(default只有同包可见，经测试在其他包中定义的子类无法重写父类方法，同理父类private方法<br>子类不可见，也不可重写，由此可见，是否能重写受到被重写方法能否被子类访问的限制，不一定<br>是这个原因，但可以这样记忆)。</p>
<p>注：static是静态绑定，重写多态是动态绑定，运行时确定，所以static方法不能被重写。</p>
</li>
<li><p>继承是is-a关系，不是的情况应不使用继承。</p>
</li>
<li>除非继承的所有方法都有意义，否则就不应使用继承。 </li>
<li>覆盖方法时不要偏离该方法最初的设计目的，预期行为。 </li>
<li>如果代码有对于不同类型的判断并进行相同概念的行为，应使用多态或接口实现。</li>
<li>不要过多使用反射，因为编译器难以发现错误。</li>
</ol>
<h2 id="接口，lambda表达式，内部类"><a href="#接口，lambda表达式，内部类" class="headerlink" title="接口，lambda表达式，内部类"></a>接口，lambda表达式，内部类</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口中的方法默认public，public可省略，所以重写接口方法时必须为public(重写访问限制)<br>接口没有实例域，<br>jdk8之后可以实现简单方法。</p>
<p>如实现<code>Comparable&lt;T&gt;</code>接口，重写compareTo(T t)方法。<br>因为Arrays.sort(Object[] obj)源码实现中进行了Comparable强转并使用compareTo方法，<br>所以如果obj中元素类型没有实现Comparable接口，会在运行中报错ClassCastException，而关于这点，<br>编译器并不会给出报错信息。<br>注：compareTo方法与equals方法一样，关于继承重写有对称性的问题(x.compareTo(y) &lt; 0则<br>y.compareTo(x) &gt; 0)，解决方法也类似，分2种情况：</p>
<ol>
<li>比较时涉及到子类属性时，应使用getClass()方法进行类型判断，类型相同才进行比较，否则抛出<br>类型转换异常。</li>
<li>比较时不涉及子类的属性，应在父类中定义compareTo方法并定义为final.<br>(经测试情况2,父类实现了泛型的Comparable接口，子类就不能实现自己的泛型类型了，编译器报错(XXX<br>interface cannot be inherited with different type arguments)，因为子类会继承父类的接口类型。<br>这样在对子类数组进行排序后，虽然实现了排序，但其中的元素都自动向上转型为父类类型了…)</li>
</ol>
<p>接口特性<br>同抽象类一样，不能使用new运算符实例化一个接口。<br>同抽象类一样，可以声明接口变量，指向接口的实现类。<br>可以使用instanceof关键字判断一个对象是否实现了某一个接口，如<code>obj instanceof Comparable</code>.<br>接口中的方法默认public,接口中的域默认public static final,<br>实现了接口的类自动继承了接口中的常量，可以直接使用如NORTH,而不用使用TestInterface.NORTH。</p>
<p>接口和抽象类的区别</p>
<ol>
<li>方法实现：抽象类可以有方法实现，作为普通方法可以被子类继承，接口在jdk1.8以后可以定义<br>默认方法和静态方法，在这一点上两者相同。</li>
<li>继承或实现：抽象类使用extends来继承抽象类，子类如果不是抽象类，需要实现父类的所有抽象<br>方法;接口使用implements实现接口，需要实现类实现所有抽象方法。</li>
<li>构造器：抽象类可以有构造器，接口不能有(定义时报错abstract method cannot have body)</li>
<li>访问修饰符：抽象类没有限制，接口方法默认public,无法修改。</li>
<li>main方法： 抽象类有，接口没有</li>
<li>多继承： 抽象类只能继承一个类，接口可以继承多个接口</li>
<li>添加新方法： 抽象类添加了新方法，如果有具体实现，不影响子类，同理接口的默认方法也不影响。<br>如果添加的是抽象方法，抽象类的子类和接口实现类都需要提供该方法的具体实现。</li>
</ol>
<p>注： C++支持多继承，带来了很多复杂特性，也很少被使用。</p>
<p>静态方法<br>jdk8中接口可以定义静态方法，以前静态方法通常是放在伴生类中，如Collection/Collections,<br>Path/Paths，jdk8以后可以合并到接口中。</p>
<p>默认方法<br>jdk8后接口可以使用default关键字定义默认方法。<br>定义了默认方法后实现类就可以不必强制实现这些默认方法了，同抽象类一样，可以让某些方法提供<br>默认行为，从而实现类无需管理。<br>默认方法可以调用任何其他方法，包括抽象方法。</p>
<p>接口演化(interface evolution): 指接口新增了一个抽象方法，遗留的类重新编译会由于没有实现<br>该方法而产生编译错误，如果不重新编译(如使用jar包),在遗留类的实例上调用该新增方法将抛出异常，<br>默认方法即解决了这个问题。重新编译时遗留类不必实现默认方法，调用新方法时也会直接调用接口的<br>方法。</p>
<p>解决默认方法冲突<br>一个接口定义了一个默认方法，又在超类或另一个接口中定义了同样的方法，会发生什么？<br>1.超类优先。超类方法会覆盖所有同名同参数类型的默认方法。<br>2.接口冲突。实现类实现了2个接口，这2个接口都实现了相同的方法，编译器报错：<br><code>inherits unrelated defaults for XXX() from I1 and I2</code>,<br>这时首先需要在实现类中重写这个方法，在该方法内可以通过如<code>I1.super.XXX();</code>的方法来调用I1或<br>I2的默认方法。<br>注： 如果相同的默认方法中有一个是抽象方法，实现类编译器也会报错，要求实现该方法，而不是<br>自动使用另一个接口的默认方法。</p>
<ol start="3">
<li>在2中报错是unrelated defaults,如果I2 extends I1,则以I2中的默认方法为准，这样就不存在<br>冲突了，class A implements I1, I2 与 class A implements I2是等价的。此时再调用<br><code>I1.super.XXX()</code>时编译器报错：<code>redundant interface I1 is extended by I2</code></li>
</ol>
<p>注：由于类优先的原则，自定义接口并实现equals,toString等默认方法无效果，应在类中重写这些方法。</p>
<h3 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h3><ol>
<li>java.swing.Timer定时回调实现了ActionListener接口的类对象</li>
<li>在无法改变源码或已有compareTo方法的情况下，可以自定义一个实现了Comparator<t>接口的类，<br>T为需要比较的对象类型，实际使用时还需要实例化该比较类(使用lambda表达式更方便)。</t></li>
<li><p>对象克隆需要实现Cloneable接口,这是一个标记接口，无任何实际作用(唯一作用是可以使用<br>instanceof判断类是否实现了它),对象克隆需要以下几步：</p>
<ol>
<li>实现cloneable接口</li>
<li>重新定义clone方法，修改访问权限为public，返回值为当前类型对象以供外界使用。</li>
<li>拷贝被克隆对象中是否有可变域，即是需要浅克隆(调用(XXX)super.clone()即可)还是深度克隆<br>(考虑给可变子域也实现clone方法)。</li>
</ol>
<p>Object中clone方法为protected的原因:<br>因为Object是所有类的父类，不能保证Object类的<br>子类中所有域都是不可变或是可以克隆的，所以Object中clone方法不是public,而是protected,<br>希望子类能根据自己的情况重写clone方法。</p>
<p>注：</p>
<ol>
<li>所有数组默认可以使用clone方法进行拷贝，经测试对象数组直接调用clone方法为复用对象<br>引用，并没有克隆对象。</li>
<li>原想可以使用上文中的反射Array.getComponentType(),Array.newInstance(),System.arrayCopy<br>来实现克隆，后来查看了Arrays.copyOf()方法的源码，正是这样的实现思路，测试后发现它<br>仍然是复用引用，即浅拷贝。问题出在System.arrayCopy上，这是一个native方法，它拷贝的结果<br>即为直接复用了对象引用,它的内部实现应该是<code>copy[i] = original[i]</code>。</li>
<li>同理，ArrayList的clone方法中使用了Arrays.copyOf()方法，同样是浅拷贝。</li>
<li>由以上可知，想实现对象数组或集合的深拷贝，需要自己遍历数组或集合对每个元素调用clone方法，<br>数组自身clone,Arrays.copyOf,arraylist.clone方法都不能实现这个目的，它们仅适用于基本类型。</li>
</ol>
</li>
</ol>
<h3 id="λ表达式"><a href="#λ表达式" class="headerlink" title="λ表达式"></a>λ表达式</h3><p>为什么需要λ表达式？<br>在上文的定时器Timer调用ActionEvent接口实现类和排序需要的compare方法中，定义的代码块都是<br>在以后将会被调用的方法，这里都通过实例化一个对象来调用这个方法，比较麻烦，λ表达式<br>以更为简洁的方式来解决这个问题。</p>
<p>λ表达式原义为带参数的表达式,如(String x, String y) -&gt; x.length() - y.length().<br>如果没有参数，括号也不能省略，如() -&gt; System.out.println(“hello world”).<br>如果参数类型可以推导得出，可以省略参数类型，如<br><code>Comparator&lt;String&gt; comp = (x,y) -&gt; x.length() - y.length();
如果方法只有一个参数，且类型可推导，则可省略小括号，如</code>ActionListener listener = event -&gt; System.out.println(“now is “ + new Date());`<br>λ表达式不需要指定返回值类型，它会根据上下文推导得出。</p>
<p>函数式接口<br>主要是java.lang.FunctionalInterface注解，它本身也是一个记号接口，无任何内容，由其注释可知：<br>一个接口如果只有一个抽象方法(除了java.lang.Object类中的public方法),那么它就是一个函数接口，<br>不管该接口有没有添加FunctionalInterface注解。Comparator接口就只有一个compare方法和equals<br>方法(与Object相同),它就是一个函数接口。因为所有类都继承自Object类，Object public方法全都<br>默认有实现，所以它不计入抽象方法中。</p>
<p>函数式接口的作用也体现在FunctionalInterface注解的注释中：<br><code>Note that instances of functional interfaces can be created with lambda expression,
method references, or constructor references</code>,说明λ表达式，方法引用，构造器引用的使用<br>对象就是这个函数式接口。</p>
<p>λ表达式的作用就是转化为函数接口，其他语言的函数特性都不支持。<br>java.util.Function包中定义了大量的函数式接口，常用的如Consumer,Predicate,Supplier等。<br>即如果想使用λ表达式，除了已有的之外，可以自定义一个函数式接口来接收λ表达式，加上<br>FunctionalInterface注解。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface OI&#123;        // public无论class, enum, interface，@interface都要求和文件名一致</span><br><span class="line">  int oper(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  print((x,y) -&gt; x + y, 10, 2);  // 调用者通过λ表达式来确定对操作数的操作逻辑</span><br><span class="line">  print((x,y) -&gt; x - y, 10, 2);  // 实现了操作逻辑的动态变化</span><br><span class="line">  print((x,y) -&gt; x * y, 10, 2); </span><br><span class="line">  print((x,y) -&gt; x / y, 10, 2); </span><br><span class="line"> &#125;  </span><br><span class="line"> private static void print(OI o, int x, int y) &#123;   // 操作逻辑，操作数</span><br><span class="line">   //这里进行简单的打印，实际上可以在操作之前和之后进行一些自定义的操作。</span><br><span class="line">   System.out.println(o.oper(x,y));  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即分三步来使用λ表达式：</p>
<ol>
<li>自定义函数式接口(jdk自带的可省略)</li>
<li>定义接收1中接口为参数的方法</li>
<li>调用2中方法使用λ表达式定义想要实现的操作</li>
</ol>
<p>如下调用java.util.functino.predicate函数接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">   print(x -&gt; (Integer)x == 0, 0);  // int类型为Object，需要转为Integer进行比较</span><br><span class="line">   print(x -&gt; (Integer)x - 1 == 0, 2);  // int类型为Object，需要转为Integer进行比较</span><br><span class="line"></span><br><span class="line">   // 调用Arraylist的removeIf方法</span><br><span class="line">   ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">   list.add(2);</span><br><span class="line">   list.add(null);</span><br><span class="line">   list.add(3);</span><br><span class="line">   System.out.println(list.size());  //3</span><br><span class="line">   list.removeIf(e -&gt; e == null);  //这里e的类型为Integer</span><br><span class="line">   System.out.println(list.size());  //2</span><br><span class="line"> &#125;  </span><br><span class="line"> private static void print(Predicate filter, int x) &#123;   // 操作逻辑，操作数</span><br><span class="line">    // 非空判断</span><br><span class="line">    if(filter == null) throw new NullPointerException(&quot;no predicate defined.&quot;);</span><br><span class="line">    if (filter.test(x)) &#123;  //直接调用即可，关注参数和返回值，具体操作逻辑交给调用者</span><br><span class="line">      System.out.println(true);  </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      System.out.println(false);  </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注： 如何在jdk8以前的版本中实现函数式编程？这时无法用λ表达式来传递计算函数，还是使用具体<br>对象来实现，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface Inter&#123;     // 函数式接口不可少，定义操作数和返回值</span><br><span class="line">    int oper(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 传递具体的对象来调用自定义的操作</span><br><span class="line">        f(new InterClass(), 4,5);    </span><br><span class="line">    &#125;</span><br><span class="line">    private static void f(Inter inter, int x, int y) &#123;  // 接收函数表达式的方法</span><br><span class="line">        System.out.println(inter.oper(x,y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class InterClass implements Inter&#123;   // 定义函数接口实现类以符合参数，返回值的约束</span><br><span class="line">    @Override</span><br><span class="line">    public int oper(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在不使用λ表达式时，需要多定义一个接口实现类和初始化一个实现类对象，此方法适用于<br>jdk8以前需要函数式编程的功能。</p>
<p>再注： 使用下方的匿名内部类更为简便，函数接口与接受函数接口的方法不变，只不过需要将λ表达式<br>替换为匿名内部类即可，不过需要在其中重写方法，代码没有λ表达式整洁，但它是jdk8前的最佳替代<br>方案了。</p>
<p>方法引用<br>如果λ表达式定义的处理逻辑已经有某个方法定义了，可以使用该方法来替代λ表达式，即方法引用。<br>方法引用即为简化的λ表达式。</p>
<p>它分3种情况：</p>
<ol>
<li>object.instanceMethod   如System.out::println  out是静态对象，println是实例方法</li>
<li>Class.staticMethod      如Math::max</li>
<li>Class.instanceMethod    如String::compareToIgnoreCase,这种情况方法调用者是第一个参数</li>
</ol>
<p>注：方法引用相当于λ表达式的简写，最终也是要转化为函数式接口的实例，所以如Math::max出现<br>方法重载时，具体调用哪一个取决于调用方法引用的函数接口使用了什么类型的参数。</p>
<p>另：由方法引用的作用来看，自定义方法引用适用于某个λ表达式经常被使用到，可以像提取常量一样，<br>将该λ表达式定义为一个具体的方法，然后在接收函数式接口处调用该方法即可。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface OI&lt;T&gt;&#123;        // 使用泛型处理不同类型参数</span><br><span class="line">  T oper(T x, T y);</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   printInteger(Math::max, 3, 5);     // 5</span><br><span class="line">   printDouble(Math::max, 33.2l, 5.3);  // 33.21</span><br><span class="line">   printInteger(Test::ss, 3, 10);      // 19</span><br><span class="line"> &#125;  </span><br><span class="line"> // 这里函数式接口需要指明泛型类型，否则默认Object,编译报错找不到Math.max(Object,Object)</span><br><span class="line"> private static void printInteger(OI&lt;Integer&gt; oi, int x, int y) &#123;   // 操作逻辑，操作数</span><br><span class="line">   System.out.println(oi.oper(x,y));  </span><br><span class="line"> &#125;</span><br><span class="line"> private static void printDouble(OI&lt;Double&gt; oi, double x, double y) &#123;   // 操作逻辑，操作数</span><br><span class="line">   System.out.println(oi.oper(x,y));  </span><br><span class="line"> &#125;</span><br><span class="line"> private static int ss(int x, int y) &#123;</span><br><span class="line">   return (x * x) + y;   //这是一个简单的运算，只有复杂的操作提取才有意义  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在方法引用的第一种情况对象引用中，可以使用this和super关键字。</p>
<p>构造器引用<br>构造器引用即方法为new的方法引用，快捷调用某个类的构造器。如String::new,本质上说，它还是<br>方法引用，即λ表达式。<br>新建一个对象的λ表达式，这决定了构造器引用的用途不是非常广，只有需要批量初始化的时候(如<br>stream流中)可以简化写法。</p>
<p>数组也可以使用构造器引用，如int[]::new，这个表达式需要的唯一参数为数组的长度。利用这一点<br>可以让工具类绕过java的限制创建泛型数组，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        list.add(3);</span><br><span class="line">        list.add(4);</span><br><span class="line"></span><br><span class="line">        // 常见方法，直接创建数组即可，这个例子里也是最快的</span><br><span class="line">        // Integer[] integers = new Integer[list.size()];</span><br><span class="line"></span><br><span class="line">        // 使用数组构造器引用。Function和BiFunction函数接口变量可以接收λ表达式，</span><br><span class="line">        // 通过调用其apply方法将参数应用到表达式中得到计算结果，这里返回值即为需要的数组</span><br><span class="line">        // Function&lt;Integer, Integer[]&gt; function = Integer[]::new;</span><br><span class="line">        // Integer[] integers = function.apply(list.size());</span><br><span class="line"></span><br><span class="line">        // 调用支持泛型方法，传递数组构造器引用，元素类型，数组大小即可。 </span><br><span class="line">        // 这里是大费周张了，但价值在于调用的泛型方法中</span><br><span class="line">        Integer[] integers = newTArray(Integer[]::new, Integer.class, list.size());</span><br><span class="line"></span><br><span class="line">        list.toArray(integers);</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> // 绕过了java不能创建T[]的限制，可以在其中进行需要的通用数组处理。这里创建后就直接返回了</span><br><span class="line">    private static &lt;T&gt; T[] newTArray(Function&lt;Integer, T[]&gt; f, Class T, Integer size) &#123;</span><br><span class="line">        T[] genericArray = f.apply(size);</span><br><span class="line">        //  do something with genericArray</span><br><span class="line">        return genericArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变量作用域<br>λ表达式就是闭包。<br>λ表达式实际由3部分组成：</p>
<ol>
<li>参数</li>
<li>表达式代码块</li>
<li>自由变量——即λ表达式外的变量，既不是参数也不是代码块中定义的变量。</li>
</ol>
<p>λ表达式引用的自由变量必须是最终变量(final)或实际上的最终变量(effectively final)。<br>即事实上的final变量。<br>最佳实践： 应将使用到的自由变量都用final修饰。</p>
<p>因为自由变量如果可以被改变，当λ表达式并发执行时，会产生问题(具体问题卷2有)。</p>
<p>λ表达式的作用域与它所有的代码块是相同的，即λ表达式的参数和局部变量不能与所在代码块的变量<br>冲突，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 3;</span><br><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x * x; </span><br><span class="line">//error: variable x is already defined in the scope</span><br></pre></td></tr></table></figure></p>
<p>λ表达式中this是指λ表达式所在方法的所属类，与它的返回值没有关系。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class Test2() &#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">   new Test2().go(1000); </span><br><span class="line">   JOptionPane.showMessageDialog(null, &quot;stop&quot;);</span><br><span class="line">   System.exit(0);</span><br><span class="line"> &#125;</span><br><span class="line"> private void go(int delay)&#123;</span><br><span class="line">  ActionListener listener = e -&gt; &#123;</span><br><span class="line">    System.out.println(this);  // will print com.test.Test2@XXXX  </span><br><span class="line">  &#125;  </span><br><span class="line">  new Timer(delay, listener).start();  // java.swing.Timer</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理λ表达式<br>λ表达式重点在于延后执行(deferred execution),可以控制代码的运行时间，条件，线程等。</p>
<p>jdk提供了很多函数式接口的模板，可以根据λ表达式的参数和返回值个数和类型直接使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. Runnable       void run()  适合无参数，无返回值的λ表达式，单纯的方法本身与线程无关</span><br><span class="line">2. Supplier&lt;T&gt;    T get()              无参数, 返回T</span><br><span class="line">3. Consumer&lt;T&gt;    void accept(T)       1个参数，无返回</span><br><span class="line">4. BiConsumer&lt;T,U&gt;  void accept(T,U)  2个参数，无返回</span><br><span class="line">5. Function&lt;T,R&gt;      R  apply(T)     1个参数，返回R</span><br><span class="line">6. BiFunction&lt;T,U,R&gt;  R apply(T,U)    2个参数，返回R</span><br><span class="line">下面是上面接口的特例</span><br><span class="line">7. UnaryOperator&lt;T&gt;   T apply(T)   Function&lt;T,T&gt;的子类，参数和返回值是相同类型</span><br><span class="line">8. BinaryOperator&lt;T&gt;  T apply(T,T) BiFunction&lt;T,T,T&gt;的子类，参数和返回值是相同类型</span><br><span class="line">9. Predicate&lt;T&gt;      boolean test(T)   1个参数,返回boolean值</span><br><span class="line">10. BiPredicate&lt;T,U&gt;  boolean test(T,U)  2个参数，返回boolean值</span><br></pre></td></tr></table></figure></p>
<p>对于基本类型int,long,double,jdk为了省去自动装箱的开销提供了一些专门的函数式接口，如<br>IntConsumer等。<br>这些接口有一些默认方法，提供了如级联调用，返回相同方法等功能。<br>如consumer.andThen(Consumer after)返回的是一个lambda表达式<br><code>(T t) -&gt; {accept(t), after.accept(t);}</code>,<br>该表达式只有一个参数，调用了2个accept方法，无返回值，其本身也是一个Consumer类型，<br>需要执行该表达式时，也是调用其accept方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   Consumer&lt;Integer&gt; first = System.out::println;  </span><br><span class="line">   Consumer&lt;Integer&gt; second = System.out::println;</span><br><span class="line">   first.andThen(second).accept(666);   // output 666 twice   </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再谈Comparator<br>Comparator是一个常用的比较器和函数式接口。抽象方法为<code>int compare(T o1, T o2);</code>,可以通过<br>多种方式得到自己需要的Comparator比较器，如Person类对象按域name长度排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class TestPerson &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Person[] ps = new Person[]&#123;new Person(&quot;wtt&quot;), new Person(&quot;wttsan&quot;), new Person(&quot;wt&quot;)&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line"></span><br><span class="line">        // 直接自己想要的比较方式，idea会给出提示可以使用comparing</span><br><span class="line">        // Comparator&lt;Person&gt; comparator =</span><br><span class="line">        //         (Person p1, Person p2) -&gt; p1.getName().length() - p2.getName().length();</span><br><span class="line"></span><br><span class="line">        // comparing有多个变体，主要参数为keyextractor,即需要比较的键的function,这里后面</span><br><span class="line">        // 一个参数为键本身的比较器，即字符串长度</span><br><span class="line">        // Comparator&lt;Person&gt; comparator = Comparator.comparing(Person::getName,</span><br><span class="line">        //         (x,y) -&gt; x.length() - y.length());</span><br><span class="line"></span><br><span class="line">        // 最终结果是比较int值大小，可以提取到外面，使用comparingInt,参数为ToIntFunction,</span><br><span class="line">        // 需要传递返回值为int,只有一个参数的function.此方法最为简洁。</span><br><span class="line">        Comparator&lt;Person&gt; comparator = Comparator.comparingInt(p -&gt; p.getName().length());</span><br><span class="line">        Arrays.sort(ps, comparator);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;&#125;</span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同consumer.andThen(Consumer con)一样，Comparator有thenComparing方法实现级联调用，目的是<br>第一个比较器比较结果为相等时可以调用第二个比较器继续比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class TestPerson &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person[] ps = new Person[]&#123;</span><br><span class="line">          new Person(&quot;wtt&quot;, 5), new Person(&quot;wttsan&quot;,1), new Person(&quot;cll&quot;,3)&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line"></span><br><span class="line">        // 第一个p的参数类型Person不可少，应是λ表达式无法推断出来，anyway,最好是</span><br><span class="line">        // 指明参数类型</span><br><span class="line">        Comparator&lt;Person&gt; comparator = Comparator.comparingInt(</span><br><span class="line">         (Person p) -&gt; p.getName().length()).thenComparingInt(p -&gt; p.getId());</span><br><span class="line"></span><br><span class="line">        Arrays.sort(ps, comparator);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int id) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, id=&quot; + id +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果比较的键函数可以返回null,可以使用Comparator.nullsFirst()或nullsLast来对null值进行排序。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>使用内部类的三个原因：</p>
<ol>
<li>可以访问类定义所在作用域中的数据，包括私有数据。</li>
<li>内部类可以对同包的其他类隐藏</li>
<li>使用匿名内部类可以快捷定义回调函数。<br>注： C++有嵌套类，它只是类之间的关系，对象之间没有关系。命名控制和访问控制同java相似，但<br>java内部类对象有一个指向外部类对象的隐式指针，可以访问其全部状态。静态内部类没有该指针。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class TimerTest&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        TimerClock timerClock = new TimerClock(1000, false);</span><br><span class="line">        timerClock.start();</span><br><span class="line"></span><br><span class="line">        // 当内部类为public时，可以在外界使用outerObject.new InnerClass(xxx)创建内部类对象</span><br><span class="line">        // 使用OuterClass.InnerClass来引用内部类对象</span><br><span class="line">        // 内部类为private时，无法在外界创建对象</span><br><span class="line">        TimerClock.TimePrinter timePrinter = timerClock.new TimePrinter();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TimerClock &#123;</span><br><span class="line">    private int interval;</span><br><span class="line">    private boolean beep;</span><br><span class="line"></span><br><span class="line">    public TimerClock(int interval, boolean beep) &#123;</span><br><span class="line">        this.interval = interval;</span><br><span class="line">        this.beep = beep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">      // 创建内部类对象的规范写法，因为在作用域内，也可以直接new</span><br><span class="line">        ActionListener listener = this.new TimePrinter();</span><br><span class="line">        Timer t = new Timer(interval, listener);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    // 只有内部类可以作为private类，其他类只能为default或public</span><br><span class="line">    public class TimePrinter implements ActionListener &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event) &#123;</span><br><span class="line">            System.out.println(&quot;At the tone, the time is &quot; + new Date());</span><br><span class="line">            // 引用外部类域的规范写法，因为在作用域内，也可以直接写beep</span><br><span class="line">            // 同时，这样写确定了调用的是TimerClock类中的域beep，避免了被同名属性覆盖</span><br><span class="line">            if (TimerClock.this.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">            System.out.println(interval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的程序使用命令<code>javac .\TimerTest.java</code>进行编译后发现生成了3个class文件，<br><code>TimerTest.class, TimerClock.class, TimerClock$TimerPrinter.class</code>文件。<br>最后一个即为定义的内部类，使用命令<code>javap -p &#39;.\TimerClock$TimePrinter.class&#39;</code>进行反编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class com.test.TimerClock$TimePrinter implements java.awt.event.ActionListener &#123;</span><br><span class="line"></span><br><span class="line">  // 内部类自动添加了对外部类的引用域</span><br><span class="line">  final com.test.TimerClock this$0;       </span><br><span class="line">  // 内部类构造器中自动添加了对外部类的引用参数</span><br><span class="line">  public com.test.TimerClock$TimePrinter(com.test.TimerClock);</span><br><span class="line">  public void actionPerformed(java.awt.event.ActionEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由此可知，内部类只是编译器层面的语法糖，虚拟机对此一无所知。<br>使用命令<code>javap -p &#39;.\TimerClock.class&#39;</code>查看外部类的反编译代码为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class com.test.TimerClock &#123;</span><br><span class="line">  private int interval;</span><br><span class="line">  private boolean beep;</span><br><span class="line">  public com.test.TimerClock(int, boolean);</span><br><span class="line">  public void start();</span><br><span class="line">  // 自动生成域的访问方法供内部类调用</span><br><span class="line">  static boolean access$000(com.test.TimerClock);</span><br><span class="line">  static int access$100(com.test.TimerClock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到针对内部类访问的2个域生成了对应的2个access方法(如果只访问了一个域只会生成对应的一个<br>access方法),内部类实际上就是通过这个自动生成的方法来访问外部类的私有属性，结合内部类反编译<br>代码，即调用了如<code>TimerClock.access$000(this$0)</code>来得到beep值。</p>
<p>注：编译生成的access$XXX方法实际上可以被任何同包的类调用,不仅限于内部类。由于access方法是<br>编译器自动生成的，无法在编译前直接调用，所以需要编写虚拟机指令来完成，而且还需要获得对应的<br>TimeClock对象作为方法参数，操作还是有难度的。</p>
<p>注2: 外部类可以访问内部类的所有成员，包括内部类的私有属性(无需如access方法等附加条件)，<br>这点可以从类包含的关系去理解，也无法解释太多。不过对于下面的局部内部类外部类将无法访问。</p>
<p>局部内部类<br>局部类是在方法中定义的内部类，它不能用public，private修饰，使用default,它的作用域限定在<br>这个方法中，外部类的其他方法不能访问它，内部类本身仍然可以访问外部类属性。<br>局部类实现了更深层次的封装。<br>将上面程序的TimePrint类移到start方法中，此时不能再使用<code>this.new TimePrint()</code>了，外部类对象<br>不能直接访问局部类。同样编译后再使用javap反编译可得，生成的内部类名字变了，中间变为<code>$1</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class com.test.TimerClock$1TimePrinter implements java.awt.event.ActionListener &#123;</span><br><span class="line">  final com.test.TimerClock this$0;       </span><br><span class="line">  com.test.TimerClock$1TimePrinter(com.test.TimerClock);</span><br><span class="line">  public void actionPerformed(java.awt.event.ActionEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同λ表达式一样，局部类也可以访问作用域内的局部变量，但它必须是final类型的，代码变为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TimerTest&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        TimerClock.start(1000, false);</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TimerClock &#123;</span><br><span class="line"></span><br><span class="line">   public static void start(int interval, boolean beep) &#123;</span><br><span class="line"></span><br><span class="line">     class TimePrinter implements ActionListener &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event) &#123;</span><br><span class="line">            System.out.println(&quot;At the tone, the time is &quot; + new Date());</span><br><span class="line">            if (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">            System.out.println(interval);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ActionListener listener = new TimePrinter();</span><br><span class="line">     Timer t = new Timer(interval, listener);</span><br><span class="line">     t.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令<code>javap &#39;.\TimerClock$1TimePrinter.class&#39;</code>可得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class com.test.TimerClock$1TimePrinter implements java.awt.event.ActionListener &#123;</span><br><span class="line">  final boolean val$beep;</span><br><span class="line">  final int val$interval;</span><br><span class="line">  com.test.TimerClock$1TimePrinter();</span><br><span class="line">  public void actionPerformed(java.awt.event.ActionEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与以上引用外部类域的反编译结果可知，没有引用外部类域后，局部类没有了外部类域的引用this$0,<br>构造器参数也去掉了，同时由于actionPerformed方法需要在start方法结束调用后仍然需要得到beep和<br>interval的值以继续执行，所以在内部类中相应的生成了域val$beep和val$interval来保存局部变量的<br>拷贝值。出于并发的考虑，访问的局部变量需要为final变量，最好是显式的声明出来。</p>
<p>可以看到，使用局部类极大的简化了代码，同时使用局部变量替代外部类实例域提高了安全性，无需<br>生成不安全的access方法供内部类调用。</p>
<p>注：如果需要在内部类中改变局部变量的值，可以将该变量封装在一个数组中，这时变量对该数组的<br>引用是final的，但其中的元素值可以被改变，从而避开了final的限制。start方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public static void start(int interval, boolean beep) &#123;</span><br><span class="line"></span><br><span class="line">   int[] count = &#123;1&#125;;</span><br><span class="line">   class TimePrinter implements ActionListener &#123;</span><br><span class="line">      public void actionPerformed(ActionEvent event) &#123;</span><br><span class="line">          // OK to change count[0] value, array reference not changed</span><br><span class="line">          System.out.println(count[0]++);  </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匿名内部类<br>匿名内部类即没有名字的内部类，因为这个类只需要创建一个对象，所以它不需要给类命名，只需要<br>以特定的语法指明父类或实现的接口即可。</p>
<p>因为匿名内部类没有名字，而构造器需要与类名相同，所以匿名内部类没有构造器，它将构造器参数<br>传递给父类构造器，因为接口没有构造器，所以匿名内部类实现接口时，也没有参数，直接为<br><code>new InterfaceType(){...}</code>.</p>
<p>λ表达式可以用匿名内部类替换，如上文中λ表达式的例子可改写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Inter&#123;     // 函数式接口不可少，定义操作数和返回值</span><br><span class="line">    int oper(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      f(new Inter()&#123;</span><br><span class="line">         @Override</span><br><span class="line">         public int oper(int x, int y) &#123;</span><br><span class="line">           return x + y;  </span><br><span class="line">         &#125;</span><br><span class="line">        &#125;, 4,5);    </span><br><span class="line">  &#125;</span><br><span class="line">  private static void f(Inter inter, int x, int y) &#123;  // 接收函数表达式的方法</span><br><span class="line">      System.out.println(inter.oper(x,y));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是继承一个类的匿名内部类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  private int id;</span><br><span class="line">  public Person(int id) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  public void say()&#123;</span><br><span class="line">   System.out.println(&quot;person&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public int getId()&#123;return id;&#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String toString()&#123;</span><br><span class="line">    return &quot;Person&#123;id=&quot; + id + &quot;&#125;&quot;;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    final String x = &quot;hello&quot;;</span><br><span class="line">    Person p = new Person(88) &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void say()&#123;</span><br><span class="line">        // 匿名内部类实际上是Person的子类，无法直接访问Person私有属性id,也getId访问</span><br><span class="line">        System.out.println(x + getId());  // output hello88</span><br><span class="line">        System.out.println(this); // output Person&#123;id=88&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public void test()&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    p.say();</span><br><span class="line">    // p.test();   // 编译报错无法解析，原因在于多态</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由以上程序可以看出，匿名内部类与局部类的作用域相同，可以对所在作用域(即声明的所在方法)内<br>的final or effective final变量有访问权限。<br>关于p.test()多态报错的问题，网上找到一个经测试可以运行的办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Person(88) &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void say()&#123;</span><br><span class="line">    // 匿名内部类实际上是Person的子类，无法直接访问Person私有属性id,也getId访问</span><br><span class="line">    System.out.println(x + getId());  // output hello88</span><br><span class="line">    System.out.println(this); // output Person&#123;id=88&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public void test()&#123;&#125;</span><br><span class="line">&#125;.test();  // 直接在类声明后调用可以调用成功，未进行向上转型</span><br></pre></td></tr></table></figure></p>
<p>无论如何，匿名内部类主要还是用于重写方法。</p>
<p>还是使用javap命令反编译以上程序，匿名内部类会自动生成一个Outerclass$1.class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final class com.test.InnerTest$1 extends com.test.Person&#123; // 证实了子类的关系</span><br><span class="line">  com.test.InnerTest$1(int);   // 构造器参数与Person一致</span><br><span class="line">  public void say();</span><br><span class="line">  public void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注：有时需要传递一个匿名数组列表，可以是使用双括号初始化(double brace initialization):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleTest&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">   showList(new ArrayList&lt;Integer&gt;() &#123;&#123;</span><br><span class="line">    add(6);</span><br><span class="line">    add(5);</span><br><span class="line">    add(111);</span><br><span class="line">   &#125;&#125;);      // 适用于只需要使用一次的list参数</span><br><span class="line"> &#125;</span><br><span class="line"> private static void showList(List&lt;Integer&gt; list) &#123;</span><br><span class="line">   System.out.println(Arrays.toString(list.toArray())); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态内部类<br>如果不需要在内部类中引用外部类对象属性，可以将其设置为静态内部类。</p>
<p>静态态可以有静态域和静态方法，非静态类不可以。<br>因为静态变量和方法属于类的范围，它们会在具体的对象初始化前被加载，而非静态内部类的初始化<br>依托于外部类对象，所以非静态内部类中不能定义静态变量和方法，因为加载它们时需要的内部类<br>还未生成。</p>
<p>对静态内部类进行反编译可以发现其类名与普通内部类组成相同：Outerclass$Innerclass,类中没有<br>对外部类的引用,无构造器参数，为普通类编译结果。</p>
<p>静态类初始化语法<code>Outer.Inner inner = new Outer.Inner(XXX);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTest&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Outer.Inner inner = new Outer.Inner(66); </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">class Outer&#123;</span><br><span class="line">  public static class Inner&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public Inner(int id)&#123;</span><br><span class="line">      this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理是一种设计模式，主要作用为对被代理对象的方法调用进行监控或加工处理等，是AOP和其他开发<br>框架常用的技术。</p>
<p>代理分为静态代理和动态代理，静态代理为显式的定义一个被代理对象的包装类，<br>实现与被代理对象相同的接口，该方法不具有广泛性，每个代理类都写死为某个接口与对象。<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class StaticProxy &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Bird bird = new Bird();</span><br><span class="line">     BirdProxy birdProxy = new BirdProxy(bird);</span><br><span class="line">     birdProxy.fly();</span><br><span class="line">  &#125;</span><br><span class="line">  interface Fly&#123;</span><br><span class="line">     void fly();</span><br><span class="line">  &#125;</span><br><span class="line">  static class Bird implements Fly&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;bird fly&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static class BirdProxy implements Fly&#123;</span><br><span class="line">     private Fly target;</span><br><span class="line">     public BirdProxy(Fly target) &#123;</span><br><span class="line">       this.target = target;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void fly() &#123;</span><br><span class="line">       System.out.println(&quot;do something before&quot;);</span><br><span class="line">       target.fly();</span><br><span class="line">       System.out.println(&quot;do something after&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>动态代理使用jdk的Proxy类和InvocationHandler接口，自定义代理类实现InvocationHandler接口，<br>同样包装被代理对象，重写invoke方法调用被代理对象的具体方法。调用时使用Proxy.newProxyInstance<br>(classloader, class[] interfaces, invocationHandler)方法在运行时生成代理对象。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Bird bird = new Bird();</span><br><span class="line">     Object proxy = Proxy.newProxyInstance(bird.getClass().getClassLoader(),</span><br><span class="line">                     bird.getClass().getInterfaces(),</span><br><span class="line">                     new ProxyFactory(bird));</span><br><span class="line">     Fly birdProxy = (Fly)proxy;  // proxy instance implements the interfaces assigned</span><br><span class="line">     birdProxy.fly();</span><br><span class="line">     System.out.println(birdProxy);  // toString方法同样调用invoke方法</span><br><span class="line">  &#125;</span><br><span class="line">  interface Fly&#123;</span><br><span class="line">     void fly();</span><br><span class="line">  &#125;</span><br><span class="line">  static class Bird implements Fly&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void fly() &#123;</span><br><span class="line">       System.out.println(&quot;bird fly&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static class ProxyFactory implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">     private Object target;</span><br><span class="line">     public ProxyFactory(Object target) &#123;</span><br><span class="line">       this.target = target;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;do sth before&quot;);</span><br><span class="line">       Object result = method.invoke(target, args);</span><br><span class="line">       System.out.println(&quot;do sth after&quot;);</span><br><span class="line">       // System.out.println(proxy);       // error and exception</span><br><span class="line">       return result;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(参照java.reflect.Proxy类注释和javaCore书)</p>
<ol>
<li><p>newProxyInstance方法会在运行时生成一个代理类，类名以<code>$Proxy</code>开头，它继承了<br><code>java.reflect.Proxy</code>类，并以相同顺序实现方法参数中传递的的接口列表。</p>
</li>
<li><p>如果接口组都是public访问权限，代理类就是public final的，并且该代理类不指定包名;<br>如果接口组中有一个非public，则代理类就是非public的，并且代理类处于和其他非公有包的相同包中，<br>其中所有的非public接口需要在同一个包中。</p>
</li>
<li><p>对于相同类加载器和相同接口组生成的proxy不同实例是属于同一个proxy类的不同对象。</p>
</li>
<li><p>每个代理对象都只有一个实例域——invocationHandler,代理对象本身可以向上转型为某个实现的接口<br>引用，而通过此种方法调用代理对象的接口方法时，代理对象会调用其invocationHandler的invoke<br>方法(由于该invocationHandler会在初始化时通过参数传入，即调用了自定义的invoke方法)，invoke<br>方法中可以自定义操作，如通过反射Method调用被代理对象的方法等，invoke方法的返回值即为该次<br>代理对象上方法调用的返回值。</p>
</li>
<li><p>生成的代理类会自动重写Object的hashCode，equals,toString方法，这些方法也会被转向<br>invocationHandler的invoke方法进行处理，在实际使用中应当注意这一点，防止不必要的invoke<br>方法调用。其他的Object方法没有被重写。</p>
</li>
<li><p>如果不同代理接口中出现了重复方法，不管代理对象引用是什么接口类型，代理对象调用的<br>都是第一个出现的拥有此方法的接口(直接声明或继承而来的)，因为生成的代理类对应方法实现中<br>无法确定调用哪一个接口–都是接口数组元素。</p>
</li>
</ol>
<p>注：调用接口方法时转向调用invoke方法的实现原理是在生成的代理类代码中写明的，查看Proxy类<br>源码，其中有一个ProxyClassFactory静态内部类，其中的apply方法调用了<br>ProxyGenerator.generateProxyClass方法来生成Proxy类。我们可以自己调用该方法来查看生成的<br>Proxy类代码，通过类代码可以清楚的证明上述的1、4、5点。该类一旦被生成就是一个普通类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GenerateProxyTest &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    byte[] $Proxy6s = ProxyGenerator.generateProxyClass(&quot;$Proxy6&quot;, new Class[]&#123;Inte.class&#125;);</span><br><span class="line"></span><br><span class="line">    // jdk 1.7后的try-with-resource语法糖，可以对实现了autoCloseable接口的资源自动关闭</span><br><span class="line">    // 编译后为原来的try-catch-finally语句(如果用户代码和关闭代码都有异常，关闭异常被抑制，</span><br><span class="line">    // 可以通过getSuppressed方法获得该被抑制的异常)</span><br><span class="line"></span><br><span class="line">    try(FileOutputStream fos = new FileOutputStream(&quot;D:\\$Proxy6.class&quot;)) &#123;</span><br><span class="line">            fos.write($Proxy6s);</span><br><span class="line">            fos.flush();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Inte&#123;</span><br><span class="line">      void say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>取出该文件，使用jd-gui反编译(直接打开无效，进去后使用open file功能),内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">import com.example.demo.Inte;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy6     // 继承Proxy,实现Inte接口</span><br><span class="line">  extends Proxy</span><br><span class="line">  implements Inte</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m1;</span><br><span class="line">  private static Method m2;</span><br><span class="line">  private static Method m3;</span><br><span class="line">  private static Method m0;</span><br><span class="line">  </span><br><span class="line">  public $Proxy6(InvocationHandler paramInvocationHandler)</span><br><span class="line">  &#123;</span><br><span class="line">      super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Error|RuntimeException localError)</span><br><span class="line">      &#123;</span><br><span class="line">          throw localError;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable localThrowable)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final String toString()</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          return (String)this.h.invoke(this, m2, null);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Error|RuntimeException localError)</span><br><span class="line">      &#123;</span><br><span class="line">          throw localError;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable localThrowable)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 代理类中只是简单的调用了invoke方法 </span><br><span class="line">  public final void say()</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          this.h.invoke(this, m3, null);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Error|RuntimeException localError)</span><br><span class="line">      &#123;</span><br><span class="line">          throw localError;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable localThrowable)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final int hashCode()</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          return ((Integer)this.h.invoke(this, m0, null)).intValue();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Error|RuntimeException localError)</span><br><span class="line">      &#123;</span><br><span class="line">          throw localError;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable localThrowable)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">          m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">          m3 = Class.forName(&quot;com.example.demo.Inte&quot;).getMethod(&quot;say&quot;, new Class[0]);</span><br><span class="line">          m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为生成的代理类继承了java.reflect.Proxy类(和枚举继承了Enum一样),而java是单继承机制，<br>所以jdk动态代理只能代理接口，无法代理一个类，想要代理一个类，可以使用cglib包，它是通过<br>生成子类的方式实现的，据说spring的面向切面就是代理类时使用cglib,代理接口时使用proxy(这<br>一点以后研究AOP时再细看)</p>
<p>注：可以使用Proxy.isProxyClass来判断一个class对象是否是代理类。</p>
<p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190512_1.jpg" class="full-image"></p>

      
    </div>

    
      

  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/post/65ea4e77/" rel="bookmark">Java3_Core10Note</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/post/fe4f0218/" rel="bookmark">Java2_Core10Note</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/post/896258ed/" rel="bookmark">ModernJavaInActionNote</a></div>
      
    </li>
  
  </ul>


    

    
    
    

    

    
      
    
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById(&quot;QR&quot;); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/wechat.jpg" alt="吴涛涛 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/alipay.jpg" alt="吴涛涛 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        



  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>吴涛涛</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="http://www.taoblog.cn/post/2a1ddb5b/" title="Java1_Core10Note">http://www.taoblog.cn/post/2a1ddb5b/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          
            <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          
            <a href="/tags/Char-with-UTF-16/" rel="tag"><i class="fa fa-tag"></i> Char with UTF-16</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
            <div id="wpac-rating"></div>
          </div>
        

        

        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/1604d5df/" rel="next" title="LinuxNote">
                <i class="fa fa-chevron-left"></i> LinuxNote
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/fe4f0218/" rel="prev" title="Java2_Core10Note">
                Java2_Core10Note <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <a href="/">
              <img class="site-author-image" itemprop="image" src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/maya.jpg" alt="吴涛涛">
                </a>
            
              <p class="site-author-name" itemprop="name">吴涛涛</p>
              <p class="site-description motion-element" itemprop="description">wutaotao personal blog</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/wutaotao2015" title="GitHub &rarr; https://github.com/wutaotao2015" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://hexo.io/zh-cn/docs/" title="https://hexo.io/zh-cn/docs/" rel="noopener" target="_blank">Hexo</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://theme-next.iissnan.com/getting-started.html" title="http://theme-next.iissnan.com/getting-started.html" rel="noopener" target="_blank">Next</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.lingblog.net/" title="http://www.lingblog.net/" rel="noopener" target="_blank">cllBlog</a>
                  </li>
                
              </ul>
            
            </div>
          

          
          
          <div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("01/18/2019 23:48:05");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="blog has been running<br/>"
+daysold+" d "+hrsold+" h "+minsold+" m "+seconds+" s";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装java"><span class="nav-number">1.</span> <span class="nav-text">安装java</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本程序设计结构"><span class="nav-number">2.</span> <span class="nav-text">基本程序设计结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">2.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">2.2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">2.3.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">2.4.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入输出"><span class="nav-number">2.5.</span> <span class="nav-text">输入输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制流程"><span class="nav-number">2.6.</span> <span class="nav-text">控制流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大数值"><span class="nav-number">2.7.</span> <span class="nav-text">大数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">2.8.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-each循环"><span class="nav-number">2.9.</span> <span class="nav-text">for each循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象与类"><span class="nav-number">3.</span> <span class="nav-text">对象与类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用jdk包中预定义类"><span class="nav-number">3.1.</span> <span class="nav-text">使用jdk包中预定义类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义类"><span class="nav-number">3.2.</span> <span class="nav-text">自定义类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态域与静态方法"><span class="nav-number">3.3.</span> <span class="nav-text">静态域与静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法参数"><span class="nav-number">3.4.</span> <span class="nav-text">方法参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象构造"><span class="nav-number">3.5.</span> <span class="nav-text">对象构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包"><span class="nav-number">3.6.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类路径"><span class="nav-number">3.7.</span> <span class="nav-text">类路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档注释"><span class="nav-number">3.8.</span> <span class="nav-text">文档注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类设计技巧"><span class="nav-number">3.9.</span> <span class="nav-text">类设计技巧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">4.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口，lambda表达式，内部类"><span class="nav-number">5.</span> <span class="nav-text">接口，lambda表达式，内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">5.1.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口示例"><span class="nav-number">5.2.</span> <span class="nav-text">接口示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#λ表达式"><span class="nav-number">5.3.</span> <span class="nav-text">λ表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">5.4.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理"><span class="nav-number">5.5.</span> <span class="nav-text">代理</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴涛涛</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">510k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">7:44</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.0.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>







  




















  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  
  

  

<script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script>



  

<script src="//cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '48ERsGJLrCK2gEVvR9razFEe-MdYXbMMI',
    appKey: 'mETL0o4bfizck0MCVvPOqv88',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>




  


  



  
  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">

  
  
    
  
  <script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.js"></script>
  

  <script src="/js/src/algolia-search.js?v=7.0.0"></script>



  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log(`Failed to save Visitor num, with error message: ${responseJSON.error}`);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'NCCFA0S02dv1PFmmODBJeCQO-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'NCCFA0S02dv1PFmmODBJeCQO-gzGzoHsz',
                'X-LC-Key': 'bAOsL8XKUXH3zST74CQcodSm',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  
  <script>
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id: 16361,
      el: 'wpac-rating',
      color: 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  </script>


  
  
  
    
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/pangu/3.3.0/pangu.min.js"></script>
  <script>pangu.spacingPage();</script>


  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


<script>!function(o){var i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function c(t,e){var n=new Image,o=t.getAttribute("data-original");n.onload=function(){t.src=o,e&&e()},n.src=o}function n(){for(var t=0;t<i.length;t++)e=i[t],void 0,0<=(n=e.getBoundingClientRect()).top&&0<=n.left&&n.top<=(o.innerHeight||document.documentElement.clientHeight)&&c(i[t],function(){i.splice(t,t)});var e,n;console.log("trigger")}n(),o.addEventListener("scroll",function(){var t,e;t=n,e=o,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
