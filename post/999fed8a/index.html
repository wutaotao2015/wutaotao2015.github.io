<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
      
    
    
      
    
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">







  <meta name="google-site-verification" content="GNI8KNzHxdOObg1xzQwHXPStlrnPJHC4Cw1iZMCCe9U">














  
  
  
  

  

  

  

  

  

  






  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.0.0',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: false,
    fastclick: false,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'LEJ8JV9ZSY',
      apiKey: '9572d9f139c3c642cdbaaa2caf3123c9',
      indexName: 'searchIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="note on learning Vue">
<meta name="keywords" content="Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="VueNote">
<meta property="og:url" content="http://www.taoblog.cn/post/999fed8a/index.html">
<meta property="og:site_name" content="TaoBlog">
<meta property="og:description" content="note on learning Vue">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==">
<meta property="og:updated_time" content="2021-03-18T10:21:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VueNote">
<meta name="twitter:description" content="note on learning Vue">
<meta name="twitter:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==">



  <link rel="alternate" href="/atom.xml" title="TaoBlog" type="application/atom+xml">




  <link rel="canonical" href="http://www.taoblog.cn/post/999fed8a/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>VueNote | TaoBlog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">TaoBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Sharing makes us better</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">50</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">17</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">23</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-message">

    
    
    
      
    

    
      
    

    <a href="/message/" rel="section"><i class="menu-item-icon fa fa-fw fa-comment"></i> <br>留言板</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.taoblog.cn/post/999fed8a/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="吴涛涛">
      <meta itemprop="description" content="wutaotao personal blog">
      <meta itemprop="image" content="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/maya.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TaoBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">VueNote

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-19 17:23:01 17:23:01" itemprop="dateCreated datePublished" datetime="2019-11-19T17:23:01+08:00">2019-11-19 17:23:01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-03-18 18:21:42 18:21:42" itemprop="dateModified" datetime="2021-03-18T18:21:42+08:00">2021-03-18 18:21:42</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/post/999fed8a/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/post/999fed8a/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/post/999fed8a/" class="leancloud_visitors" data-flag-title="VueNote">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">54k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">49 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>note on learning Vue<br><a id="more"></a></p>
<h2 id="官网教程"><a href="#官网教程" class="headerlink" title="官网教程"></a>官网教程</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>直接下载vue.js并在html中引用即可。这里使用的vue版本为2.6.10.</p>
<h3 id="声明式渲染，条件与循环等"><a href="#声明式渲染，条件与循环等" class="headerlink" title="声明式渲染，条件与循环等"></a>声明式渲染，条件与循环等</h3><p>数据可以绑定到DOM文本:如文本插值<code>{ { message }}</code>,<br>DOM属性: 如直接在html标签中使用指令v-bind:title=”eleTitle”改变鼠标悬停效果,<br>DOM结构: 如使用指令v-if=”seen”控制是否显示标签(控制结构时还可以提供fade in, out等其他动画效果)</p>
<p>v-for=”item in itemList”在li标签中的应用。<br>v-on:click=”afterClick”绑定点击事件为afterClick方法。<br>v-model=”message”为双向数据绑定。</p>
<p>可以通过如下方式自定义组件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;todo&apos;, &#123;</span><br><span class="line">  props: [&apos;prop1&apos;, &apos;prop2&apos;],</span><br><span class="line">  template: &apos;&lt;li&gt;&#123; &#123; prop1.text &#125;&#125;&lt;/li&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var ele = new Vue(&#123;</span><br><span class="line"> el: &apos;#ap5&apos;,</span><br><span class="line"> data: &#123;</span><br><span class="line">   list: [</span><br><span class="line">    &#123;id: 0, text: &apos;one&apos;&#125;,</span><br><span class="line">    &#123;id: 1, text: &apos;two&apos;&#125;,</span><br><span class="line">    &#123;id: 2, text: &apos;three&apos;&#125;</span><br><span class="line">   ]  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>自定义组件，使用时如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&apos;ap5&apos;&gt;</span><br><span class="line">  &lt;todo v-for=&quot;item in list&quot; v-bind:prop1=&quot;item&quot; v-bind:key=&quot;item.id&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，自定义组件todo使用组件属性prop使得组件动态显示外界传递的数据内容。这与上面的<br>v-bind:title=”message”是一样的。</p>
<h3 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h3><p>在vue中，一个组件实际上是一个预定义的Vue实例。每个Vue实例可以接受多个选项。</p>
<ol>
<li>数据选项 data<br>当实例创建时，data选项中已经存在的属性会被加入到vue的响应式系统中，如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var dataSource = &#123;text: 1&#125;;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: dataSource </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这时无论改变vm.text还是改变dataSource.text的值，另一个的值都会同步发生改变，即实现了数据<br>和视图的双向响应式变化。如果在vm实例创建后，对dataSource添加新属性是无法实现响应式变化的。</p>
<p>注: Object.freeze(dataSource)会阻止修改对象属性值。</p>
<p>实例属性和方法都有前缀$, 如vm.$el, vm.$data等。</p>
<p>实例提供了多个生命周期钩子，如created, mounted, updated, destroyed等，可以在选项中自定义<br>回调方法执行自定义操作。钩子的this关键字指向vue实例，避免使用箭头函数。</p>
<p>教程中给出了vue实例的整个生命周期流程，可以看到以下几点：</p>
<ol>
<li>如果没有指定el选项，可以使用vm.$mount(el)方法指定元素。</li>
<li>选项中如果有指定template模板，使用该模板进行渲染，否则就使用el的html标签进行渲染。这一点<br>也区分开了自定义组件和普通的html标签。</li>
<li>vue使用vm.$el替换原生的el标签实现虚拟DOM, 在此基础上实现响应式渲染。 </li>
</ol>
<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><ol>
<li>文本<br>双大括号为mustache语法，<code>{ { message }}</code>, 数据选项属性message发生变化，该文本值也会变化。<br>可以使用<code>&lt;p v-once&gt;{ { message }}&lt;/p&gt;</code>来实现一次性渲染.</li>
</ol>
<p>注: 类似document.getElementById().innerText = XXX;</p>
<ol start="2">
<li>html标签<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&apos;ap6&apos;&gt;</span><br><span class="line">  &lt;p&gt;&lt;span v-html=&quot;sp&quot;/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var ap6 = new Vue(&#123;</span><br><span class="line">  el: &apos;#ap6&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    sp: &apos;&lt;a style=&apos;color: red&apos;&gt;I am red&lt;/a&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对用户输入的内容使用html插值容易导致XSS攻击，应只对可信内容使用。</p>
<p>注: 类似<code>document.getElementById().innerHTML = &quot;&lt;x&gt;...&lt;/x&gt;&quot;;</code></p>
<ol start="3">
<li><p>属性<br>同上面所说，标签属性的改变使用v-bind指令，如v-bind:disabled=”disableFlag”等, 其中disableFlag<br>必须为boolean值。</p>
</li>
<li><p>模板表达式<br>如<code>{ { num + 1}}</code>, <code>{ { ok ? &#39;yes&#39; : &#39;no&#39; }}</code>都会被当作js表达式解析，其中num作为v-model双向绑定时<br>是字符串类型，<code>{ {num+1}}</code>得到的是字符串的拼接。<br>模板表达式的解析是在沙盒中，只能访问如Math,Date等白名单对象，无法访问用户自定义全局变量，<br>访问时会报错该属性未定义。</p>
</li>
</ol>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>指令一般是作用于单个表达式，如v-on:click=’reverse’, v-if=’seen’等。</p>
<ol>
<li><p>参数<br>即指令名称冒号后的值，如v-bind:href=’url’, v-on:click=’reverse’中href, click都是参数，<br>等号后是参数值。</p>
</li>
<li><p>动态参数<br>如v-on:[event]=’dosth’, 其中event可以为一个js表达式，如实例中有一个数据属性为event,值为<br>focus, 那么它就等价为v-on:focus=’dosth’.通过这种形式，该标签就可以在不同时间以聚焦或点击<br>的不同动作调用相同的方法。(这种需求还是比较少见, 其他指令的参数动态性可能有点用)<br>动态表达式中不能有空格和引号，大写字母会被强制转换为小写。</p>
</li>
<li><p>修饰符<br>如v-on:submit.prevent=’sub’中参数submit后的.prevent指出该指令以特殊方式绑定，即调用<br>event.preventDefault()语句。</p>
</li>
</ol>
<h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><p>v-bind:href=’url’可以缩写为:href=’url’,<br>v-on:click=’dosth’可以缩写为@click=’dosth’.</p>
<h3 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h3><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>在模板表达式中写比较复杂的算式可读性不好，而且不方便复用。这时可以使用计算属性。如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123; &#123; reverseTxt &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">var ap7 = new Vue(&#123;</span><br><span class="line">  el: &apos;#ap7&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    txt: &apos;sdg&apos;  </span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    reverseTxt: function() &#123;</span><br><span class="line">      return this.txt.split(&apos;&apos;).reverse().join(&apos;&apos;);  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>计算属性与方法的不同在于计算属性自带缓存，当this.txt没有发生改变时，不会重新计算直接返回<br>缓存值。<br>计算属性与侦听器的不同在于计算属性可以同时监控多个属性的变化，而侦听器只能针对单个属性的变化<br>分别定义函数。<br>计算属性默认是get方法，即计算结果值由”监测”的属性计算得到，但也可以通过设置计算属性值反过来<br>设置监测的属性值。通过这种联动可以实现实例中属性的双向影响，感觉在某些场景中这种相互影响非常<br>实用。代码如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line"> reverseTxt: &#123;</span><br><span class="line">   get: function() &#123;</span><br><span class="line">      return this.txt.split(&apos;&apos;).reverse().join(&apos;&apos;);  </span><br><span class="line">   &#125;,</span><br><span class="line">   set: function(val) &#123;</span><br><span class="line">      this.txt = val.split(&apos;&apos;).reverse().join(&apos;&apos;);  </span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>侦听器在属性值发生变化时可以调用相应的函数，如发出ajax异步请求等。为防止请求过于频繁，教程中<br>使用lodash的debounce方法限制请求间隔，使用axios发出ajax请求。</p>
<h3 id="class与style绑定"><a href="#class与style绑定" class="headerlink" title="class与style绑定"></a>class与style绑定</h3><p>v-bind指令在设置标签的样式如class, style属性时除了字符串，还可以绑定一个对象或数组。</p>
<ol>
<li>class<br>传递对象:<br>如<code>&lt;p v-bind:class=&quot;{real: isReal, active: isActive}&quot;&gt;&lt;/p&gt;</code>,这个绑定的对象<br>除了可以在这里直接定义，还可以定义在实例的data选项属性中，或是计算属性中(更强大的控制)。</li>
</ol>
<p>其中，对象的属性名是具体的class名称，属性值是该class是否生效的boolean值。为truthy时该class<br>生效，为false时该class不生效。<br>注: <strong>js中除false, 0, “”, null, undefined, NaN以外，都是真值，即为truthy.</strong></p>
<p>实例中定义为<code>data: {isReal: true, isActive: false}</code>.</p>
<p>注: v-bind:class可以和普通的class属性共存。</p>
<p>传递数组:<br>比起使用boolean值控制class列表的对象语法，数组语法通过class列表的字符串数组进行控制，<br>如<code>v-bind:class=&quot;[aClass, bClass]&quot;</code>，同理，为实现控制，这里的aClass,bClass是实例的属性名，<br>实例中有<code>data: {aClass: &#39;a&#39;, bClass: &#39;b&#39;}</code>, a和b即为具体的class名称。当需要去除某个class时，<br>将对应属性值设置为’’即可。如果需要动态控制，可以在数组语法中嵌套使用对象语法，<br>如<code>v-bind:class=&#39;[{aClass: aflag}, bClass]</code>.</p>
<p>用在组件上:<br>在自定义组件中通过以上2种方式带数据绑定的class会追加到组件的根元素中，不会覆盖已有的class列表。 </p>
<ol start="2">
<li>style<br>通过style绑定的是内联样式，直接指定样式，不需要中间的class层，适合样式少并分散的情况。</li>
</ol>
<p>对象语法:<br>如<code>v-bind:style=&quot;{color: acolor, fontSize: fs + &#39;px&#39;}&quot;</code>, 实例中定义<br><code>data: {acolor: &#39;red&#39;, fs: 30}</code>,<br>同样的，可以将该对象定义在实例data中，或使用计算属性。<br>如<code>v-bind:style=&quot;sty&quot;</code>, <code>data: {sty: {color: &#39;red&#39;, fontSize: &#39;30px&#39;}}</code>.</p>
<p>数组语法:<br>style的数组语法可以使用多个style对象进行控制，这里使用对象语法一个style对象即可以控制，<br>所以数组语法意义不大，就此略过。</p>
<p>自动添加前缀: 对于非标准的浏览器引擎CSS前缀，v-bind:style会自动添加前缀，可忽略。<br>多重值: style样式属性值除字符串外，还可以传递数组，vue会选择数组中最后一个支持的浏览器样式，<br>可忽略。</p>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><ol>
<li>v-if<br>在单个标签中使用v-if=”seen”, 当seen为false时，刷新后该标签一闪而过后消失。应该是渲染的执行<br>顺序问题。当需要控制隐藏多个标签时，使用template标签并在其中使用v-if指令，发现没有出现闪烁<br>现象。</li>
</ol>
<p>v-if后可以使用v-else-if，v-else指令块控制多个元素的显式隐藏。要求必须相应的元素必须紧靠在<br>一起，否则无法识别。</p>
<p>当使用v-if切换2个template元素组时，vue会复用已经有的元素，这样在切换时会出现元素中已有的<br>值(如用户的输入值)不会被清空的情况。这时可以给这2个template中相同的元素设置key属性，相当于<br>指定了id, 通过设置不同的key值，vue就不会复用该元素。而未指定key时，vue将复用相同元素提高<br>渲染速度。</p>
<ol start="2">
<li>v-show<br>v-show指令值为false时相当于style=’display:none”，所以v-show元素始终存在于dom中。</li>
</ol>
<p>注: v-if是真正的条件渲染，而且是惰性的(只有第一次为真时才开始渲染)，切换开销较大；而v-show<br>始终会渲染，初始开销大，但切换时只是CSS变换，切换开销小。<br>所以如果频繁切换应使用v-show, 切换较少时使用v-if.</p>
<p>注: 不应当在同一个元素内同时使用v-if和v-for指令，因为v-for指令优先级更高，这样当只需要渲染<br>其中一小部分元素时，却遍历了整个列表进行判断。这时应当使用计算属性过滤出需要的列表，对其<br>使用v-for指令渲染，这样更高效，而且将筛选逻辑解耦出来了(而且计算属性还自带缓存，可以复用)。</p>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ol>
<li>渲染列表<br>v-for指令在li标签上使用可以渲染一个列表。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;item in items&quot;&gt;&#123; &#123; item.txt &#125;&#125;&lt;/li&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  items: [</span><br><span class="line">    &#123;txt: &quot;one&quot;&#125;,</span><br><span class="line">    &#123;txt: &quot;two&quot;&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>v-for还可以写为<code>v-for=&quot;(item, index) in items&quot;</code>, index为自动添加的索引。<br>还可以使用of代替in, 如<code>v-for=&quot;(item, index) of items&quot;</code>。</p>
<ol start="2">
<li>v-for中使用对象<br>如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;value in obj&quot;&gt;&#123; &#123;value&#125;&#125;&lt;/li&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    title: &apos;tt&apos;,</span><br><span class="line">    name: &apos;ss&apos;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>同时显示对象属性名和值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;(value, name) in obj&quot;&gt;&#123; &#123;name&#125;&#125;: &#123; &#123;value&#125;&#125;&lt;/li&gt;</span><br><span class="line">或</span><br><span class="line">&lt;li v-for=&quot;(value, name, index) in obj&quot;&gt;&#123; &#123;index&#125;&#125;:&#123; &#123;name&#125;&#125;: &#123; &#123;value&#125;&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure></p>
<p>注: 模板表达式只能识别单个属性，<code>{ {name: value}}</code>会报错。<br>遍历顺序为Object.keys()结果。</p>
<ol start="3">
<li><p>维护状态<br>同前面v-if的元素复用类似，v-for指令在未指定key时使用默认的”就地更新”策略，即不会主动更改<br>dom元素位置，而是更新每个元素值。这种模式很高效，但它只适用于输出的DOM非常简单的情况。<br>一般建议是在使用v-for指令时，同时使用v-bind:key=”item.id”值为每一个列表项指定id.<br>使用key后，会强制更新元素或组件而不是重复利用已有元素，适用于触发过渡效果。</p>
</li>
<li><p>数组更新检测<br>当v-for的数组内容发生变化时，对应的列表也会发生变化，数组变化的方法有<br>push, pop, shift, unshift, splice, sort, reverse.这些方法会改变原数组，而其他另外一些方法<br>如filter, concat, slice等没有改变原数组，这时如果想要重新渲染列表，可以使用计算属性，<br>在其中将得到的新数组替换原属性即可(vue会尽量复用已有DOM, 不会马上销毁原有DOM重新渲染)。</p>
</li>
</ol>
<p>注: 直接使用索引修改元素值如a[i] = 3和a.length = 3无法实现响应式更新。对于前者可以使用<br>Vue.set(vm.items, index, newValue)或vm.items.splice(index, 1, newValue),<br>对于后者可以使用vm.items.splice(newlength).</p>
<p>splice意思是拼接，splice(startIndex, deleteCount, item1, item2…)意为从startIndex(包括)开始删除<br>deleteCount个字符，并在相同位置插入元素item1, item2…, 该方法改变了原数组，方法的返回值是<br>被删除的元素数组。</p>
<ol start="5">
<li>对象变更检测<br>前面说过，对于已经初始化完成的vue实例，后面再添加属性值是不支持响应式更新的。(即时支持<br>好像也没有实际作用)。但可以对属性对象进行修改。<br>如果添加单个属性可以使用<code>Vue.set(vm.obj, &#39;name&#39;, 29)</code>添加或修改属性，如果要添加多个时，<br>可以使用<code>vm.obj = Object.assign({}, vm.obj, {&#39;name&#39;:29, &#39;sex&#39;: &#39;m&#39;});</code><br>这里新建一个vm.obj对象而不是直接<code>Object.assign(vm.obj, {...})</code>的原因经网上搜索，说如果直接<br>修改vm对象，可能会导致基于vm的元素出现渲染问题，所以还是使用新对象较好。而且使用{}当vm.obj<br>对象为undefined时不会报错。即assign的源对象可以为undefined. </li>
</ol>
<p>注: Object.assign()复制的是属性值，为浅拷贝，如果需要深拷贝，可以json序列化后再解析，即<br>let copy = JSON.parse(JSON.stringify(source));</p>
<ol start="6">
<li><p>显示过滤/排序后的结果<br>前面已经说过，需要过滤时应使用计算属性或方法对数组处理后再使用v-for指令渲染(直接使用v-if<br>性能低，耦合度高)。在使用v-for循环嵌套时，列表不是data属性(是数据内部的次级列表)，无法直接<br>访问所以不能使用计算属性，只能使用方法来处理。</p>
</li>
<li><p>v-for使用值范围<br><code>&lt;p v-for=&quot;n in 10&quot;&gt;{ {n}}&lt;/p&gt;</code>输出12345678910</p>
</li>
<li><p>template上使用v-for<br>对于一组需要多次重复的元素组，可以在template上使用v-for. 具体需求如表格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b4&quot;&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">              &lt;template v-for=&quot;row in rows&quot;&gt;</span><br><span class="line">                      &lt;tr&gt;</span><br><span class="line">                              &lt;td&gt;&#123; &#123;row.a&#125;&#125;&lt;/td&gt;</span><br><span class="line">                              &lt;td&gt;&#123; &#123;row.b&#125;&#125;&lt;/td&gt;</span><br><span class="line">                      &lt;/tr&gt;</span><br><span class="line">              &lt;/template&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var b4 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b4&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              rows: [</span><br><span class="line">                      &#123;a: &apos;11&apos;, b: &apos;12&apos;&#125;,</span><br><span class="line">                      &#123;a: &apos;21&apos;, b: &apos;22&apos;&#125;</span><br><span class="line">              ]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件上使用v-for<br>前面说过，组件中应使用key区分每个列表内元素保证渲染正确。同时组件有自己的作用域，需要使用<br>prop来传递数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li is=&quot;myComponent&quot; </span><br><span class="line">  v-for=&quot;(item,index) in list&quot; </span><br><span class="line">  :key = &quot;item.id&quot;</span><br><span class="line">  :content = &quot;item.text&quot;</span><br><span class="line">  @remove=&quot;list.splice(index, 1)&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中is=”myComponent”是因为html限制ul中只有li是有效标签，要在其中使用自定义元素myComponent<br>时，需要通过is进行标记。key为item.id, 组件props属性(数组)为<code>[&#39;content&#39;]</code>(即li标签显示内容),<br>赋值为item.text.最后是点击按钮触发remove事件时将数组中该项去除，这样会同步响应到视图中。</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ol>
<li>内联语句<br>如v-on:click=”count += 1”可以让属性count自增1</li>
<li>绑定到方法<br>使用如v-on:click=”afterClicked”将动作绑定到实例方法，处理逻辑都在方法中定义。</li>
<li>内联语句中调用方法<br>如v-on:click=”say(‘oneClick’)”, 在内联语句中调用方法。此时可以用$event向方法中传入原生<br>DOM事件，如v-on:click=”say(‘oneClick’, $event)”.</li>
<li><p>事件修饰符<br>某些情况需要阻止事件的默认行为，如form表单提交的默认重载页面行为，一般是使用<br>event.preventDefault(), vue提供了修饰符简化该操作，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.stop 阻止事件继续传播 </span><br><span class="line">.prevent 阻止事件默认行为</span><br><span class="line">.capture 捕获内部元素事件，捕获处理完毕后再交还子元素</span><br><span class="line">.self 只处理自身的事件，内部元素触发的事件不进入该处理</span><br><span class="line">.once 该事件方法只会被调用一次</span><br><span class="line">.passive 告诉浏览器执行事件的默认行为(正好与.prevent相反), </span><br><span class="line">         与.prevent一起使用时.prevent会被忽略</span><br></pre></td></tr></table></figure>
</li>
<li><p>按键修饰符<br>监听键盘事件时，可以指定按键。<br>如v-on:keyup.enter=”submit”回车键调用submit方法，<br>v-on:keyup.page-down=”onPageDown”按下pageDown键时调用onPageDown方法。<br>键名可以使用KeyboardEvent.key得到。<br>可以通过以下方式获取:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;b5&quot;&gt;</span><br><span class="line">      &lt;input @keyup=&quot;go($event)&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var b5 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b5&apos;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">              go: function (e) &#123;</span><br><span class="line">                      console.log(e.key);</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注：按键码keycode用法已经被废弃，应避免使用</p>
<ol start="6">
<li>系统修饰键<br>键盘修饰键只有在按下时才能触发，有<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如alt+c触发clear方法: <code>&lt;input @keyup.alt.c=&quot;clear&quot;&gt;</code>，<br>完整代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b5&quot;&gt;</span><br><span class="line">    &lt;input @keyup.alt.c=&quot;clear&quot; v-model=&quot;mess&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var b5 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b5&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              mess: &apos;&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">              clear: function () &#123;</span><br><span class="line">                      this.mess = &apos;&apos;;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的<a href="mailto:`@keyup.alt.c" target="_blank" rel="noopener">`@keyup.alt.c</a>=”clear”<code>当alt和其他的修饰键如ctrl, shift等一起按下时也会调用，使用
.exact修饰符可以控制只有alt被按下时才会调用clear方法,代码为</code>@keyup.alt.exact.c=”clear”`.</p>
<ol start="7">
<li>鼠标按钮修饰符<br>.left .right .middle</li>
</ol>
<h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>v-model实际是语法糖，它监听用户的输入事件并更新数据。<br>v-model适用于input, textarea, checkbox, radio, select元素。</p>
<p>text, textarea, select根据value属性的变化触发input事件。<br>checkbox, radio根据checked属性的变化触发change事件。</p>
<p>v-model绑定的值为元素值。如<code>&lt;input type=&#39;checkbox&#39; value=&#39;one&#39; v-model=&#39;arr&#39;&gt;</code>中，复选框<br>选中时arr数组中有值one, 未勾选时无值one. 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b6&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; value=&quot;one&quot; v-model=&quot;arr&quot;/&gt;&lt;label&gt;one&lt;/label&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; value=&quot;two&quot; v-model=&quot;arr&quot;/&gt;&lt;label&gt;two&lt;/label&gt;</span><br><span class="line">      &lt;p&gt;&#123; &#123;arr&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var b6 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b6&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              arr: []</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用<code>&lt;textarea&gt;{ {mess}}&lt;/textarea&gt;</code>无法实现双向绑定，只有初始时可以成功渲染mess值，用户<br>在输入文本后，mess值并不会相应的变化，若要实现双向绑定必须使用<code>&lt;textarea v-model=&#39;mess&#39;/&gt;</code>.</p>
<p>select下拉框:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b7&quot;&gt;</span><br><span class="line">      &lt;select v-model=&quot;sel&quot;&gt;</span><br><span class="line">              &lt;option disabled value=&quot;&quot;&gt;please select&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;A&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;B&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;C&lt;/option&gt;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">      &lt;p&gt;&#123; &#123;sel&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var b7 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b7&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              sel: &apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>多选下拉框除绑定到一个数组外，标签使用multiple标记为可多选，具体选择时按住ctrl键可多选<br><code>&lt;select v-model=&#39;selected&#39; multiple&gt;...&lt;/select&gt;</code></p>
<h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p>以上使用v-model时单选框，复选框，下拉框的值都是静态的，为字符串(复选框可以为boolean值)。<br>实际使用时如下拉框，选中的选项需要绑定到一个对象，这时简单的绑定方式<code>&lt;option&gt;A&lt;/option&gt;</code><br>(该选项值为A)就不能满足需求，这时可以进一步对选项的值进行绑定，即值绑定。</p>
<p>即<code>&lt;option v-bind:value=&quot;{name: &#39;zs&#39;, age: 20}&quot;</code>.这样通过v-bind指令对value属性进一步绑定<br>即可满足要求。</p>
<p>如下代码展示了下拉框联动后获取子下拉框选择的具体对象信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b8&quot;&gt;</span><br><span class="line">      &lt;select v-model=&quot;parent&quot; @change=&quot;changeList&quot;&gt;</span><br><span class="line">              &lt;option disabled value=&quot;&quot;&gt;please select one&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;a&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;b&lt;/option&gt;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">      &lt;select v-model=&quot;child&quot;&gt;</span><br><span class="line">              &lt;option disabled value=&quot;&quot;&gt;please select one&lt;/option&gt;</span><br><span class="line">              &lt;option v-for=&quot;item in list&quot; :key=&quot;item.id&quot; :value=&quot;item&quot;&gt;&#123; &#123; item.name &#125;&#125;&lt;/option&gt;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">      &lt;p&gt;id: &#123; &#123;child.id&#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;name: &#123; &#123;child.name&#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;age: &#123; &#123;child.age&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var b8 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b8&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              parent: &apos;&apos;,</span><br><span class="line">              child: &#123;&#125;,</span><br><span class="line">              list: []</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">            changeList: function () &#123;</span><br><span class="line">                  if (this.parent == &apos;a&apos;) &#123;</span><br><span class="line">                          this.list = [</span><br><span class="line">                                  &#123;id: 1, name: &apos;a1&apos;, age: 11&#125;,</span><br><span class="line">                                  &#123;id: 2, name: &apos;a2&apos;, age: 22&#125;];</span><br><span class="line">                  &#125;else&#123;</span><br><span class="line">                          this.list = [</span><br><span class="line">                                  &#123;id: 3, name: &apos;b1&apos;, age: 33&#125;,</span><br><span class="line">                                  &#123;id: 4, name: &apos;b2&apos;, age: 44&#125;];</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以注意到，要获取子下拉框选择的对象信息，直接绑定<code>:value=&quot;item&quot;</code>.</p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>.lazy<br><code>&lt;input v-model.lazy=&quot;mess&quot; /&gt;&lt;p&gt;{ {mess}}&lt;/p&gt;</code>, 这时输入字符时显示文本不会马上改变，而是<br>回车或tab键后改变，即.lazy使用change事件，而不是input事件。</p>
<p>.number<br><code>&lt;input v-model.number=&#39;age&#39; type=&#39;number&#39;/&gt;</code>将用户输入值变为数字类型。经测试，type=’number’<br>有上下调整按钮，并且无法输入数字。不使用.number时typeof(b9.num)返回string类型。</p>
<p>.trim<br><code>&lt;input v-model.trim=&#39;txt&#39;/&gt;</code>去除首尾空白字符。</p>
<h3 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h3><h4 id="组件data必须是一个函数"><a href="#组件data必须是一个函数" class="headerlink" title="组件data必须是一个函数"></a>组件data必须是一个函数</h4><p>自定义组件代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c1&quot;&gt;</span><br><span class="line">      &lt;clock&gt;&lt;/clock&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;clock&apos;, &#123;</span><br><span class="line">      data: function () &#123;</span><br><span class="line">              return &#123; count: 0 &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: &apos;&lt;button @click=&quot;count++&quot;&gt;&#123; &#123;count&#125;&#125;&lt;/button&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c1 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c1&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>组件是可以复用的vue实例，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;clock /&gt;</span><br><span class="line">  &lt;clock /&gt;</span><br><span class="line">  &lt;clock /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中每个clock都是一个不同的实例，都有自己的属性定义。所以组件定义中data属性不能同上面一样<br>是一个简单的对象，而需要是一个函数，该函数返回需要的data对象，这样每个实例就有自己的对象了。</p>
<p><code>c1=new Vue({el: &#39;#c1})</code>中c1是根实例，el是根实例特有的属性。</p>
<p>经测试发现，组件复用时这种写法<code>&lt;clock/&gt;&lt;clock/&gt;</code>只有一个组件会显示，而<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;clock&gt;&lt;/clock&gt;</span><br><span class="line">&lt;clock&gt;&lt;/clock&gt;</span><br></pre></td></tr></table></figure></p>
<p>这种写法才能正确的显示多个自定义组件，原因不明。</p>
<h4 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h4><p>组件是通过嵌套树的形式进行组织的。<code>Vue.component(&#39;(xxx&#39;, {...})</code>的形式是全局注册。<br>在全局注册后任意新创建的Vue根实例和子组件实例(即为全局)都可以使用该组件，<br>经测试将上面的组件定义和根实例定义顺序颠倒，vue报错<code>unknown custom element</code>.</p>
<h4 id="通过prop向子组件传递数据"><a href="#通过prop向子组件传递数据" class="headerlink" title="通过prop向子组件传递数据"></a>通过prop向子组件传递数据</h4><p>为了给组件传递值，Vue使用props属性将需要传递的属性名集合为一个数组，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;xx&apos;, &#123;</span><br><span class="line">  props: [&apos;title&apos;],</span><br><span class="line">  template: &apos;&lt;p&gt;&#123; &#123;title&#125;&#125;&lt;/p&gt;&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在组件模板中可以像访问data中的值一样访问props中的属性。<br>传值时只需要像普通html标签的属性值赋值一样即可，如<code>&lt;clock title=&#39;wttClock&#39;/&gt;</code>.<br>同理，当属性值是动态值(如v-for列表中)时，一样使用如<code>v-bind:title=&#39;item.title&#39;</code>进行属性绑定。</p>
<p>组件属性prop除了可以是字符串类型的属性外，还支持将一个对象作为属性。这样向组件传值时就<br>不需要逐个具体指明对象的属性值，只需要绑定该对象即可。<br>需要注意的是，传值时不能同字符串一样直接赋值，需要使用v-bind标签绑定值对象。即前面的缩写<br>冒号不可少。代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c1&quot;&gt;</span><br><span class="line">      &lt;clock&gt;&lt;/clock&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;clock&apos;, &#123;</span><br><span class="line">      data: function () &#123;</span><br><span class="line">              return &#123; count: 0 &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: &apos;&lt;button @click=&quot;count++&quot;&gt;&#123; &#123;count&#125;&#125;&lt;/button&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c1 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c1&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;c1&quot;&gt;</span><br><span class="line">      &lt;clock :property=&quot;&#123;name: &apos;wttClock&apos;, color: &apos;red&apos;&#125;&quot;&gt;&lt;/clock&gt;</span><br><span class="line">      &lt;clock :property=&quot;&#123;name: &apos;wttClock2&apos;, color: &apos;red2&apos;&#125;&quot;&gt;&lt;/clock&gt;</span><br><span class="line">      &lt;clock :property=&quot;&#123;name: &apos;wttClock3&apos;, color: &apos;red3&apos;&#125;&quot; other=&quot;GGG&quot;&gt;&lt;/clock&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;clock&apos;, &#123;</span><br><span class="line">      data: function () &#123;</span><br><span class="line">              return &#123; count: 0&#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      props: [&apos;property&apos;, &apos;other&apos;],</span><br><span class="line">      template: &apos;&lt;div&gt;&apos; +</span><br><span class="line">              &apos;&lt;p&gt;&#123; &#123;property.name&#125;&#125; is &#123; &#123;property.color&#125;&#125;&lt;/p&gt;&apos; +</span><br><span class="line">              &apos;&lt;button @click=&quot;count++&quot;&gt; and &#123; &#123;other&#125;&#125;,&apos; +</span><br><span class="line">              &apos; clicked &#123; &#123;count&#125;&#125; times&lt;/button&gt;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var c1 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c1&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>同时，需要注意的是，组件模板中使用了property属性对象的相关信息进行显示，使用组件时必须给出<br>property属性值，否则会报错。如这里会报错<code>cannot read property: name of undefined</code>, 对应着<br>模板第一处的<code>{ {property.name}}</code>。</p>
<h4 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h4><p>组件模板template中只能包含一个根元素，所以当模板中存在多个平级标签时，必须使用一个元素标签<br>将多个元素”包裹”起来。</p>
<h4 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h4><p>有时候需要根据组件内部子元素的事件修改自定义组件所在元素(即其父组件)的状态，如点击按钮修改<br>父组件中所有文本的字体大小, 这时就需要将自定义组件内部的事件”传播”给其父组件进行处理,<br>反过来也可以说父组件监听子组件的事件.</p>
<p>实现该功能需要两步设置.</p>
<ol>
<li>在子组件上”发射”事件.如<code>&lt;button @click=&quot;$emit(&#39;afterClicked&#39;)&quot;&gt;&lt;/button&gt;</code>, 其中将点击<br>操作通过内建的$emit方法触发一个事件, 指定事件名为afterClicked.</li>
<li>在父组件中使用如<code>&lt;self-component v-on:afterClicked=&quot;doSth&quot;&gt;&lt;/self-component&gt;</code>,<br>这里需要注意的是这里的响应函数属于父组件,处理的属性也是父组件的属性,不可与子组件混淆.</li>
</ol>
<p>具体代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c2&quot; :style=&quot;&#123;fontSize: fs&#125;&quot;&gt;</span><br><span class="line">      &lt;p&gt;I am Text being affected by wtt click event&lt;/p&gt;</span><br><span class="line">  &lt;wtt v-on:ee=&quot;cfs&quot;&gt;&lt;/wtt&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;wtt&apos;, &#123;</span><br><span class="line">   data: function () &#123;</span><br><span class="line">         return &#123;</span><br><span class="line">                 acolor: &apos;red&apos;</span><br><span class="line">         &#125;;</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">           changeColor: function () &#123;</span><br><span class="line">                   this.acolor = &apos;black&apos;;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   template: &apos;&lt;div :style=&quot;&#123;color: acolor&#125;&quot;&gt;&apos; +</span><br><span class="line">           &apos;&lt;p&gt;WTT GO FUN&lt;/p&gt;&apos; +</span><br><span class="line">           &apos;&lt;button @click=&quot;changeColor&quot; :style=&quot;&#123;color: acolor&#125;&quot;&gt;call wtt component inner methods to change color of&apos; +</span><br><span class="line">           &apos; wtt&lt;/button&gt;&lt;br&gt;&lt;br&gt;&apos;+</span><br><span class="line">           &apos;&lt;button @click=&quot;$emit(\&apos;ee\&apos;, 20)&quot; :style=&quot;&#123;color: acolor&#125;&quot;&gt;change parent text fontSize&lt;/button&gt;&apos;+</span><br><span class="line">           &apos;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c2 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c2&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">            fs: 10</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">              cfs: function (am) &#123;</span><br><span class="line">                    this.fs = am;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>其中,可以看到$emit方法还可以传递第二个参数, 这里代表新的字体大小, 即子组件触发事件时可以给出<br>更具体的信息或指令. 父组件进行响应处理时如果是表达式, 用$event可以得到该参数值,如果是方法,<br>直接如上使用第一个参数即可.</p>
<h4 id="组件上使用v-model"><a href="#组件上使用v-model" class="headerlink" title="组件上使用v-model"></a>组件上使用v-model</h4><p>普通标签的v-model实际上是语法糖, 即<code>&lt;input v-model=&#39;it&#39; /&gt;</code>它等价于<br><code>&lt;input :value=&#39;it&#39; :input=&#39;it = $event.target.value&#39; /&gt;</code>, 即input标签的值取属性it的值,<br>同时将input标签的输入值赋值给属性it, 这样就实现了双向绑定.</p>
<p>自定义组件实现双向绑定,同理如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;wtt :value=&apos;it&apos; :input=&apos;it = $event&apos;&gt;&lt;/wtt&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中, 首先wtt组件需要有value这个属性, 即props中有属性value; 再是wtt组件中的input标签同前面<br>所说需要触发一个事件名为’input’. 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c3&quot;&gt;</span><br><span class="line">      &lt;wtt-input :value=&quot;mess&quot; @input=&quot;mess=$event&quot;&gt;&lt;/wtt-input&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;wtt-input&apos;, &#123;</span><br><span class="line">    props: [&apos;value&apos;],</span><br><span class="line">    template: &apos;&lt;div&gt;\</span><br><span class="line">                &lt;p&gt;wtt-input value is &#123; &#123;value&#125;&#125;&lt;/p&gt;\</span><br><span class="line">                &lt;input @input=&quot;$emit(\&apos;input\&apos;, $event.target.value)&quot; :value=&quot;value&quot;&gt;\</span><br><span class="line">               &lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c3 = new Vue(&#123;</span><br><span class="line">    el: &apos;#c3&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">          mess: &apos;xxx&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>其中为了让组件内的值与prop mess同步显示, 使用了<code>:value=&quot;value&quot;</code>进行绑定.<br>这时就可以在input框中输入值,通过p标签查看prop值; 同时在console中使用<code>c3.mess = &#39;gogo&#39;</code>命令<br>后可以看到input框的值同步发生了改变, 从而验证出确实实现了双向绑定.</p>
<h4 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h4><p>以上的自定义组件使用时是这种模板<code>&lt;wtt&gt;&lt;/wtt&gt;</code>, 如果想要像普通元素一样在标签中传值,如<br><code>&lt;p&gt;message&lt;/p&gt;</code>, 可以使用Vue的自定义元素slot, 使用时<code>&lt;wtt&gt;Hello World&lt;/wtt&gt;</code>或直接内嵌<br>其他标签<code>&lt;wtt&gt;&lt;div&gt;&lt;p&gt;GO FUN&lt;/p&gt;&lt;button&gt;click me&lt;/button&gt;&lt;/div&gt;&lt;/wtt&gt;</code>.然后只需要在组件<br>定义模板中插入<code>&lt;slot&gt;&lt;/slot&gt;</code>即可.具体代码略.</p>
<h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><p>某些场景下需要一个动态的组件, 即根据不同的条件该组件的类型可以切换.<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c5&quot;&gt;</span><br><span class="line">      &lt;button @click=&quot;cc&quot;&gt;change the component type&lt;/button&gt;</span><br><span class="line">      &lt;component :is=&quot;curComp&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;wtt-a&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;I am A&lt;/p&gt;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(&apos;wtt-b&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;I am B&lt;/p&gt;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(&apos;wtt-c&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;I am C&lt;/p&gt;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c5 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c5&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">            comps: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;],</span><br><span class="line">              index: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">            curComp: function () &#123;</span><br><span class="line">                  return &apos;wtt-&apos; + this.comps[this.index];</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">              cc: function () &#123;</span><br><span class="line">                      this.index = ++this.index % this.comps.length;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>编写过程中发现几点要注意:</p>
<ol>
<li>组件名要多个单词, 自定义高一点, 使用如a作为组件名时(a是超链接…), vue会给出警告.</li>
<li>计算属性中不要忘记使用this引用data中的属性.</li>
</ol>
<p>从代码中可以看出, 组件动态化主要就是利用了Vue的Component标签配合其is属性, 在is属性中指定<br>具体的组件名称即可实现组件类型的切换.</p>
<p>注: 除了可以使用具体的完整组件名称, 还可以使用一个对象数组, 对象属性包括组件名称和组件模板,<br>具体代码略过.</p>
<h4 id="解析DOM模板需要注意内容"><a href="#解析DOM模板需要注意内容" class="headerlink" title="解析DOM模板需要注意内容"></a>解析DOM模板需要注意内容</h4><p>如前面说过的, 某些标签如<code>&lt;ul&gt;</code>中只允许出现<code>&lt;li&gt;</code>标签,这时如果在其中加入自定义组件会被视为<br>无效标签而被提取到<code>&lt;ul&gt;</code>标签外,渲染出现问题.<br>如以下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c6&quot;&gt;</span><br><span class="line">      &lt;p&gt;Hello world&lt;/p&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">              &lt;wtt-row&gt;&lt;/wtt-row&gt;</span><br><span class="line">              &lt;tr&gt;&lt;td&gt;Done&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;wtt-row&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;tr&gt;&lt;td&gt;I am wtt-row&lt;/td&gt;&lt;/tr&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c6 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c6&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>通过devTool查看元素可以看到,wtt-row被提取到table标签外, 渲染错误.这时可以使用<br><code>&lt;tr is=&#39;wtt-row&#39;&gt;&lt;/tr&gt;</code>代替<code>&lt;wtt-row&gt;&lt;/wtt-row&gt;</code>.再次查看, 可见渲染成功.<br>这是在普通的html页面中使用出现的问题,如果是在以下场景中使用就没有该问题,<br>不需要使用is特性:</p>
<ol>
<li><p>字符串中, 如以上例子这样写也可以成功渲染.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c6&quot;&gt;</span><br><span class="line">      &lt;p&gt;Hello world&lt;/p&gt;</span><br><span class="line">      &lt;wtt-table&gt;&lt;/wtt-table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;wtt-row&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;tr&gt;&lt;td&gt;I am wtt-li&lt;/td&gt;&lt;/tr&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(&apos;wtt-table&apos;, &#123;</span><br><span class="line">      template: &quot; &lt;table&gt; &lt;wtt-row&gt;&lt;/wtt-row&gt; &lt;tr&gt;&lt;td&gt;Done&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var c6 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c6&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>单文件组件.vue, 暂略</p>
</li>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code>, 暂略</li>
</ol>
<h3 id="深入了解组件"><a href="#深入了解组件" class="headerlink" title="深入了解组件"></a>深入了解组件</h3><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><h4 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h4><p>组件名推荐使用多个小写单词, 并且必须包含一个连字符, 这样可以避免与已有或未来的html标签名<br>冲突.</p>
<h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>前面使用Vue.component(‘xx’, {…})的方式即为全局注册, 在注册以后后面创建的vue根实例都可以<br>使用该组件, 其他组件也能使用.</p>
<h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>全局注册的问题在于即使没有使用该组件,该组件注册后仍然会在最终的依赖结果中.这时可以使用局部<br>注册.代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c6&quot;&gt;</span><br><span class="line">      &lt;p&gt;Hello world&lt;/p&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">              &lt;tr is=&quot;wtt-row&quot;&gt;&lt;/tr&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var wttRow=&#123;name: &apos;wtt-row&apos;,</span><br><span class="line">      template: &apos;&lt;tr&gt;&lt;td&gt;I am wtt-row&lt;/td&gt;&lt;/tr&gt;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">var c6 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c6&apos;,</span><br><span class="line">      components: &#123;</span><br><span class="line">              &apos;wtt-row&apos;: wttRow</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>可以看出, 局部注册就是在需要使用自定义组件的vue实例中使用components属性列出所有需要的组件,<br>列出组件名称和对应的组件对象, 组件对象有name属性和template属性(与全局注册组件一致).</p>
<p>经测试wttRow也不能放在c6 vue实例后面定义, 否则报错<code>unknown custom element</code>, 对于这个问题<br>组件对象本身的定义位置无影响, 应该是vue渲染的顺序性(或者生命周期?)要求导致.</p>
<p>注: 局部注册的组件在子组件中不可用.<br>这应该是显而易见的, 子组件中也可用的组件是全局注册的组件.</p>
<h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h4><p>暂略</p>
<h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><h4 id="prop的大小写"><a href="#prop的大小写" class="headerlink" title="prop的大小写"></a>prop的大小写</h4><p>组件属性在定义时使用正常变量命名规范驼峰式命名方式(camelCase)如<code>wttTxt</code>, 但在html Dom中使用时如果<br>直接使用这种命名如<code>&lt;wtt-com wttTxt=&#39;mes&#39;&gt;&lt;/wtt-com&gt;</code>, 浏览器无法正常显示, 在devTool中vue<br>显示了一个tip, 告知这种情况下, 应使用kebab-case方式, 即<code>&lt;wtt-com wtt-txt=&#39;mes&#39;&gt;&lt;/wtt-com&gt;</code>.</p>
<h4 id="prop类型"><a href="#prop类型" class="headerlink" title="prop类型"></a>prop类型</h4><p>属性除了有字符串类型, 还有其他类型, 如布尔型<code>checked=true</code>, 数字型<code>width=100</code>等,这时props<br>字符串数组无法满足需求, 可以使用对象来定义props. 如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  message: String,</span><br><span class="line">  checked: Boolean,</span><br><span class="line">  width: Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中, 对象属性名为prop名称, 对应属性值为prop类型. 其他类型有Array, Object, Function,<br>Promise.</p>
<h4 id="传递静态或动态prop"><a href="#传递静态或动态prop" class="headerlink" title="传递静态或动态prop"></a>传递静态或动态prop</h4><p>如前面所说, 在传递prop属性值时, 直接赋值如<code>&lt;wtt-com num=&#39;88&#39;&gt;&lt;/wtt-com&gt;</code>,这时属性<br>num的值是字符串”88”, 如果需要传递数字类型, 需要使用v-bind指令,如<br><code>&lt;wtt-com :num=&#39;88&#39;&gt;&lt;/wtt-com&gt;</code>. 这时<code>props: {num: Number}</code>即可正常工作.<br>其他类型, Boolean, Array, Object类型同理都需要使用v-bind指令.</p>
<p>注: 不带参数的v-bind指令如<code>&lt;wtt-com v-bind=&#39;obj&#39;&gt;&lt;/wtt-com&gt;</code>是将obj的所有属性作为prop传入,<br>代码略.</p>
<h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>有时候组件需要”修改”通过prop属性传递进来的值, 主要就是将传进来的该属性值作为初始值,<br>后续在组件内部进行修改.如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c7&quot;&gt;</span><br><span class="line">      &lt;wtt-com :init-num=&quot;88&quot;&gt;&lt;/wtt-com&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var wttCom = &#123;name: &apos;wtt-com&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">            initNum: Number</span><br><span class="line">      &#125;,</span><br><span class="line">      data: function()&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">                  wttCount: this.initNum</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">          add: function () &#123;</span><br><span class="line">                this.wttCount++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;&#123; &#123;wttCount&#125;&#125;&lt;/p&gt;&lt;button @click=&quot;initNum++&quot;&gt;increment&apos; +</span><br><span class="line">              &apos; wttTxt&lt;/button&gt;&lt;/div&gt;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">var c7 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c7&apos;,</span><br><span class="line">      components: &#123;</span><br><span class="line">              &apos;wtt-com&apos;: wttCom</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>运行代码, vue给出报错信息:<code>应避免直接修改一个prop属性, 应使用data或计算属性</code>, 这里我们改成<br><code>wttCount++</code>即可实现功能.</p>
<p>另外, 经测试, 如果这样写<code>@click=&#39;this.initNum++&#39;</code>, 点击按钮无反应, 可以想到template中的<br>this已经没有指向该组件实例了(可能是渲染时的其他中间对象). 但如果绑定到方法上<code>@click=&#39;add&#39;</code>,<br>这时就需要如上面代码所写<code>this.wttCount++</code>, 因为这时this确实是指向该组件实例的, 不加this<br>则会报错.</p>
<p>这种只能从父组件传递数据到子组件, 而子组件不能直接修改prop的方式即为单向数据流.</p>
<p>不过, 因为javascript中对象和数组是引用传递, 所以对于数组或对象类型的prop属性, 如果在组件中<br>直接修改prop, vue不会报错并且修改成功. 对于该问题, 为避免影响到父组件, 可以在data中拷贝对象<br>进行处理, 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c7&quot;&gt;</span><br><span class="line">      &lt;wtt-com :init-num=&quot;&#123;val: 88&#125;&quot;&gt;&lt;/wtt-com&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var wttCom = &#123;name: &apos;wtt-com&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">            initNum: Object</span><br><span class="line">      &#125;,</span><br><span class="line">      data: function()&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">                  wttCount: Object.assign(&#123;&#125;, initNum)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;initNum is &#123; &#123;initNum&#125;&#125;&lt;/p&gt;&lt;p&gt;wttCount is &#123; &#123;wttCount&#125;&#125;&lt;/p&gt;&apos; +</span><br><span class="line">              &apos;&lt;button @click=&quot;wttCount.val++&quot;&gt;increment wttCount&lt;/button&gt;&lt;/div&gt;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">var c7 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c7&apos;,</span><br><span class="line">      components: &#123;</span><br><span class="line">              &apos;wtt-com&apos;: wttCom</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>注: 使用时同样需注意Object.assign的浅拷贝问题.</p>
<h4 id="prop验证"><a href="#prop验证" class="headerlink" title="prop验证"></a>prop验证</h4><p>prop除了可以指定类型外, 还可以指定是否必输, 默认值, 自定义验证函数等. 如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  wttProp: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    required: true,</span><br><span class="line">    default: 100,    // 对象或数组的默认值是从函数获得</span><br><span class="line">    validator: funtion(val)&#123;  // 值必须是66, 77, 88之一</span><br><span class="line">      return [66, 77, 88].indexOf(val) != -1;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>prop验证是在组件实例创建前完成, 所以default, validator函数不能使用data, computed等中的值.</p>
<p>注: 除基本类型外, prop还可以为自定义对象类型, 如<code>props: {man: Person}</code>, validator中可以用<br>instanceof验证类型.</p>
<h4 id="非prop的特性"><a href="#非prop的特性" class="headerlink" title="非prop的特性"></a>非prop的特性</h4><p>某些场景下, 子组件没有定义某个prop, 这时可以直接传递需要的prop值, 如给某些组件打上是否<br>激活的标记, 如<code>&lt;wtt-com :disabled=&quot;true&quot;&gt;&lt;/wtt-com&gt;</code>, wtt-com中可以不用定义disabled特性,<br>该特性会被添加到组件根元素下,外界需要判断时直接判断即可.</p>
<p>外部传入的prop属性通常会替换组件模板内已定义的值, 而class和style特性会将两者合并起来.</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>教程中说:子组件产出的事件名和父组件监听的事件名必须保持一致(事件名与prop属性不同,<br>不会进行camelCase和kebab-case的转化), 即this.$emit(‘myEvent’)只有@myEvent才能监听到,<br>但myEvent事件的监听会被dom自动转化为全小写.所以@myEvent监听不到.<strong>但经实际测试, 可以监听到….</strong></p>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h3 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件&amp;异步组件"></a>动态组件&amp;异步组件</h3><h3 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h3><h3 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h3><h3 id="进入-离开-amp-列表过渡"><a href="#进入-离开-amp-列表过渡" class="headerlink" title="进入/离开&amp;列表过渡"></a>进入/离开&amp;列表过渡</h3><h3 id="状态过渡"><a href="#状态过渡" class="headerlink" title="状态过渡"></a>状态过渡</h3><h3 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性&amp;组合"></a>可复用性&amp;组合</h3><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><h3 id="渲染函数-amp-JSX"><a href="#渲染函数-amp-JSX" class="headerlink" title="渲染函数&amp;JSX"></a>渲染函数&amp;JSX</h3><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h3 id="TypeScript支持"><a href="#TypeScript支持" class="headerlink" title="TypeScript支持"></a>TypeScript支持</h3><h3 id="生产环境部署"><a href="#生产环境部署" class="headerlink" title="生产环境部署"></a>生产环境部署</h3><h3 id="规模化"><a href="#规模化" class="headerlink" title="规模化"></a>规模化</h3><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><h3 id="内在"><a href="#内在" class="headerlink" title="内在"></a>内在</h3><h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><h2 id="springboot整合vue"><a href="#springboot整合vue" class="headerlink" title="springboot整合vue"></a>springboot整合vue</h2><ol>
<li>建立父项目, 有2个模块. 在父项目中定义spring-boot-starter-parent版本</li>
<li>用springboot initializer新建子模块backend, 依赖选starter-web和mybatis, 建立后修改parent<br>改为第一步中新建的父项目, 修改build 插件实现拷贝vue相关静态文件到backend的static目录下.  </li>
<li>使用windows安装包安装node, 安装过程中选择第二个带npm的选项.</li>
<li><code>npm install -g @vue/cli</code>, 完成后使用<code>vue --version</code>查看版本.</li>
<li>在frontend目录下执行<code>vue create frontend</code>, 删除frontend下的src目录, 将生成的vue项目<br>frontend下的所有内容提到上一级的frontend目录中.</li>
<li>编写后台代码, 启动测试后台服务</li>
<li>添加axios. frontend目录下执行<code>npm install axios --save</code>.</li>
<li>使用vue-cli-plugin-element添加element-ui组件.frontend目录下执行命令为<code>vue add element</code></li>
<li>idea添加vue.js插件(网络不好未安装);<br>filetypes - html - .vue;<br>javascript es6;<br>editor - file and code templates -&gt; + Vue File, extension vue, open with html format</li>
<li>修改element.js, 引入table, tableColumn组件, 修改App.vue, 使用axios请求后台.<br>后台服务地址暂定为请求根目录<code>/xxx</code>.</li>
<li>在backend中执行<code>mvn process-resources</code>将frontend dist全部内容拷贝到backend<br><code>src/main/resources</code>中.</li>
<li>启动BackendApplication main方法.</li>
<li>frontend下添加.eslintrc.js, 添加devServe配置, 使得npm run serve时可以访问后端服务.  </li>
</ol>
<p>别人的架子</p>
<ol>
<li>安装node, npm</li>
<li>执行命令<code>npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass</code>  </li>
<li>frontend下npm install</li>
<li>npm run serve查看页面</li>
<li>npm run build生成</li>
<li>主目录执行<code>mvn --projects backend springboot:run --settings d://alimaven//settings.xml</code>.</li>
</ol>
<h2 id="webpack-4-41-2使用"><a href="#webpack-4-41-2使用" class="headerlink" title="webpack 4.41.2使用"></a>webpack 4.41.2使用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li>entry<br>处理依赖的起始位置 默认./src</li>
<li>output<br>打包输出(emit)信息,包括路径,文件名等</li>
<li>loader<br>loader可以将非js文件转换为依赖处理. 可以在module.rules中配置.<br>test选中处理目标(可以用正则表达式), use指明使用哪个loader.</li>
<li>plugins<br>实现如打包优化和压缩等一系列功能.</li>
<li>模式<br>开发或生产模式, 启用webpack内置优化</li>
</ol>
<h3 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h3><h4 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h4><ol>
<li>npm init -y<br>npm i webpack webpack-cli –save-dev</li>
<li>新建dist/index.html, src/index.js, 修改package.json为private</li>
<li>npm i –save lodash</li>
<li>npx webpack  该命令是运行<code>node_modules</code>中的webpack命令, 将src/index.js转变为dist/main.js</li>
<li>使用浏览器打开index.html查看效果</li>
<li>新建webpack.config.js, 其中output修改为dist/bundle.js, 所以dist/html中也需要修改.</li>
<li>npm webpack –config webpack.config.js  这里–config可省略,默认即为webpack.config.js</li>
<li>添加npm脚本, npm run build代替npx命令</li>
</ol>
<h4 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h4><ol>
<li>npm i –save-dev style-loader css-loader  </li>
<li>修改webpack.config.js指定使用style-loader, css-loader加载css文件. </li>
<li>新建src/style.css, 修改index.js import ‘./style.css’; element.classList.add(‘hello’);</li>
<li>npm run build</li>
<li>浏览器打开index.html查看效果, 通过dev-tool查看网页代码head标签, 源码被压缩无法查看</li>
</ol>
<p>图片</p>
<ol>
<li>npm i file-loader –save-dev</li>
<li>修改webpack.config.js使用fileloader处理png, jpg等格式文件</li>
<li>在src下添加图片, src/index.js引入图片, src/style.css使用该图片作为背景图片</li>
<li>npm run build</li>
<li>浏览器打开index.html查看效果, 通过dev-tool查看网页代码head标签, 源码被压缩无法查看</li>
</ol>
<p>字体<br>file-loader同样可以处理字体, 具体过程同上, src/style.css中可以使用@font-face引入</p>
<p>加载本地数据<br>使用csv-loader, xml-loader可以加载本地的csv/tsv, xml数据文件<br>还可以处理json格式数据, src/index.js中引入的变量为解析后的JSON数据(经测试xml实际被转换为<br>一个对象, 根节点为属性名).</p>
<h4 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h4><p>多入口</p>
<ol>
<li>新建src/print.js, 修改src/index.js使用print.js, 修改webpack.config.js添加入口,并修改<br>输出文件名.</li>
<li>npm run build</li>
<li>index.html查看效果</li>
</ol>
<p>使用HtmlWebpackPlugin生成index.html文件<br>到目前为止,webpack帮我们将src/index.js等文件连同依赖进行打包, 但dist/index.html还是我们<br>自己手动写的标签, 当上面的输出文件如dist/xx.bundle.js名字修改后,还要手动修改dist/index.html,<br>这时我们可以使用该插件自动生成dist/index.html文件</p>
<ol>
<li>npm i html-webpack-plugin –save-dev</li>
<li>修改webpack.config.js引入该插件</li>
<li>npm run build<br>可以看到, <code>*.bundle.js, index.html</code>都是webpack生成(emit)的, webpack plugin中设置的title即为<br>页面title, 相应的script标签内嵌在body标签中.</li>
</ol>
<p>清理dist文件夹</p>
<ol>
<li>npm i clean-webpack-plugin –save-dev</li>
<li>修改webpack.config.js引入该插件</li>
<li>npm run build<br>这里发现使用的clean-webpack-plugin版本为3.0.0, 文档写法报错CleanWebpackPlugin is not a<br>constructor, 改为const {CleanWebpackPlugin} = require(‘..’);<br>plugins中写new CleanWebpackPlugin()即可. 这里的变量名不可修改, 否则同样报错not a constructor.</li>
</ol>
<h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p>source map<br>追踪错误具体位置, 修改webpack.config.js后重新编译即可.<br>source map是js自带功能, 无需使用插件.它有很多选项, 针对开发环境和生产环境有不同的推荐,<br>经测试发现inline-source-map可以显示原代码的js文件名称和行数, 适合开发环境错误定位.</p>
<p>开发工具<br>前面每次修改完配置或代码, 都需要重新编译生成文件,非常麻烦, 这里同样可以使用webpack提供的<br>多种方法自动编译.</p>
<ol>
<li>watch<br>修改package.json, 建立一个npm脚本命令”watch”: “webpack –watch”.使用<code>npm run watch</code>执行该<br>脚本. 这里其实是用<code>npm run watch</code>代替执行<code>npm run build</code>, 不同的是命令会一直执行, 始终监控.</li>
</ol>
<p>修改src/print.js后发现脚本有自动重新编译, 但是需要刷新浏览器才能看见效果.</p>
<ol start="2">
<li><p>webpack-dev-server<br>这是webpack提供的一个web服务器, 可以实现自动刷新(live reload). </p>
<ol>
<li>npm i webpack-dev-server –save-dev</li>
<li>修改webpack.config.js指定devServer代码加载位置</li>
<li>修改package.json添加npm start脚本启动devServer.<br>经测试, 执行<code>npm start</code>后自动打开<code>localhost:8080</code>页面, 修改文件后自动刷新生效.</li>
</ol>
</li>
<li><p>webpack-dev-middleware<br>webpack-dev-server内部使用了该middleware, 它也可以单独使用, 进行自定义配置, 这里略过.</p>
</li>
</ol>
<p>最后提到, 文件编辑器的safe-write功能可能影响重新编译, 应该是说dist目录不能被重新编译结果<br>自动覆盖.vim中没有发现该问题, 后面遇到再说.</p>
<h4 id="HMR-hot-module-replacement"><a href="#HMR-hot-module-replacement" class="headerlink" title="HMR hot module replacement"></a>HMR hot module replacement</h4><p>无需完全刷新可以热加载模块, 如样式等. 暂时未发现用途, 暂略</p>
<h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h4><p>打包时去除没有被引用的模块.<br>简单的修改package.json, 指定mode: “production”可以压缩打包输出, 也可以使用命令行<br><code>npm run build --optimize-minimize</code>来启用webpack内部的压缩插件UglifyJsPlugin.</p>
<ol>
<li>npm i uglifyjs-webpack-plugin</li>
<li>修改webpack.config.js引入该plugin</li>
<li>npm run build<br>查看dist目录大小, 发现压缩后目录小了10倍!</li>
</ol>
<h4 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h4><p>同spring相同, webpack也可以对于开发和生产环境进行不同的配置, 并且它可以将公共的部分提取出来,<br>再使用webpack-merge工具将配置进行整合.</p>
<ol>
<li>删除webpack.config.js, 新建webpack.common.js, webpack.dev.js, webpack.prod.js, </li>
<li>npm i webpack-merge –save-dev</li>
<li>修改package.json将start定义为生产环境启动脚本, build定义为打生产环境包. </li>
</ol>
<p>生产环境的sourceMap可以在webconfig.prod.js的UglifyJsPlugin中指定.<br>另外, <code>process.env.NODE_ENV</code>是个重要的环境变量, 因为在webpack.config.js中无法直接赋值(是个<br>bug?), 所以需要通过new webpack.DefinePlugin(…)的形式赋值, 赋值后所有依赖包括用户自己的<br>代码都可以使用, 如代码中可以判断该变量得到当前环境是开发还是生产环境来进行逻辑处理.</p>
<p>分离CSS文件适用于css文件较大的情况, 暂时略过.</p>
<p>可以看到, common中配置的是共同配置, dev和prod配置中通过引入merge模块对象, 聚合了common配置<br>和自己额外添加的配置. start和build脚本通过前面提过的–config指定自己需要的配置文件.<br>注意:</p>
<ol>
<li>css loader也需要添加到common配置中</li>
<li>clean webpack plugin使用方式需如上修改</li>
<li>npm start后可以发现dist中没有文件生成, 它只是启动了内置web服务器, 用于开发调试, 需要生成<br>文件时仍需npm run build</li>
</ol>
<h4 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h4><p>前面的src/index.js中引入了loadash模块, 如果添加另外一个入口src/b.js, b.js中如果也引入了<br>loadash模块, 那么打包时就会将该模块重复打入2个bundle中. 因为文档中的插件CommonsChunkPlugin<br>已过时,现在只能使用SplitChunksPlugin插件进行提取公共依赖.</p>
<ol>
<li><p>修改webpack.common.js, 这里我们简单的加上配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: &apos;all&apos;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>npm run build后发现, 输出目录中多了一个vendors~app~b.bundle.js文件, 其中即包含了共同依赖<br>loadash, 再查看app.bundle.js, b.bundle.js文件, 可以看见其中已经都没有了loadash模块.</p>
</li>
</ol>
<p>动态导入<br>前面使用模块是import xx from xx 或 import {xx} from xx的形式, ES5还有动态加载import(…)方法,<br>它基于异步操作, webpack将它作为分离的模块起点, 打包时(包括子模块)会作为一个单独的chunk包.<br>因为import无法设置模块名称和属性, 所以webpack只能通过注释来定义这里的chunk名称!<br>这个功能暂时略过。</p>
<p>bundle分析<br>可以通过工具分析生成的bundle, 具体以后使用到再看。</p>
<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>懒加载提高了应用的启动速度，灵外某些模块可能永远不会被加载(如用户没有触发该动作)。<br>上面的分离chunks是从技术上提高了加载速度，但不属于懒加载。<br>下面操作只有在用户点击按钮时才加载src/print.js模块。</p>
<ol>
<li>修改print.js, index.js中使用动态加载import().</li>
<li>修改webpack.common.js指定非入口chunk名称，即动态加载的模块名称，其中的name如上面所说是<br>动态加载时通过注释指定的。</li>
</ol>
<p>经测试，npm run build会uglifyjs插件会报错。暂时注释后运行成功，点击按钮后print.js模块才会<br>加载。另外，我们在webpack.common.js中只指定了app和b2个入口，编译后发现多了一个print.bundle.js,<br>说明动态加载确实默认是作为分离入口。</p>
<p>以上uglifyjs报错，是因为uglifyjs不支持es6(上面的动态加载使用了es6的语法), 可以不用uglifyjs<br>插件，转而使用支持es6的插件terser-webpack-plugin, 在webpack.prod.js中这样配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">//const UglifyJSPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);</span><br><span class="line">const common = require(&apos;./webpack.common.js&apos;);</span><br><span class="line">const TerserPlugin = require(&apos;terser-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  devtool: &apos;source-map&apos;,</span><br><span class="line">  plugins: [</span><br><span class="line">    //   new UglifyJSPlugin(&#123;</span><br><span class="line">    //     sourceMap: true</span><br><span class="line">    //   &#125;),</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env.NODE_ENV&apos;: JSON.stringify(&apos;production&apos;)</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        sourceMap: true,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>总体来说，这个问题可以使用babel解决。</p>
<p>教程最后提到， react, vue, angular都有自己的方式实现懒加载，如vue router和vuex都可以实现<br>懒加载。这里简单记录下，后面再看具体原理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//vue router</span><br><span class="line">// Instead of: import Login from &apos;./login&apos;</span><br><span class="line">const Login = () =&gt; import(&quot;./login&quot;);</span><br><span class="line"></span><br><span class="line">new VueRouter(&#123;</span><br><span class="line">  routes: [&#123; path: &quot;/login&quot;, component: Login &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//vuex module</span><br><span class="line">const store = new Vuex.Store()</span><br><span class="line"></span><br><span class="line">// Assume there is a &quot;login&quot; module we wanna load</span><br><span class="line">import(&apos;./store/login&apos;).then(loginModule =&gt; &#123;</span><br><span class="line">  store.registerModule(&apos;login&apos;, loginModule)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>在开发过程中可以通过禁用浏览器缓存或刷新缓存的方式来加载新编译的文件，但生产环境中不可能<br>要求用户这样做，这就要求webpack重新编译后能自动刷新客户端的缓存。实际在现实中，都是部署完<br>以后再让用户使用，线上升级还是比较少。这里的缓存个人感觉主要还是提高了开发过程中浏览器的<br>缓存性能，提高开发效率。尤其是模块依赖比较多的情况。</p>
<p>实际上，缓存复用的基础是文件名相同，所以我们可以让每次修改后文件名发生变动即可。即<br>webpack.common.js中output的配置由<code>filename: &#39;[name].bundle.js</code>改为<br><code>filename: [name].[chunkhash].js</code>, 可以看到这里输出的文件名中包含了编译时的hash值。</p>
<p>注: 经过以上测试后，不修改文件的情况下重复编译发现哈希码没有变化，说明新版本没有文档中说的<br>hash问题。</p>
<p>anyway, 为了利用缓存提高性能，主要是需要进行拆分:</p>
<ol>
<li>将模板代码(主要指manifest的内容)和引入的第三方依赖模块提取出来，这里也需要用到前面的<br>自动切分插件SplitChunksPlugin.</li>
<li>分离后主要有三块内容，自己的业务逻辑代码main bundle, 依赖包vendor bundle，以及样板<br>manifest bundle。<br>除了删除vendor依赖的情况外，其他情况vendor bundle都不应当发生变化(指其文件名的hash值)。<br>这里它变化的原因在于hash值是根据module.id生成的，而module.id会受解析顺序的影响。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">也就是说，当解析顺序发生变化，ID 也会随之改变。因此，简要概括：</span><br><span class="line">main bundle 会随着自身的新增内容的修改，而发生变化。</span><br><span class="line">vendor bundle 会随着自身的 module.id 的修改，而发生变化。</span><br><span class="line">manifest bundle 会因为当前包含一个新模块的引用，而发生变化。</span><br><span class="line">第一个和最后一个都是符合预期的行为 -- 而 vendor 的 hash 发生变化是我们要修复的。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为了解决vendor的问题，即我们不应当使用module.id来生成hash值，webpack提供了NamedModulesPlugin,<br>HashedModuleIdsPlugin, 它们的原理都是根据文件路径来生成hash值，这样就解决了没有进行修改<br>vendor也会发生变化的问题。</p>
<p>注: 对于runtime chunk问题，在默认的SplitChunksPlugin中没有测试出该问题。所以使用SplitChunksPlugin<br>的默认配置即可，默认为async.</p>
<p>为了查看具体的输出打包效果，这里需要先配置图形化工具，这里使用Webpack bundle analyzer plugin.</p>
<ol>
<li>npm i webpack-bundle-analyzer –save-dev</li>
<li>为了灵活方便，先生成json文件，再查看该文件。修改webpack.prod.js引入插件，修改package.json<br>编写npm脚本启动服务展示。查看完以后，修改webpack.prod.js中的generateStatsFile为false即可<br>避免生成json文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">webpack.prod.js</span><br><span class="line"></span><br><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin</span><br><span class="line">  plugins: [</span><br><span class="line">    new BundleAnalyzerPlugin(&#123;</span><br><span class="line">      analyzerMode: &apos;disabled&apos;, // 不启动展示打包报告的http服务器</span><br><span class="line">      generateStatsFile: true, // 是否生成stats.json文件</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">package.json</span><br><span class="line">    // 这句实际可省略，因为在webpack.prod.js配置后，可由npm run build代替</span><br><span class="line">    &quot;getjson&quot;: &quot;webpack --profile --json &gt; ./dist/stats.json&quot;,  </span><br><span class="line">    &quot;analyze&quot;: &quot;webpack-bundle-analyzer --port 8888 ./dist/stats.json&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>splitcChunksPlugin配置意义:<br>插件默认将<code>node_modules</code>中所有的模块划为一个缓存组vendors, 所有重复的依赖划为缓存组default。<br>default组默认优先级为-20, vendors默认优先级为-10.</p>
<ol>
<li>optimization.splitChunks.chunks有3种值，async, initial, all<br>async: 只对异步加载的chunk处理。即任意一个动态引入的依赖都会被切分为一个新chunk,<br>静态的依赖即使有重复依赖也不会优化。</li>
</ol>
<p>initial: 对初始chunk处理，初始有重复引入的依赖将被切分。而异步加载的依赖根据动态引入的默认<br>处理方式也会被切分，最后结果即为静态和动态导入的包都可以得到优化。它的问题在于对静态和动态<br>依赖的区分处理，这种区分会导致某些既有静态又有动态引入的相同模块被重复打包。为避免该问题，<br>应使用下面的all方式。</p>
<p>all: 即不区分动态和静态引入，统一处理。针对上面既有动态又有静态引入的相同模块，从结果看<br>是统一作为动态引入处理(由最终bundle名称确定，未亲自测试)。</p>
<p>这样看，默认的async没有优化重复的静态引入，应当使用all方式。<br>另外，应当使用optimization.runtimeChunk: “single”, 经测试几行代码打出的包就有几k大小，将<br>webpack运行时单独打一个包后回到正常的几百字节。修改js文件内容不影响打出的runtime文件。</p>
<h2 id="webpack4-整合vue"><a href="#webpack4-整合vue" class="headerlink" title="webpack4 整合vue"></a>webpack4 整合vue</h2><p>Vue-loader</p>
<h3 id="起步-1"><a href="#起步-1" class="headerlink" title="起步"></a>起步</h3><ol>
<li>npm i -D vue-loader vue-template-compiler<br><strong>npm install xxx 默认是生产模式，依赖追加到dependencies; npm install -D xxx 相当于–save-dev</strong></li>
<li>修改webpack.common.js引入vue-loader plugin, 并针对.vue, .css文件进行处理。</li>
</ol>
<p>其中loader除了配置外，还需要引入插件，这样如对js配置babel处理时，vue文件中的script块才能<br>同样得到处理. </p>
<h3 id="处理资源路径"><a href="#处理资源路径" class="headerlink" title="处理资源路径"></a>处理资源路径</h3><p>vue-loader会自动将template中的资源转化为模块请求, 对css文件配置了css-loader后, css块中的资源<br>同样也会被转化为模块请求, 这是vue文件的资源处理机制.</p>
<p>注: </p>
<ol>
<li>资源路径中如果以@开头, 会被看作是模块依赖, 可以在webpack中给@设置别名.如/src目录.</li>
<li>url-loader会将小文件转化为内联base64编码的url地址,减少http请求次数, 文件过大后使用<br>file-loader. 使用base64编码的图片体积会变大, 影响加载css文件速度.</li>
</ol>
<h3 id="使用预处理器"><a href="#使用预处理器" class="headerlink" title="使用预处理器"></a>使用预处理器</h3><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>现在有三大CSS预处理器, sass/scss, less, stylus, 经查找scss用的较多,较为一般性. </p>
<ol>
<li>npm i -D sass-loader node-sass</li>
<li>修改webpack.common.js, 针对.scss文件处理<br>这时可以在.vue文件中使用<code>&lt;style lang=&quot;scss&quot;&gt;...&lt;/style&gt;</code>使用scss.</li>
</ol>
<p>注: sass-loader默认不处理基于缩进的sass语法.需要额外配置, 这里暂不使用, 略过. </p>
<h4 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a>postcss</h4><p>postcss是一款使用插件转换css的工具,经查看, 总体实用性不强, 其中autoprefixer和stylelint<br>还可以, 暂略过.也可以注意到vue loader默认不应用postcss变换.</p>
<h4 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h4><p>轻松编写es6语法代码无需担心浏览器支持的神器, 必装.</p>
<ol>
<li>npm i -D @babel/core @babel/preset-env babel-loader</li>
<li>修改webpack.common.js对.js文件使用babel-loader, 同时排除掉<code>node_modules</code>目录中的文件,<br>但如果<code>node_modules</code>目录中有vue单文件组件, 还是应当使用babel转化, 所以需要进行判断筛选.</li>
<li>babel转换代码有时会产生重复代码, 如对class类的编译会产生多个工具函数. 这个问题可以通过<br>babel插件实现: <code>npm i -D @babel/plugin-transform-runtime @babel/runtime</code>.</li>
<li>polyfill可以提供某些不支持的特性, 从而支持完整的ES2015+环境.<code>npm i -D @babel/polyfill</code>.</li>
<li>编写babel.config.js文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    presets: [</span><br><span class="line">            &apos;@babel/preset-env&apos;,</span><br><span class="line">            &#123;</span><br><span class="line">                useBuiltIns: &apos;usage&apos;, // usage-按需引入 entry-入口引入（整体引入） false-不引入polyfill</span><br><span class="line">                corejs: 3  // 2-corejs@2  3-corejs@3</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    plugins: [&apos;@babel/plugin-transform-runtime&apos;]</span><br><span class="line">&#125;;</span><br><span class="line">6. npm i core-js@3 axios vue vue-router vuex</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h4><p>略</p>
<h4 id="pug"><a href="#pug" class="headerlink" title="pug"></a>pug</h4><p>是一个可以快速编写html标签的工具, 暂时不需要, 略过.</p>
<h4 id="scoped-css"><a href="#scoped-css" class="headerlink" title="scoped css"></a>scoped css</h4><p>暂略<br>使用scoped后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件<br>的scoped CSS 和子组件的 scoped CSS 的影响。即子组件大部分是不受父组件影响, 只有其根节点例外,<br>如div标签等.</p>
<h4 id="css-modules"><a href="#css-modules" class="headerlink" title="css modules"></a>css modules</h4><p>因为webpack现在是单入口或多入口, 引入css样式时非常容易造成全局命名冲突等问题, css模块化<br>依靠webpack等构建工具给出了解决方案. 具体就是编译过后样式名字会被自动加工.<br>具体略过, 个人推荐使用sass.</p>
<h4 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h4><p>略<br>hmr会对打包的hash文件名报错, 经查找资料, 说开发环境不应当使用hash值作为输出文件名.<br>所以可以根据环境不同输出不同的名字.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">主要是修改webpack.dev.js文件, hmr只用于开发环境</span><br><span class="line"></span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const common = require(&apos;./webpack.common.js&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  devtool: &apos;inline-source-map&apos;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &apos;./dist&apos;,</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">webpack.common.js配置有关内容为:</span><br><span class="line">提取css插件的支持:</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sa|sc|c)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: &apos;./&apos;,</span><br><span class="line">              hmr: devMode   // 开发环境开启hmr</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          &apos;sass-loader&apos;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">主要是文件名的不同:</span><br><span class="line">  plugins: [</span><br><span class="line">    new CleanWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;DemoHtml&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    new VueLoaderPlugin(),</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: devMode ? &apos;css/[name].css&apos; : &apos;css/[name].[chunkhash].css&apos;,</span><br><span class="line">      chunkFilename: devMode ? &apos;css/[id].css&apos; : &apos;css/[id].[chunkhash].css&apos;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: devMode ? &apos;[name].js&apos; : &apos;[name].[chunkhash].js&apos;,</span><br><span class="line">    chunkFilename: devMode ? &apos;[name].js&apos; : &apos;[name].[chunkhash].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;..&apos;, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>略</p>
<h4 id="自定义块"><a href="#自定义块" class="headerlink" title="自定义块"></a>自定义块</h4><p>略</p>
<h4 id="css提取"><a href="#css提取" class="headerlink" title="css提取"></a>css提取</h4><ol>
<li>npm i -D optimize-css-assets-webpack-plugin mini-css-extract-plugin </li>
<li>修改webpack配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">webpack.common.js:</span><br><span class="line"></span><br><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">const devMode = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class="line"></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sa|sc|c)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          devMode ? &apos;vue-style-loader&apos; : MiniCssExtractPlugin.loader,</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          &apos;sass-loader&apos;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      // Options similar to the same options in webpackOptions.output</span><br><span class="line">      // both options are optional</span><br><span class="line">      filename: devMode ? &apos;[name].css&apos; : &apos;[name].[hash].css&apos;,</span><br><span class="line">      chunkFilename: devMode ? &apos;[id].css&apos; : &apos;[id].[hash].css&apos;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">webpack.prod.js</span><br><span class="line"></span><br><span class="line">const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line"> optimization: &#123;</span><br><span class="line">    minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        styles: &#123;</span><br><span class="line">          name: &apos;styles&apos;,</span><br><span class="line">          test: /\.(sa|sc|c)ss$/,</span><br><span class="line">          chunks: &apos;all&apos;,</span><br><span class="line">          enforce: true,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="引入依赖的路径和省略后缀符问题"><a href="#引入依赖的路径和省略后缀符问题" class="headerlink" title="引入依赖的路径和省略后缀符问题"></a>引入依赖的路径和省略后缀符问题</h3><p>在build中写util.js定义resolve寻找项目根路径,assetsPath是静态资源目录, 在webpack.common.js中<br>引入util.js对.js, .vue, .json后缀名的文件进行解析.,</p>
<h3 id="图片拷贝问题"><a href="#图片拷贝问题" class="headerlink" title="图片拷贝问题"></a>图片拷贝问题</h3><ol>
<li>npm i -D copy-webpack-plugin</li>
<li>修改webpack.common.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const devMode = process.env.NODE_ENV !== &apos;production&apos;;</span><br><span class="line"></span><br><span class="line">new CopyWebpackPlugin([&#123;</span><br><span class="line">      from: utils.resolve(&apos;static/img&apos;),</span><br><span class="line">      to: utils.resolve(&apos;dist/static/img&apos;),</span><br><span class="line">      toType: &apos;dir&apos;</span><br><span class="line">    &#125;])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="起步-2"><a href="#起步-2" class="headerlink" title="起步"></a>起步</h3><p>不同的组件都有一个路径值, 路径匹配后router将该组件渲染到指定位置.</p>
<ol>
<li>router-link是路由入口,通过to属性指定跳转路径,可以有多个; router-view标签输出匹配的组件.</li>
<li>新建VueRouter实例并将其放入Vue根实例中.</li>
</ol>
<h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>路径中使用冒号开头的参数可以匹配不同的值, 参数名是键, 参数值为键值, 作为对象放入$route.params中,<br>如<code>/usr/:name/post/:postid</code>匹配到<code>/usr/wtt/post/123</code>时, $route.params为<br><code>{name: &#39;wtt&#39;, postid: &#39;123&#39;}</code>.</p>
<p>路由变化时会复用组件, 所以生命周期不会被调用. 可以通过watch $route对象在路由变化时进行操作.<br>匹配优先级: 当一个路径同时匹配多个路由时, 优先定义的优先匹配</p>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code>输出匹配路由的组件。但该组件本身也可以使用<br><code>&lt;router-view&gt;&lt;/router-view</code>调用另外一个路由组件，这就构成了路由嵌套。<br>这时使用children属性在路由参数中进行配置。<br>注: 可以提供空的子路由组件便于子路径参数为空时时使用。</p>
<h3 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h3><p><code>&lt;router-link :to=&quot;...&quot;&gt;</code>标签内部其实调用了this.$router.push(…)方法，所以我们可以直接调用<br>该方法进行自定义跳转。<br>注: params与path不能同时使用(在push方法和to属性中)，用以下写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const userId = &apos;123&apos;</span><br><span class="line">router.push(&#123;name: &apos;user, params: &#123;userId&#125;&#125;)</span><br><span class="line">router.push(&#123;path: `/user/$&#123;userId&#125;`&#125;)</span><br></pre></td></tr></table></figure></p>
<p>push方法后面还有onComplete和onAbort参数，适用于完成路由跳转或终止时调用。<br>但如果路由路径不变，只有参数发生变化时，这两个参数无法被调用，需要使用beforeRouteUpdate属性<br>进行处理。<br>router.replace方法不会向history添加记录，而是替换当前history记录。<br>router.go(n)在记录中向前或向后多少步。负数为后退，正数为前进。</p>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>可以给路由命名，使用name属性，这与上面的push使用name属性跳转是相同的。</p>
<h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p>前面的<code>&lt;router-view&gt;&lt;/router-view&gt;</code>只有一个路由出口，如果想要对一个路由同时展示2个不同的<br>组件时(如侧边栏和主栏), 这时候就需要用到命名视图了。这时，该路由对应的就是多个组件，即<br>使用<code>components</code>属性而不是<code>component</code>.<br>router-view通过name属性指定不同的名字，components中通过name指定不同的组件。</p>
<p>嵌套路由可以和命名视图组合起来使用实现复杂的页面视图控制。<br>注: 命名视图如果在配置中找不到同名的组件，就不会显示组件内容。<br><code>&lt;router-view&gt;&lt;/router-view&gt;</code>默认命名是default.</p>
<p>可以看到:</p>
<ol>
<li>嵌套路由就是组件中以直接或间接的方式(用组件封装起来，如UserSettingsNav组件)给出子路由的<br>链接, 即<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&apos;/xxx/a&apos;&gt;&lt;/router-link&gt; </span><br><span class="line">&lt;router-link to=&apos;/xxx/b&apos;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>并使用children属性配置子路由的组件。</p>
<ol start="2">
<li>命名就是组件中使用多个<code>router-view</code>出口，用name属性区分开。并在路由配置中使用components<br>属性指定每个名字视图对应的组件。</li>
</ol>
<p>结合起来，嵌套路由和命名视图同时使用时就是多个router-link和router-view同时使用。</p>
<h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><p>在routes配置中也可以配置重定向，将<code>{path: &#39;/a&#39;, component: Foo}</code>改为<br><code>{path: &#39;/a&#39;, redirect: &#39;/b&#39;}</code>即可实现重定向。或者redirect: {name: ‘xx’}重定向到命名视图。 </p>
<p>重定向是从/a跳转到/b, 然后匹配路由/b，而别名是跳转时保持url为/b, 但实际匹配为/a.<br>语法为<code>{path: &#39;/a&#39;, component: xx, alias: &#39;/b&#39;}</code>.<br>别名如在嵌套路由中匹配<code>/a/b/c/xxx</code>, 这时可以设置别名<code>/y</code>，访问<code>/y</code>时实际匹配<code>/a/b/c/xxx</code>,<br>感觉同linux的别名功能是相同的。</p>
<h3 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h3><p>前面定义组件时，有用到<code>&lt;div&gt;$route.params.id&lt;/div&gt;</code>，看到这样的写法就应当意识到通过路由<br>显示该组件时，该路由需要有一个动态参数如xxx/:id进行匹配。这种组件定义明显限制了组件的<br>使用范围，所以我们不应当使用$route.params来获取路由传递的参数，而使用props代替。routes配置:<br><code>{path: &#39;/xxx/:id&#39;, component: User, props: true}</code>, 对于命名视图，需要一一对应定义props:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &apos;xx/:id&apos;,</span><br><span class="line">  components: &#123;default: User, another: Another&#125;,</span><br><span class="line">  props: &#123;default: true, another: false&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的路由id是传给默认的User组件，所以props User为true, another为false.<br>注: 反过来想，我们通过路由参数给组件的属性进行了赋值操作。<br>即props设置为true时即将$route.params设置为了组件属性.同时，props还可以是对象或一个函数，<br>这2种情况下相应的路由值也会作为属性传递给组件。</p>
<h3 id="html5-history模式"><a href="#html5-history模式" class="headerlink" title="html5 history模式"></a>html5 history模式</h3><p>vue-router默认hash(指<code>#</code>号)模式，即<code>http://www.baidu.com/#/hello</code>中的hash值为<code>#/hello</code>, 改变这个hash<br>值，页面不会向服务端发送请求，这就是单页应用的关键。</p>
<p>因为<code>#</code>号夹杂在url中不好看，所以可以使用history模式，前端在路由配置中覆盖所有路由情况，<br>在最后配置一个404页面，同时后端也需要在匹配不到任何路径时也返回一个页面，防止后端报404错误。</p>
<p>注: history模式不能刷新和地址栏访问页面, 需要后端对每个url地址进行处理, 所以相比hash模式,<br>history模式更麻烦, 同时它还有publicPath的问题, 需要修改图片等资源才能正常加载, 如无必要使用<br>hash模式即可.</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h3 id="简单store模式-without-vuex"><a href="#简单store模式-without-vuex" class="headerlink" title="简单store模式 without vuex"></a>简单store模式 without vuex</h3><p>当组件变多后,组件间参数传递变的复杂,而且经常有多个组件依赖一个数据源进行渲染, 或多个组件<br>同时更新一个数据源的情况,这时就需要进行状态管理, 这就是vuex的作用.<br>但是当应用很简单时, 可以简单使用store模式即可.</p>
<p>简单来说, 单纯使用一个对象state来记录状态,当组件改变它时, 没有修改记录, 所以无法追踪和控制, 我<br>们将该state对象封装到另外一个对象store中, 然后通过set方法去改变state属性, 这样就实现了<br>历史记录和统一管理.可以看出这种设计符合了面向对象编程的封装变化的设计原则.</p>
<p>以上简单store模式建立的是action -&gt; store -&gt; view的数据流向图. 这里action直接改变store,<br>大部分时候这样做是不安全的, 而且不利于管理, 所以flux架构在中间加了一层, 变为<br>action -&gt; dispatcher -&gt; store -&gt; view模式.这种模式即称为单向数据流, 任意邻近的2个节点之间<br>没有往返的数据流动.借助dispatcher我们可以实现状态快照, 状态时间旅行调试等高级调试功能.</p>
<p>flux架构就像眼镜, 你知道什么时候需要它. 意思即为当你的组件间状态开始变得复杂时, 一个好的<br>解耦架构可以带来轻松的管理体验.</p>
<h3 id="vuex-1"><a href="#vuex-1" class="headerlink" title="vuex"></a>vuex</h3><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>从基本的vuex计数器例子中可以看出:</p>
<ol>
<li>计数值使用计算属性显示,这样state变化时能进行响应.</li>
<li>点击按钮的方法不直接修改store.state, 而使用store.commit(‘methodName’),这样利用调试管理.</li>
<li>在中间层的store中定义state对象, mutation中定义操作方法, 直接写操作方法的定义时,<br>store.commit()中参数默认即方法名.简单方法可以使用nameA: x =&gt; x + x;这样的箭头函数定义.</li>
</ol>
<h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol>
<li>state<br>每个应用只应当维护一个store实例, 这样应用的每一刻状态都可以进行控制.<br>前面view响应store的变化最简单的方式就是通过计算属性, 但每个子组件都必须引入store实例, 比较<br>麻烦, 可以在根实例中注册store实例, 它会自动”注入”所有子组件, 子组件中不用引入,直接使用<br>this.$store.state.xxx即可.</li>
</ol>
<p>mapState:<br>上面的计数器例子中, 页面通过计算属性显示该state状态, 计算属性这样定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  count()&#123;</span><br><span class="line">    return this.$store.state.count;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当需要根据state生成多个用于显示的计算属性时(还可能加上组件自己的data属性), 这样做就会有很多<br>的重复.vuex提供了mapState函数, 可用于简化该计算属性的编写. 当只需要显示state属性并且计算属性<br>名和state属性名相同时, 可以直接在mapState函数中传递字符串数组, 这是最简洁的定义方式.</p>
<p>注: 当需要使用组件自身的this属性时, 只能使用普通函数定义, 箭头函数是不绑定this的.<br>注2: this其实就是call方法的第一个参数, 常规的方法调用如foo()其实是标准形式foo.call()的变体.<br>如调用foo.call(obj)时方法内的this指向的就是obj对象, 但箭头函数无法通过这种形式改变this指向.<br>也就是说调用foo.call(a,b)时如果foo是一个箭头函数, a参数会被忽略, 而b参数会被当作第一个参数<br>传入方法内进行处理.</p>
<p>使用mapState时, 可以发现它”霸占”了整个computed属性, 如果这时想要定义本地局部的计算属性时,<br>可以使用对象展开运算符<code>...</code>, 即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputedProperty: function()&#123;...&#125;,</span><br><span class="line">  ...mapState([&apos;xx&apos;, &apos;yy&apos;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注: 只有共享的状态才需要放入根实例store的state值中, 组件内部的状态还是应当放在组件内部.</p>
<ol start="2">
<li>getters<br>在组件增多时，如果多个组件对根store实例有一些共同的处理逻辑，我们完全可以将它们提取出来<br>放到store实例中进行定义，即store的getters属性。</li>
</ol>
<p>在store中定义好getters后，组件中可以使用this.$store.getters.xxx进行属性调用;<br>还可以给getters传递参数实现动态处理，如传递索引值查询store实例中数组对应索引的值。这时getters<br>属性返回的是一个函数，利用到了函数式编程中的高阶函数特性。</p>
<p>与mapState方法相同，为了组件中方便编写计算属性，计算属性中使用getter属性时，可以使用<br>mapGetters方法。</p>
<ol start="3">
<li>mutations<br>类似于flux架构的dispatcher.(但只是其一部分, 另一部分为下面的action)<br>在store中定义mutations相当于注册了事件，mutation方法名为事件类型type, 具体方法为事件的<br>回调函数。在组件中使用this.$store.commit(‘mutationType’).触发对应type的事件。</li>
</ol>
<p>mutation handler接受state作为第一个参数，我们自己需要传递的参数可以加在后面(payload).<br>对应的，组件中commit时第一个参数是事件类型type, 后面的参数可以写需要传递的payload参数，<br>还可以整体写为对象的形式， 即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&#123;</span><br><span class="line">  type: &apos;typeName&apos;,</span><br><span class="line">  payloadName: payloadValue</span><br><span class="line">&#125;)</span><br><span class="line">// 以下这种写法传递的payload是一个对象，store.mutations定义中接收时需要按对象处理</span><br><span class="line">this.$store.commit(&apos;typeName&apos;, &#123;</span><br><span class="line">  payloadName: payloadValue</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>注: 可以将mutationTypes统一提取为常量，方便管理。<br>mutation中定义的方法都必须是同步方法，因为mutation的设计作用是对状态进行快照处理, 如果<br>它本身的定义中使用了异步方法,将无法实现该作用.</p>
<ol start="4">
<li>action<br>对于异步操作方法, 我们应将其提取到action中, 在action中使用异步方法commit mutation, 组件中<br>不能直接操作mutation, 改为操作相应的action方法.</li>
</ol>
<p>action本身使用context代替store对象, 它有与store相同的方法和属性.即调用<br>context.commit(‘mutationType’)进行处理. 这时可以使用es6的参数解构写法省略context对象,<br>直接为commit(‘type’).</p>
<p>组件中使用this.$store.dispatch(‘actionType’).这里action带上参数payload的形式和mutation是<br>相同的.同样它也提供了mapActions辅助方法, 但个人认为, mapXXX可读性和实用性都不强, 不建议使用.</p>
<p>action方法之间同getters一样可以组合起来使用, 形成进一步更复杂的处理逻辑. 这是因为<br>store.dispatch(‘actionType’)返回的是promise, 根据promise的特性可以使用如<br>store.dispatch(‘actionA’).then(…)的方式调用下一个action.<br>如果想进一步控制promise的同步进行, 还可以将action定义为async方法,通过await关键字先行<br>完成调用另一个action.</p>
<ol start="5">
<li>module<br>对于复杂的应用, 一个根store记录所有的状态会导致state, mutations, getters, actions变得非常<br>臃肿, 这时可以将该store拆分为模块.每个模块都有自己的state, mutations等属性. 这些属性默认<br>是全局命名的,如果想区分开, 可以设置namespaces: true.<br>模块内部还可以访问rootState等全局属性.<br>如果想定义一个模块的多个实例, 可以像组件的data属性一样, 将其变为一个函数.<br>这种处理本质上就是用方法代替属性, 从而实现不同实例状态的分隔:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;place: &apos;default&apos;, data: &#123;place: &apos;china&apos;&#125;&#125;;</span><br><span class="line">变为</span><br><span class="line">const ob2 = &#123;place: &apos;default&apos;, data: function(place)&#123;return &#123;place: this.place&#125;&#125;&#125;;</span><br><span class="line">测试如下:</span><br><span class="line">const a = obj;</span><br><span class="line">const b = obj;</span><br><span class="line">b.data;</span><br><span class="line">a.data.place = &apos;usa&apos;;</span><br><span class="line">b.data;  // usa</span><br><span class="line"></span><br><span class="line">const c = ob2;</span><br><span class="line">const d = ob2;</span><br><span class="line">c.data(&apos;usa&apos;);  // default  this指向c对象</span><br><span class="line">c.data.call(&#123;place: &apos;usa&apos;&#125;) // usa 明确绑定this对象</span><br><span class="line"></span><br><span class="line">const ob3 = &#123;place: &apos;default&apos;, data: place =&gt; &#123;return &#123;place: this.place&#125;&#125;&#125;; //undefined</span><br><span class="line">// 箭头函数不能作为方法定义 </span><br><span class="line">// 这个例子中应避免使用this指针, 组件中的this指向当前组件实例</span><br><span class="line">const ob3 = &#123;data: function(pl)&#123;return &#123;place: pl&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>略</p>
<h4 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h4><p>略</p>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>如果发生了除mutation函数以外的状态变更将会报错, 这样利于调试.<br>但只应当在开发环境下开启.</p>
<h4 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h4><p>当同时使用store的strict mode和v-model时, 如果v-model绑定的是store.state中的属性, 由于<br>v-model不是通过mutation改变的状态, 所以会报错.这时有2种办法:</p>
<ol>
<li><code>:value=&#39;x&#39; @input=&#39;updateX&#39;</code>, 这比简单的使用组件局部状态data要麻烦, 不推荐使用.</li>
<li>使用计算属性的get, set方法双向绑定. 经测试, 这样做虽然很简洁, 但是计算属性值每次变化<br>都会触发mutation方法, 无法控制. vue教程中使用watch通过lodash通过停止操作的时间进行控制.<br>实用性不强. 所以,还是应当使用组件局部状态data.</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>略</p>
<h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><ol>
<li>npm i -D eslint eslint-plugin-vue</li>
<li><p>根目录下新建.eslintrc.js文件, 写入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  extends: [</span><br><span class="line">    &quot;plugin:vue/essential&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改package.json文件,加入eslint命令<code>eslint --ext .js,.vue src</code>.</p>
</li>
</ol>
<h2 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h2><p>略</p>
<h2 id="element-ui-theme"><a href="#element-ui-theme" class="headerlink" title="element-ui theme"></a>element-ui theme</h2><ol>
<li>webpack中需要引入对字体文件的处理.</li>
<li>全局引入element-ui. main.js中写入以下3行即可.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &apos;element-ui&apos;;</span><br><span class="line">import &apos;element-ui/lib/theme-chalk/index.css&apos;;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="java-vue-Element-前后端分离独立项目-图形验证码的坑"><a href="#java-vue-Element-前后端分离独立项目-图形验证码的坑" class="headerlink" title="java + vue Element 前后端分离独立项目 图形验证码的坑"></a>java + vue Element 前后端分离独立项目 图形验证码的坑</h2><p>use java to generate image (java awt) is easy, save the image text to session and return<br>the image to frontend, frontend directly use src = interface to show the image is also<br>straight-forward, then frontend use post method to request the server to login or add data,<br>now the server needs to check the code, it needs to get the image text from session to<br>compare it with post data text. And now comes the bug. </p>
<p>the front and backend separated projects’ session is different with the old one, even use<br>get method to get image, the jsessionid is different. After one day’s searching and testing,<br>I finally fixed the bug:</p>
<ol>
<li><p>do not use localhost with frontend service to test, as it will trigger cors problem,<br>the request will generate different session.</p>
</li>
<li><p>with front and backend separated projects, we need config axios withCredentials = true,<br>in this way, the request head will contain cookie,and cookie actually saves sessionid,<br>so we can get our image generated session and get the text there!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">var service = axios.create(&#123;</span><br><span class="line">      baseURL: &apos;http://xxx:xxx:xxx:xxx:8200/resCenter&apos;, // api的base_url</span><br><span class="line">      // timeout: 5000 // 请求超时时间</span><br><span class="line">      withCredentials: true</span><br><span class="line">&#125;)</span><br><span class="line">export default service</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20191119_1.jpg" class="full-image"></p>

      
    </div>

    
      


    

    
    
    

    

    
      
    
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById(&quot;QR&quot;); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/wechat.jpg" alt="吴涛涛 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/alipay.jpg" alt="吴涛涛 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        



  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>吴涛涛</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="http://www.taoblog.cn/post/999fed8a/" title="VueNote">http://www.taoblog.cn/post/999fed8a/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Vue/" rel="tag"><i class="fa fa-tag"></i> Vue</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
            <div id="wpac-rating"></div>
          </div>
        

        

        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/ddfb64ab/" rel="next" title="VimNote">
                <i class="fa fa-chevron-left"></i> VimNote
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/b53499ee/" rel="prev" title="DockerNote">
                DockerNote <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <a href="/">
              <img class="site-author-image" itemprop="image" src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/maya.jpg" alt="吴涛涛">
                </a>
            
              <p class="site-author-name" itemprop="name">吴涛涛</p>
              <p class="site-description motion-element" itemprop="description">wutaotao personal blog</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/wutaotao2015" title="GitHub &rarr; https://github.com/wutaotao2015" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://hexo.io/zh-cn/docs/" title="https://hexo.io/zh-cn/docs/" rel="noopener" target="_blank">Hexo</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://theme-next.iissnan.com/getting-started.html" title="http://theme-next.iissnan.com/getting-started.html" rel="noopener" target="_blank">Next</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.lingblog.net/" title="http://www.lingblog.net/" rel="noopener" target="_blank">cllBlog</a>
                  </li>
                
              </ul>
            
            </div>
          

          
          
          <div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("01/18/2019 23:48:05");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="blog has been running<br/>"
+daysold+" d "+hrsold+" h "+minsold+" m "+seconds+" s";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#官网教程"><span class="nav-number">1.</span> <span class="nav-text">官网教程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装"><span class="nav-number">1.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明式渲染，条件与循环等"><span class="nav-number">1.2.</span> <span class="nav-text">声明式渲染，条件与循环等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue实例"><span class="nav-number">1.3.</span> <span class="nav-text">Vue实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板语法"><span class="nav-number">1.4.</span> <span class="nav-text">模板语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插值"><span class="nav-number">1.4.1.</span> <span class="nav-text">插值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令"><span class="nav-number">1.4.2.</span> <span class="nav-text">指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缩写"><span class="nav-number">1.4.3.</span> <span class="nav-text">缩写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算属性和侦听器"><span class="nav-number">1.5.</span> <span class="nav-text">计算属性和侦听器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算属性"><span class="nav-number">1.5.1.</span> <span class="nav-text">计算属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class与style绑定"><span class="nav-number">1.6.</span> <span class="nav-text">class与style绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件渲染"><span class="nav-number">1.7.</span> <span class="nav-text">条件渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表渲染"><span class="nav-number">1.8.</span> <span class="nav-text">列表渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件处理"><span class="nav-number">1.9.</span> <span class="nav-text">事件处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表单输入绑定"><span class="nav-number">1.10.</span> <span class="nav-text">表单输入绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础用法"><span class="nav-number">1.10.1.</span> <span class="nav-text">基础用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#值绑定"><span class="nav-number">1.10.2.</span> <span class="nav-text">值绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修饰符"><span class="nav-number">1.10.3.</span> <span class="nav-text">修饰符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件基础"><span class="nav-number">1.11.</span> <span class="nav-text">组件基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#组件data必须是一个函数"><span class="nav-number">1.11.1.</span> <span class="nav-text">组件data必须是一个函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组件的组织"><span class="nav-number">1.11.2.</span> <span class="nav-text">组件的组织</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过prop向子组件传递数据"><span class="nav-number">1.11.3.</span> <span class="nav-text">通过prop向子组件传递数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单个根元素"><span class="nav-number">1.11.4.</span> <span class="nav-text">单个根元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监听子组件事件"><span class="nav-number">1.11.5.</span> <span class="nav-text">监听子组件事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组件上使用v-model"><span class="nav-number">1.11.6.</span> <span class="nav-text">组件上使用v-model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过插槽分发内容"><span class="nav-number">1.11.7.</span> <span class="nav-text">通过插槽分发内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态组件"><span class="nav-number">1.11.8.</span> <span class="nav-text">动态组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析DOM模板需要注意内容"><span class="nav-number">1.11.9.</span> <span class="nav-text">解析DOM模板需要注意内容</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入了解组件"><span class="nav-number">1.12.</span> <span class="nav-text">深入了解组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组件注册"><span class="nav-number">1.13.</span> <span class="nav-text">组件注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#组件名"><span class="nav-number">1.13.1.</span> <span class="nav-text">组件名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全局注册"><span class="nav-number">1.13.2.</span> <span class="nav-text">全局注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部注册"><span class="nav-number">1.13.3.</span> <span class="nav-text">局部注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块系统"><span class="nav-number">1.13.4.</span> <span class="nav-text">模块系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prop"><span class="nav-number">1.14.</span> <span class="nav-text">Prop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#prop的大小写"><span class="nav-number">1.14.1.</span> <span class="nav-text">prop的大小写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prop类型"><span class="nav-number">1.14.2.</span> <span class="nav-text">prop类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传递静态或动态prop"><span class="nav-number">1.14.3.</span> <span class="nav-text">传递静态或动态prop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单向数据流"><span class="nav-number">1.14.4.</span> <span class="nav-text">单向数据流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prop验证"><span class="nav-number">1.14.5.</span> <span class="nav-text">prop验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非prop的特性"><span class="nav-number">1.14.6.</span> <span class="nav-text">非prop的特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义事件"><span class="nav-number">1.15.</span> <span class="nav-text">自定义事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插槽"><span class="nav-number">1.16.</span> <span class="nav-text">插槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态组件-amp-异步组件"><span class="nav-number">1.17.</span> <span class="nav-text">动态组件&amp;异步组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理边界情况"><span class="nav-number">1.18.</span> <span class="nav-text">处理边界情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过渡-amp-动画"><span class="nav-number">1.19.</span> <span class="nav-text">过渡&amp;动画</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进入-离开-amp-列表过渡"><span class="nav-number">1.20.</span> <span class="nav-text">进入/离开&amp;列表过渡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态过渡"><span class="nav-number">1.21.</span> <span class="nav-text">状态过渡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可复用性-amp-组合"><span class="nav-number">1.22.</span> <span class="nav-text">可复用性&amp;组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混入"><span class="nav-number">1.23.</span> <span class="nav-text">混入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义指令"><span class="nav-number">1.24.</span> <span class="nav-text">自定义指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染函数-amp-JSX"><span class="nav-number">1.25.</span> <span class="nav-text">渲染函数&amp;JSX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插件"><span class="nav-number">1.26.</span> <span class="nav-text">插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤器"><span class="nav-number">1.27.</span> <span class="nav-text">过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工具"><span class="nav-number">1.28.</span> <span class="nav-text">工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单文件组件"><span class="nav-number">1.29.</span> <span class="nav-text">单文件组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单元测试"><span class="nav-number">1.30.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TypeScript支持"><span class="nav-number">1.31.</span> <span class="nav-text">TypeScript支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产环境部署"><span class="nav-number">1.32.</span> <span class="nav-text">生产环境部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规模化"><span class="nav-number">1.33.</span> <span class="nav-text">规模化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由"><span class="nav-number">1.34.</span> <span class="nav-text">路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态管理"><span class="nav-number">1.35.</span> <span class="nav-text">状态管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务端渲染"><span class="nav-number">1.36.</span> <span class="nav-text">服务端渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内在"><span class="nav-number">1.37.</span> <span class="nav-text">内在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入响应式原理"><span class="nav-number">1.38.</span> <span class="nav-text">深入响应式原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springboot整合vue"><span class="nav-number">2.</span> <span class="nav-text">springboot整合vue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack-4-41-2使用"><span class="nav-number">3.</span> <span class="nav-text">webpack 4.41.2使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指南"><span class="nav-number">3.2.</span> <span class="nav-text">指南</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#起步"><span class="nav-number">3.2.1.</span> <span class="nav-text">起步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管理资源"><span class="nav-number">3.2.2.</span> <span class="nav-text">管理资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管理输出"><span class="nav-number">3.2.3.</span> <span class="nav-text">管理输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开发"><span class="nav-number">3.2.4.</span> <span class="nav-text">开发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HMR-hot-module-replacement"><span class="nav-number">3.2.5.</span> <span class="nav-text">HMR hot module replacement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tree-shaking"><span class="nav-number">3.2.6.</span> <span class="nav-text">tree shaking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生产环境配置"><span class="nav-number">3.2.7.</span> <span class="nav-text">生产环境配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码分离"><span class="nav-number">3.2.8.</span> <span class="nav-text">代码分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#懒加载"><span class="nav-number">3.2.9.</span> <span class="nav-text">懒加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存"><span class="nav-number">3.2.10.</span> <span class="nav-text">缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack4-整合vue"><span class="nav-number">4.</span> <span class="nav-text">webpack4 整合vue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#起步-1"><span class="nav-number">4.1.</span> <span class="nav-text">起步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理资源路径"><span class="nav-number">4.2.</span> <span class="nav-text">处理资源路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用预处理器"><span class="nav-number">4.3.</span> <span class="nav-text">使用预处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Sass"><span class="nav-number">4.3.1.</span> <span class="nav-text">Sass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#postcss"><span class="nav-number">4.3.2.</span> <span class="nav-text">postcss</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#babel"><span class="nav-number">4.3.3.</span> <span class="nav-text">babel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typescript"><span class="nav-number">4.3.4.</span> <span class="nav-text">typescript</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pug"><span class="nav-number">4.3.5.</span> <span class="nav-text">pug</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scoped-css"><span class="nav-number">4.3.6.</span> <span class="nav-text">scoped css</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#css-modules"><span class="nav-number">4.3.7.</span> <span class="nav-text">css modules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#热重载"><span class="nav-number">4.3.8.</span> <span class="nav-text">热重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数式组件"><span class="nav-number">4.3.9.</span> <span class="nav-text">函数式组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义块"><span class="nav-number">4.3.10.</span> <span class="nav-text">自定义块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#css提取"><span class="nav-number">4.3.11.</span> <span class="nav-text">css提取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">4.3.12.</span> <span class="nav-text"> </span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引入依赖的路径和省略后缀符问题"><span class="nav-number">5.1.</span> <span class="nav-text">引入依赖的路径和省略后缀符问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图片拷贝问题"><span class="nav-number">5.2.</span> <span class="nav-text">图片拷贝问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue-router"><span class="nav-number">6.</span> <span class="nav-text">vue-router</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#起步-2"><span class="nav-number">6.1.</span> <span class="nav-text">起步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态路由匹配"><span class="nav-number">6.2.</span> <span class="nav-text">动态路由匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套路由"><span class="nav-number">6.3.</span> <span class="nav-text">嵌套路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编程式的导航"><span class="nav-number">6.4.</span> <span class="nav-text">编程式的导航</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名路由"><span class="nav-number">6.5.</span> <span class="nav-text">命名路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名视图"><span class="nav-number">6.6.</span> <span class="nav-text">命名视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重定向和别名"><span class="nav-number">6.7.</span> <span class="nav-text">重定向和别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由组件传参"><span class="nav-number">6.8.</span> <span class="nav-text">路由组件传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#html5-history模式"><span class="nav-number">6.9.</span> <span class="nav-text">html5 history模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vuex"><span class="nav-number">7.</span> <span class="nav-text">vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单store模式-without-vuex"><span class="nav-number">7.1.</span> <span class="nav-text">简单store模式 without vuex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vuex-1"><span class="nav-number">7.2.</span> <span class="nav-text">vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#开始"><span class="nav-number">7.2.1.</span> <span class="nav-text">开始</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#核心概念"><span class="nav-number">7.2.2.</span> <span class="nav-text">核心概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#项目结构"><span class="nav-number">7.2.3.</span> <span class="nav-text">项目结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插件-1"><span class="nav-number">7.2.4.</span> <span class="nav-text">插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#严格模式"><span class="nav-number">7.2.5.</span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表单处理"><span class="nav-number">7.2.6.</span> <span class="nav-text">表单处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试"><span class="nav-number">7.2.7.</span> <span class="nav-text">测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eslint"><span class="nav-number">8.</span> <span class="nav-text">eslint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单元测试-1"><span class="nav-number">9.</span> <span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#element-ui-theme"><span class="nav-number">10.</span> <span class="nav-text">element-ui theme</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-vue-Element-前后端分离独立项目-图形验证码的坑"><span class="nav-number">11.</span> <span class="nav-text">java + vue Element 前后端分离独立项目 图形验证码的坑</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴涛涛</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">508k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">7:42</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.0.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>







  




















  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script>

  
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  
  

  

<script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script>



  

<script src="//cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '48ERsGJLrCK2gEVvR9razFEe-MdYXbMMI',
    appKey: 'mETL0o4bfizck0MCVvPOqv88',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>




  


  



  
  
  
    
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">

  
  
    
  
  <script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.js"></script>
  

  <script src="/js/src/algolia-search.js?v=7.0.0"></script>



  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log(`Failed to save Visitor num, with error message: ${responseJSON.error}`);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log(`LeanCloud Counter Error: ${responseJSON.code} ${responseJSON.error}`);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'NCCFA0S02dv1PFmmODBJeCQO-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'NCCFA0S02dv1PFmmODBJeCQO-gzGzoHsz',
                'X-LC-Key': 'bAOsL8XKUXH3zST74CQcodSm',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  
  <script>
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id: 16361,
      el: 'wpac-rating',
      color: 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  </script>


  
  
  
    
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/pangu/3.3.0/pangu.min.js"></script>
  <script>pangu.spacingPage();</script>


  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


<script>!function(o){var i=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function c(t,e){var n=new Image,o=t.getAttribute("data-original");n.onload=function(){t.src=o,e&&e()},n.src=o}function n(){for(var t=0;t<i.length;t++)e=i[t],void 0,0<=(n=e.getBoundingClientRect()).top&&0<=n.left&&n.top<=(o.innerHeight||document.documentElement.clientHeight)&&c(i[t],function(){i.splice(t,t)});var e,n;console.log("trigger")}n(),o.addEventListener("scroll",function(){var t,e;t=n,e=o,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>
