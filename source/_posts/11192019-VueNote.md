---
title: VueNote
categories: Vue
tags:
  - Vue
abbrlink: 999fed8a
updated: 2021-03-18 18:21:42
date: 2019-11-19 17:23:01
---
note on learning Vue
<!-- more -->
## 官网教程

### 安装
直接下载vue.js并在html中引用即可。这里使用的vue版本为2.6.10.

### 声明式渲染，条件与循环等
数据可以绑定到DOM文本:如文本插值`{ { message }}`, 
DOM属性: 如直接在html标签中使用指令v-bind:title="eleTitle"改变鼠标悬停效果,
DOM结构: 如使用指令v-if="seen"控制是否显示标签(控制结构时还可以提供fade in, out等其他动画效果)

v-for="item in itemList"在li标签中的应用。
v-on:click="afterClick"绑定点击事件为afterClick方法。
v-model="message"为双向数据绑定。

可以通过如下方式自定义组件:
```txt
Vue.component('todo', {
  props: ['prop1', 'prop2'],
  template: '<li>{ { prop1.text }}</li>'
});

var ele = new Vue({
 el: '#ap5',
 data: {
   list: [
    {id: 0, text: 'one'},
    {id: 1, text: 'two'},
    {id: 2, text: 'three'}
   ]  
 }
});
```
自定义组件，使用时如
```txt
<div id='ap5'>
  <todo v-for="item in list" v-bind:prop1="item" v-bind:key="item.id"/>
</div>
```
可以看到，自定义组件todo使用组件属性prop使得组件动态显示外界传递的数据内容。这与上面的
v-bind:title="message"是一样的。

### Vue实例
在vue中，一个组件实际上是一个预定义的Vue实例。每个Vue实例可以接受多个选项。
1. 数据选项 data
当实例创建时，data选项中已经存在的属性会被加入到vue的响应式系统中，如
```txt
var dataSource = {text: 1};
var vm = new Vue({
  data: dataSource 
});
```
这时无论改变vm.text还是改变dataSource.text的值，另一个的值都会同步发生改变，即实现了数据
和视图的双向响应式变化。如果在vm实例创建后，对dataSource添加新属性是无法实现响应式变化的。

注: Object.freeze(dataSource)会阻止修改对象属性值。

实例属性和方法都有前缀$, 如vm.$el, vm.$data等。

实例提供了多个生命周期钩子，如created, mounted, updated, destroyed等，可以在选项中自定义
回调方法执行自定义操作。钩子的this关键字指向vue实例，避免使用箭头函数。

教程中给出了vue实例的整个生命周期流程，可以看到以下几点：
1. 如果没有指定el选项，可以使用vm.$mount(el)方法指定元素。
2. 选项中如果有指定template模板，使用该模板进行渲染，否则就使用el的html标签进行渲染。这一点
也区分开了自定义组件和普通的html标签。
3. vue使用vm.$el替换原生的el标签实现虚拟DOM, 在此基础上实现响应式渲染。 

### 模板语法
#### 插值
1. 文本
双大括号为mustache语法，`{ { message }}`, 数据选项属性message发生变化，该文本值也会变化。
可以使用`<p v-once>{ { message }}</p>`来实现一次性渲染.

注: 类似document.getElementById().innerText = XXX;

2. html标签
```txt
<div id='ap6'>
  <p><span v-html="sp"/></p>
</div>

var ap6 = new Vue({
  el: '#ap6',
  data: {
    sp: '<a style='color: red'>I am red</a>'
  }
})
```
对用户输入的内容使用html插值容易导致XSS攻击，应只对可信内容使用。

注: 类似`document.getElementById().innerHTML = "<x>...</x>";`

3. 属性 
同上面所说，标签属性的改变使用v-bind指令，如v-bind:disabled="disableFlag"等, 其中disableFlag
必须为boolean值。

4. 模板表达式
如`{ { num + 1}}`, `{ { ok ? 'yes' : 'no' }}`都会被当作js表达式解析，其中num作为v-model双向绑定时
是字符串类型，`{ {num+1}}`得到的是字符串的拼接。
模板表达式的解析是在沙盒中，只能访问如Math,Date等白名单对象，无法访问用户自定义全局变量，
访问时会报错该属性未定义。

#### 指令
指令一般是作用于单个表达式，如v-on:click='reverse', v-if='seen'等。
1. 参数 
即指令名称冒号后的值，如v-bind:href='url', v-on:click='reverse'中href, click都是参数，
等号后是参数值。

2. 动态参数
如v-on:[event]='dosth', 其中event可以为一个js表达式，如实例中有一个数据属性为event,值为
focus, 那么它就等价为v-on:focus='dosth'.通过这种形式，该标签就可以在不同时间以聚焦或点击
的不同动作调用相同的方法。(这种需求还是比较少见, 其他指令的参数动态性可能有点用)
动态表达式中不能有空格和引号，大写字母会被强制转换为小写。

3. 修饰符
如v-on:submit.prevent='sub'中参数submit后的.prevent指出该指令以特殊方式绑定，即调用
event.preventDefault()语句。

#### 缩写
v-bind:href='url'可以缩写为:href='url',
v-on:click='dosth'可以缩写为@click='dosth'.

### 计算属性和侦听器
#### 计算属性
在模板表达式中写比较复杂的算式可读性不好，而且不方便复用。这时可以使用计算属性。如:
```txt
<p>{ { reverseTxt }}</p>

var ap7 = new Vue({
  el: '#ap7',
  data: {
    txt: 'sdg'  
  },
  computed: {
    reverseTxt: function() {
      return this.txt.split('').reverse().join('');  
    }
  }
});
```
计算属性与方法的不同在于计算属性自带缓存，当this.txt没有发生改变时，不会重新计算直接返回
缓存值。
计算属性与侦听器的不同在于计算属性可以同时监控多个属性的变化，而侦听器只能针对单个属性的变化
分别定义函数。
计算属性默认是get方法，即计算结果值由"监测"的属性计算得到，但也可以通过设置计算属性值反过来
设置监测的属性值。通过这种联动可以实现实例中属性的双向影响，感觉在某些场景中这种相互影响非常
实用。代码如:
```txt
computed: {
 reverseTxt: {
   get: function() {
      return this.txt.split('').reverse().join('');  
   },
   set: function(val) {
      this.txt = val.split('').reverse().join('');  
   }
 } 
}
```

侦听器在属性值发生变化时可以调用相应的函数，如发出ajax异步请求等。为防止请求过于频繁，教程中
使用lodash的debounce方法限制请求间隔，使用axios发出ajax请求。

### class与style绑定
v-bind指令在设置标签的样式如class, style属性时除了字符串，还可以绑定一个对象或数组。
1. class
传递对象:
如`<p v-bind:class="{real: isReal, active: isActive}"></p>`,这个绑定的对象
除了可以在这里直接定义，还可以定义在实例的data选项属性中，或是计算属性中(更强大的控制)。

其中，对象的属性名是具体的class名称，属性值是该class是否生效的boolean值。为truthy时该class
生效，为false时该class不生效。
注: **js中除false, 0, "", null, undefined, NaN以外，都是真值，即为truthy.**

实例中定义为`data: {isReal: true, isActive: false}`.

注: v-bind:class可以和普通的class属性共存。

传递数组:
比起使用boolean值控制class列表的对象语法，数组语法通过class列表的字符串数组进行控制，
如`v-bind:class="[aClass, bClass]"`，同理，为实现控制，这里的aClass,bClass是实例的属性名，
实例中有`data: {aClass: 'a', bClass: 'b'}`, a和b即为具体的class名称。当需要去除某个class时，
将对应属性值设置为''即可。如果需要动态控制，可以在数组语法中嵌套使用对象语法，
如`v-bind:class='[{aClass: aflag}, bClass]`.

用在组件上:
在自定义组件中通过以上2种方式带数据绑定的class会追加到组件的根元素中，不会覆盖已有的class列表。 

2. style
通过style绑定的是内联样式，直接指定样式，不需要中间的class层，适合样式少并分散的情况。

对象语法:
如`v-bind:style="{color: acolor, fontSize: fs + 'px'}"`, 实例中定义
`data: {acolor: 'red', fs: 30}`, 
同样的，可以将该对象定义在实例data中，或使用计算属性。
如`v-bind:style="sty"`, `data: {sty: {color: 'red', fontSize: '30px'}}`.

数组语法:
style的数组语法可以使用多个style对象进行控制，这里使用对象语法一个style对象即可以控制，
所以数组语法意义不大，就此略过。

自动添加前缀: 对于非标准的浏览器引擎CSS前缀，v-bind:style会自动添加前缀，可忽略。
多重值: style样式属性值除字符串外，还可以传递数组，vue会选择数组中最后一个支持的浏览器样式，
可忽略。

### 条件渲染
1. v-if
在单个标签中使用v-if="seen", 当seen为false时，刷新后该标签一闪而过后消失。应该是渲染的执行
顺序问题。当需要控制隐藏多个标签时，使用template标签并在其中使用v-if指令，发现没有出现闪烁
现象。

v-if后可以使用v-else-if，v-else指令块控制多个元素的显式隐藏。要求必须相应的元素必须紧靠在
一起，否则无法识别。

当使用v-if切换2个template元素组时，vue会复用已经有的元素，这样在切换时会出现元素中已有的
值(如用户的输入值)不会被清空的情况。这时可以给这2个template中相同的元素设置key属性，相当于
指定了id, 通过设置不同的key值，vue就不会复用该元素。而未指定key时，vue将复用相同元素提高
渲染速度。

2. v-show
v-show指令值为false时相当于style='display:none"，所以v-show元素始终存在于dom中。

注: v-if是真正的条件渲染，而且是惰性的(只有第一次为真时才开始渲染)，切换开销较大；而v-show
始终会渲染，初始开销大，但切换时只是CSS变换，切换开销小。
所以如果频繁切换应使用v-show, 切换较少时使用v-if.

注: 不应当在同一个元素内同时使用v-if和v-for指令，因为v-for指令优先级更高，这样当只需要渲染
其中一小部分元素时，却遍历了整个列表进行判断。这时应当使用计算属性过滤出需要的列表，对其
使用v-for指令渲染，这样更高效，而且将筛选逻辑解耦出来了(而且计算属性还自带缓存，可以复用)。

### 列表渲染
1. 渲染列表
v-for指令在li标签上使用可以渲染一个列表。
```txt
<li v-for="item in items">{ { item.txt }}</li>
data: {
  items: [
    {txt: "one"},
    {txt: "two"},
  ]
}
```
v-for还可以写为`v-for="(item, index) in items"`, index为自动添加的索引。
还可以使用of代替in, 如`v-for="(item, index) of items"`。

2. v-for中使用对象
如
```txt
<li v-for="value in obj">{ {value}}</li>
data: {
  obj: {
    title: 'tt',
    name: 'ss'
  } 
}
```
同时显示对象属性名和值:
```txt
<li v-for="(value, name) in obj">{ {name}}: { {value}}</li>
或
<li v-for="(value, name, index) in obj">{ {index}}:{ {name}}: { {value}}</li>
```
注: 模板表达式只能识别单个属性，`{ {name: value}}`会报错。
遍历顺序为Object.keys()结果。

3. 维护状态
同前面v-if的元素复用类似，v-for指令在未指定key时使用默认的"就地更新"策略，即不会主动更改
dom元素位置，而是更新每个元素值。这种模式很高效，但它只适用于输出的DOM非常简单的情况。
一般建议是在使用v-for指令时，同时使用v-bind:key="item.id"值为每一个列表项指定id.
使用key后，会强制更新元素或组件而不是重复利用已有元素，适用于触发过渡效果。

4. 数组更新检测
当v-for的数组内容发生变化时，对应的列表也会发生变化，数组变化的方法有
push, pop, shift, unshift, splice, sort, reverse.这些方法会改变原数组，而其他另外一些方法
如filter, concat, slice等没有改变原数组，这时如果想要重新渲染列表，可以使用计算属性，
在其中将得到的新数组替换原属性即可(vue会尽量复用已有DOM, 不会马上销毁原有DOM重新渲染)。

注: 直接使用索引修改元素值如a[i] = 3和a.length = 3无法实现响应式更新。对于前者可以使用
Vue.set(vm.items, index, newValue)或vm.items.splice(index, 1, newValue),
对于后者可以使用vm.items.splice(newlength).

splice意思是拼接，splice(startIndex, deleteCount, item1, item2...)意为从startIndex(包括)开始删除
deleteCount个字符，并在相同位置插入元素item1, item2..., 该方法改变了原数组，方法的返回值是
被删除的元素数组。

5. 对象变更检测
前面说过，对于已经初始化完成的vue实例，后面再添加属性值是不支持响应式更新的。(即时支持
好像也没有实际作用)。但可以对属性对象进行修改。
如果添加单个属性可以使用`Vue.set(vm.obj, 'name', 29)`添加或修改属性，如果要添加多个时，
可以使用`vm.obj = Object.assign({}, vm.obj, {'name':29, 'sex': 'm'});`
这里新建一个vm.obj对象而不是直接`Object.assign(vm.obj, {...})`的原因经网上搜索，说如果直接
修改vm对象，可能会导致基于vm的元素出现渲染问题，所以还是使用新对象较好。而且使用{}当vm.obj
对象为undefined时不会报错。即assign的源对象可以为undefined. 

注: Object.assign()复制的是属性值，为浅拷贝，如果需要深拷贝，可以json序列化后再解析，即
let copy = JSON.parse(JSON.stringify(source));

6. 显示过滤/排序后的结果
前面已经说过，需要过滤时应使用计算属性或方法对数组处理后再使用v-for指令渲染(直接使用v-if
性能低，耦合度高)。在使用v-for循环嵌套时，列表不是data属性(是数据内部的次级列表)，无法直接
访问所以不能使用计算属性，只能使用方法来处理。

7. v-for使用值范围
`<p v-for="n in 10">{ {n}}</p>`输出12345678910

8. template上使用v-for
对于一组需要多次重复的元素组，可以在template上使用v-for. 具体需求如表格。
```txt
<div id="b4">
      <table>
              <template v-for="row in rows">
                      <tr>
                              <td>{ {row.a}}</td>
                              <td>{ {row.b}}</td>
                      </tr>
              </template>
      </table>
</div>
var b4 = new Vue({
      el: '#b4',
      data: {
              rows: [
                      {a: '11', b: '12'},
                      {a: '21', b: '22'}
              ]
      }
});
```
9. 组件上使用v-for
前面说过，组件中应使用key区分每个列表内元素保证渲染正确。同时组件有自己的作用域，需要使用
prop来传递数据。
```txt
<ul>
  <li is="myComponent" 
  v-for="(item,index) in list" 
  :key = "item.id"
  :content = "item.text"
  @remove="list.splice(index, 1)"
  />
</ul>
```
其中is="myComponent"是因为html限制ul中只有li是有效标签，要在其中使用自定义元素myComponent
时，需要通过is进行标记。key为item.id, 组件props属性(数组)为`['content']`(即li标签显示内容),
赋值为item.text.最后是点击按钮触发remove事件时将数组中该项去除，这样会同步响应到视图中。

### 事件处理
1. 内联语句
如v-on:click="count += 1"可以让属性count自增1
2. 绑定到方法
使用如v-on:click="afterClicked"将动作绑定到实例方法，处理逻辑都在方法中定义。
3. 内联语句中调用方法
如v-on:click="say('oneClick')", 在内联语句中调用方法。此时可以用$event向方法中传入原生
DOM事件，如v-on:click="say('oneClick', $event)".
4. 事件修饰符
某些情况需要阻止事件的默认行为，如form表单提交的默认重载页面行为，一般是使用
event.preventDefault(), vue提供了修饰符简化该操作，如
```txt
.stop 阻止事件继续传播 
.prevent 阻止事件默认行为
.capture 捕获内部元素事件，捕获处理完毕后再交还子元素
.self 只处理自身的事件，内部元素触发的事件不进入该处理
.once 该事件方法只会被调用一次
.passive 告诉浏览器执行事件的默认行为(正好与.prevent相反), 
         与.prevent一起使用时.prevent会被忽略
```
5. 按键修饰符
监听键盘事件时，可以指定按键。
如v-on:keyup.enter="submit"回车键调用submit方法，
v-on:keyup.page-down="onPageDown"按下pageDown键时调用onPageDown方法。
键名可以使用KeyboardEvent.key得到。
可以通过以下方式获取:
```txt
 <div id="b5">
      <input @keyup="go($event)"/>
</div>

var b5 = new Vue({
      el: '#b5',
      methods: {
              go: function (e) {
                      console.log(e.key);
              }
      }
});
```
注：按键码keycode用法已经被废弃，应避免使用

6. 系统修饰键
键盘修饰键只有在按下时才能触发，有
```txt
.ctrl
.alt
.shift
.meta
```
如alt+c触发clear方法: `<input @keyup.alt.c="clear">`，
完整代码如下:
```txt
<div id="b5">
    <input @keyup.alt.c="clear" v-model="mess"/>
</div>
var b5 = new Vue({
      el: '#b5',
      data: {
              mess: ''
      },
      methods: {
              clear: function () {
                      this.mess = '';
              }
      }
});
```
上面的`@keyup.alt.c="clear"`当alt和其他的修饰键如ctrl, shift等一起按下时也会调用，使用
.exact修饰符可以控制只有alt被按下时才会调用clear方法,代码为`@keyup.alt.exact.c="clear"`.

7. 鼠标按钮修饰符
.left .right .middle

### 表单输入绑定

#### 基础用法
v-model实际是语法糖，它监听用户的输入事件并更新数据。
v-model适用于input, textarea, checkbox, radio, select元素。

text, textarea, select根据value属性的变化触发input事件。
checkbox, radio根据checked属性的变化触发change事件。

v-model绑定的值为元素值。如`<input type='checkbox' value='one' v-model='arr'>`中，复选框
选中时arr数组中有值one, 未勾选时无值one. 代码如下:
```txt
<div id="b6">
      <input type="checkbox" value="one" v-model="arr"/><label>one</label>
      <input type="checkbox" value="two" v-model="arr"/><label>two</label>
      <p>{ {arr}}</p>
</div>

var b6 = new Vue({
      el: '#b6',
      data: {
              arr: []
      }
});
```
使用`<textarea>{ {mess}}</textarea>`无法实现双向绑定，只有初始时可以成功渲染mess值，用户
在输入文本后，mess值并不会相应的变化，若要实现双向绑定必须使用`<textarea v-model='mess'/>`.

select下拉框:
```txt
<div id="b7">
      <select v-model="sel">
              <option disabled value="">please select</option>
              <option>A</option>
              <option>B</option>
              <option>C</option>
      </select>
      <p>{ {sel}}</p>
</div>

var b7 = new Vue({
      el: '#b7',
      data: {
              sel: ''
      }
});
```
多选下拉框除绑定到一个数组外，标签使用multiple标记为可多选，具体选择时按住ctrl键可多选
`<select v-model='selected' multiple>...</select>`

#### 值绑定
以上使用v-model时单选框，复选框，下拉框的值都是静态的，为字符串(复选框可以为boolean值)。
实际使用时如下拉框，选中的选项需要绑定到一个对象，这时简单的绑定方式`<option>A</option>`
(该选项值为A)就不能满足需求，这时可以进一步对选项的值进行绑定，即值绑定。

即`<option v-bind:value="{name: 'zs', age: 20}"`.这样通过v-bind指令对value属性进一步绑定
即可满足要求。

如下代码展示了下拉框联动后获取子下拉框选择的具体对象信息:
```txt
<div id="b8">
      <select v-model="parent" @change="changeList">
              <option disabled value="">please select one</option>
              <option>a</option>
              <option>b</option>
      </select>
      <select v-model="child">
              <option disabled value="">please select one</option>
              <option v-for="item in list" :key="item.id" :value="item">{ { item.name }}</option>
      </select>
      <p>id: { {child.id}}</p>
      <p>name: { {child.name}}</p>
      <p>age: { {child.age}}</p>
</div>

var b8 = new Vue({
      el: '#b8',
      data: {
              parent: '',
              child: {},
              list: []
      },
      methods: {
            changeList: function () {
                  if (this.parent == 'a') {
                          this.list = [
                                  {id: 1, name: 'a1', age: 11},
                                  {id: 2, name: 'a2', age: 22}];
                  }else{
                          this.list = [
                                  {id: 3, name: 'b1', age: 33},
                                  {id: 4, name: 'b2', age: 44}];
                  }
            }
      }
});
```
可以注意到，要获取子下拉框选择的对象信息，直接绑定`:value="item"`.

#### 修饰符
.lazy
`<input v-model.lazy="mess" /><p>{ {mess}}</p>`, 这时输入字符时显示文本不会马上改变，而是
回车或tab键后改变，即.lazy使用change事件，而不是input事件。

.number
`<input v-model.number='age' type='number'/>`将用户输入值变为数字类型。经测试，type='number'
有上下调整按钮，并且无法输入数字。不使用.number时typeof(b9.num)返回string类型。

.trim
`<input v-model.trim='txt'/>`去除首尾空白字符。

### 组件基础
#### 组件data必须是一个函数
自定义组件代码如下:
```txt
<div id="c1">
      <clock></clock>
</div>

Vue.component('clock', {
      data: function () {
              return { count: 0 };
      },
      template: '<button @click="count++">{ {count}}</button>'
});
var c1 = new Vue({
      el: '#c1'
});
```
组件是可以复用的vue实例，如
```txt
  <div>
    <clock />
    <clock />
    <clock />
  </div>
```
其中每个clock都是一个不同的实例，都有自己的属性定义。所以组件定义中data属性不能同上面一样
是一个简单的对象，而需要是一个函数，该函数返回需要的data对象，这样每个实例就有自己的对象了。

`c1=new Vue({el: '#c1})`中c1是根实例，el是根实例特有的属性。

经测试发现，组件复用时这种写法`<clock/><clock/>`只有一个组件会显示，而
```txt
<clock></clock>
<clock></clock>
```
这种写法才能正确的显示多个自定义组件，原因不明。

#### 组件的组织 
组件是通过嵌套树的形式进行组织的。`Vue.component('(xxx', {...})`的形式是全局注册。
在全局注册后任意新创建的Vue根实例和子组件实例(即为全局)都可以使用该组件，
经测试将上面的组件定义和根实例定义顺序颠倒，vue报错`unknown custom element`.

#### 通过prop向子组件传递数据 
为了给组件传递值，Vue使用props属性将需要传递的属性名集合为一个数组，如下
```txt
Vue.component('xx', {
  props: ['title'],
  template: '<p>{ {title}}</p>'
});
```
在组件模板中可以像访问data中的值一样访问props中的属性。
传值时只需要像普通html标签的属性值赋值一样即可，如`<clock title='wttClock'/>`.
同理，当属性值是动态值(如v-for列表中)时，一样使用如`v-bind:title='item.title'`进行属性绑定。

组件属性prop除了可以是字符串类型的属性外，还支持将一个对象作为属性。这样向组件传值时就
不需要逐个具体指明对象的属性值，只需要绑定该对象即可。
需要注意的是，传值时不能同字符串一样直接赋值，需要使用v-bind标签绑定值对象。即前面的缩写
冒号不可少。代码如下:
```txt
<div id="c1">
      <clock></clock>
</div>
Vue.component('clock', {
      data: function () {
              return { count: 0 };
      },
      template: '<button @click="count++">{ {count}}</button>'
});
var c1 = new Vue({
      el: '#c1'
});

<div id="c1">
      <clock :property="{name: 'wttClock', color: 'red'}"></clock>
      <clock :property="{name: 'wttClock2', color: 'red2'}"></clock>
      <clock :property="{name: 'wttClock3', color: 'red3'}" other="GGG"></clock>
</div>
Vue.component('clock', {
      data: function () {
              return { count: 0};
      },
      props: ['property', 'other'],
      template: '<div>' +
              '<p>{ {property.name}} is { {property.color}}</p>' +
              '<button @click="count++"> and { {other}},' +
              ' clicked { {count}} times</button></div>'
});

var c1 = new Vue({
      el: '#c1'
});
```
同时，需要注意的是，组件模板中使用了property属性对象的相关信息进行显示，使用组件时必须给出
property属性值，否则会报错。如这里会报错`cannot read property: name of undefined`, 对应着
模板第一处的`{ {property.name}}`。

#### 单个根元素 
组件模板template中只能包含一个根元素，所以当模板中存在多个平级标签时，必须使用一个元素标签
将多个元素"包裹"起来。

#### 监听子组件事件
有时候需要根据组件内部子元素的事件修改自定义组件所在元素(即其父组件)的状态，如点击按钮修改
父组件中所有文本的字体大小, 这时就需要将自定义组件内部的事件"传播"给其父组件进行处理, 
反过来也可以说父组件监听子组件的事件.

实现该功能需要两步设置.
1. 在子组件上"发射"事件.如`<button @click="$emit('afterClicked')"></button>`, 其中将点击
操作通过内建的$emit方法触发一个事件, 指定事件名为afterClicked.
2. 在父组件中使用如`<self-component v-on:afterClicked="doSth"></self-component>`, 
这里需要注意的是这里的响应函数属于父组件,处理的属性也是父组件的属性,不可与子组件混淆.

具体代码如下:
```txt
<div id="c2" :style="{fontSize: fs}">
      <p>I am Text being affected by wtt click event</p>
  <wtt v-on:ee="cfs"></wtt>
</div>

Vue.component('wtt', {
   data: function () {
         return {
                 acolor: 'red'
         };
   },
   methods: {
           changeColor: function () {
                   this.acolor = 'black';
           }
   },
   template: '<div :style="{color: acolor}">' +
           '<p>WTT GO FUN</p>' +
           '<button @click="changeColor" :style="{color: acolor}">call wtt component inner methods to change color of' +
           ' wtt</button><br><br>'+
           '<button @click="$emit(\'ee\', 20)" :style="{color: acolor}">change parent text fontSize</button>'+
           '</div>'
});
var c2 = new Vue({
      el: '#c2',
      data: {
            fs: 10
      },
      methods: {
              cfs: function (am) {
                    this.fs = am;
              }
      }
});
```
其中,可以看到$emit方法还可以传递第二个参数, 这里代表新的字体大小, 即子组件触发事件时可以给出
更具体的信息或指令. 父组件进行响应处理时如果是表达式, 用$event可以得到该参数值,如果是方法,
直接如上使用第一个参数即可.

#### 组件上使用v-model
普通标签的v-model实际上是语法糖, 即`<input v-model='it' />`它等价于
`<input :value='it' :input='it = $event.target.value' />`, 即input标签的值取属性it的值, 
同时将input标签的输入值赋值给属性it, 这样就实现了双向绑定.

自定义组件实现双向绑定,同理如下
```txt
<wtt :value='it' :input='it = $event'></wtt>
```
其中, 首先wtt组件需要有value这个属性, 即props中有属性value; 再是wtt组件中的input标签同前面
所说需要触发一个事件名为'input'. 代码如下:
```txt
<div id="c3">
      <wtt-input :value="mess" @input="mess=$event"></wtt-input>
</div>
Vue.component('wtt-input', {
    props: ['value'],
    template: '<div>\
                <p>wtt-input value is { {value}}</p>\
                <input @input="$emit(\'input\', $event.target.value)" :value="value">\
               </div>'
});
var c3 = new Vue({
    el: '#c3',
    data: {
          mess: 'xxx'
    }
})
```
其中为了让组件内的值与prop mess同步显示, 使用了`:value="value"`进行绑定.
这时就可以在input框中输入值,通过p标签查看prop值; 同时在console中使用`c3.mess = 'gogo'`命令
后可以看到input框的值同步发生了改变, 从而验证出确实实现了双向绑定.

#### 通过插槽分发内容 
以上的自定义组件使用时是这种模板`<wtt></wtt>`, 如果想要像普通元素一样在标签中传值,如
`<p>message</p>`, 可以使用Vue的自定义元素slot, 使用时`<wtt>Hello World</wtt>`或直接内嵌
其他标签`<wtt><div><p>GO FUN</p><button>click me</button></div></wtt>`.然后只需要在组件
定义模板中插入`<slot></slot>`即可.具体代码略.

#### 动态组件 
某些场景下需要一个动态的组件, 即根据不同的条件该组件的类型可以切换.
代码如下:
```txt
<div id="c5">
      <button @click="cc">change the component type</button>
      <component :is="curComp"></component>
</div>

Vue.component('wtt-a', {
      template: '<div><p>I am A</p></div>'
});
Vue.component('wtt-b', {
      template: '<div><p>I am B</p></div>'
});
Vue.component('wtt-c', {
      template: '<div><p>I am C</p></div>'
});
var c5 = new Vue({
      el: '#c5',
      data: {
            comps: ['a', 'b', 'c'],
              index: 0
      },
      computed: {
            curComp: function () {
                  return 'wtt-' + this.comps[this.index];
            }
      },
      methods: {
              cc: function () {
                      this.index = ++this.index % this.comps.length;
              }
      }
})
```
编写过程中发现几点要注意:
1. 组件名要多个单词, 自定义高一点, 使用如a作为组件名时(a是超链接...), vue会给出警告.
2. 计算属性中不要忘记使用this引用data中的属性.

从代码中可以看出, 组件动态化主要就是利用了Vue的Component标签配合其is属性, 在is属性中指定
具体的组件名称即可实现组件类型的切换.

注: 除了可以使用具体的完整组件名称, 还可以使用一个对象数组, 对象属性包括组件名称和组件模板,
具体代码略过.

#### 解析DOM模板需要注意内容
如前面说过的, 某些标签如`<ul>`中只允许出现`<li>`标签,这时如果在其中加入自定义组件会被视为
无效标签而被提取到`<ul>`标签外,渲染出现问题.
如以下代码:
```txt
<div id="c6">
      <p>Hello world</p>
      <table>
              <wtt-row></wtt-row>
              <tr><td>Done</td></tr>
      </table>
</div>
Vue.component('wtt-row', {
      template: '<tr><td>I am wtt-row</td></tr>'
});
var c6 = new Vue({
      el: '#c6'
})
```

通过devTool查看元素可以看到,wtt-row被提取到table标签外, 渲染错误.这时可以使用
`<tr is='wtt-row'></tr>`代替`<wtt-row></wtt-row>`.再次查看, 可见渲染成功.
这是在普通的html页面中使用出现的问题,如果是在以下场景中使用就没有该问题, 
不需要使用is特性:

1. 字符串中, 如以上例子这样写也可以成功渲染.
```txt
<div id="c6">
      <p>Hello world</p>
      <wtt-table></wtt-table>
</div>
Vue.component('wtt-row', {
      template: '<tr><td>I am wtt-li</td></tr>'
});
Vue.component('wtt-table', {
      template: " <table> <wtt-row></wtt-row> <tr><td>Done</td></tr> </table>"
})

var c6 = new Vue({
      el: '#c6'
})
```

2. 单文件组件.vue, 暂略
3. `<script type="text/x-template">`, 暂略

### 深入了解组件

### 组件注册
#### 组件名
组件名推荐使用多个小写单词, 并且必须包含一个连字符, 这样可以避免与已有或未来的html标签名
冲突.

#### 全局注册
前面使用Vue.component('xx', {...})的方式即为全局注册, 在注册以后后面创建的vue根实例都可以
使用该组件, 其他组件也能使用.

#### 局部注册
全局注册的问题在于即使没有使用该组件,该组件注册后仍然会在最终的依赖结果中.这时可以使用局部
注册.代码如下:
```txt
<div id="c6">
      <p>Hello world</p>
      <table>
              <tr is="wtt-row"></tr>
      </table>
</div>

var wttRow={name: 'wtt-row',
      template: '<tr><td>I am wtt-row</td></tr>'};

var c6 = new Vue({
      el: '#c6',
      components: {
              'wtt-row': wttRow
      }
})
```
可以看出, 局部注册就是在需要使用自定义组件的vue实例中使用components属性列出所有需要的组件,
列出组件名称和对应的组件对象, 组件对象有name属性和template属性(与全局注册组件一致).

经测试wttRow也不能放在c6 vue实例后面定义, 否则报错`unknown custom element`, 对于这个问题
组件对象本身的定义位置无影响, 应该是vue渲染的顺序性(或者生命周期?)要求导致.

注: 局部注册的组件在子组件中不可用. 
这应该是显而易见的, 子组件中也可用的组件是全局注册的组件.

#### 模块系统
暂略

### Prop
#### prop的大小写
组件属性在定义时使用正常变量命名规范驼峰式命名方式(camelCase)如`wttTxt`, 但在html Dom中使用时如果
直接使用这种命名如`<wtt-com wttTxt='mes'></wtt-com>`, 浏览器无法正常显示, 在devTool中vue
显示了一个tip, 告知这种情况下, 应使用kebab-case方式, 即`<wtt-com wtt-txt='mes'></wtt-com>`.

#### prop类型
属性除了有字符串类型, 还有其他类型, 如布尔型`checked=true`, 数字型`width=100`等,这时props
字符串数组无法满足需求, 可以使用对象来定义props. 如
```txt
props: {
  message: String,
  checked: Boolean,
  width: Number
}
```
其中, 对象属性名为prop名称, 对应属性值为prop类型. 其他类型有Array, Object, Function, 
Promise.

#### 传递静态或动态prop 
如前面所说, 在传递prop属性值时, 直接赋值如`<wtt-com num='88'></wtt-com>`,这时属性
num的值是字符串"88", 如果需要传递数字类型, 需要使用v-bind指令,如
`<wtt-com :num='88'></wtt-com>`. 这时`props: {num: Number}`即可正常工作.
其他类型, Boolean, Array, Object类型同理都需要使用v-bind指令.

注: 不带参数的v-bind指令如`<wtt-com v-bind='obj'></wtt-com>`是将obj的所有属性作为prop传入,
代码略.

#### 单向数据流
有时候组件需要"修改"通过prop属性传递进来的值, 主要就是将传进来的该属性值作为初始值,
后续在组件内部进行修改.如下代码:
```txt
<div id="c7">
      <wtt-com :init-num="88"></wtt-com>
</div>
var wttCom = {name: 'wtt-com',
      props: {
            initNum: Number
      },
      data: function(){
          return {
                  wttCount: this.initNum
          }
      },
      methods: {
          add: function () {
                this.wttCount++;
          }
      },
      template: '<div><p>{ {wttCount}}</p><button @click="initNum++">increment' +
              ' wttTxt</button></div>'};

var c7 = new Vue({
      el: '#c7',
      components: {
              'wtt-com': wttCom
      }
})
```
运行代码, vue给出报错信息:`应避免直接修改一个prop属性, 应使用data或计算属性`, 这里我们改成
`wttCount++`即可实现功能.

另外, 经测试, 如果这样写`@click='this.initNum++'`, 点击按钮无反应, 可以想到template中的
this已经没有指向该组件实例了(可能是渲染时的其他中间对象). 但如果绑定到方法上`@click='add'`,
这时就需要如上面代码所写`this.wttCount++`, 因为这时this确实是指向该组件实例的, 不加this
则会报错.

这种只能从父组件传递数据到子组件, 而子组件不能直接修改prop的方式即为单向数据流.

不过, 因为javascript中对象和数组是引用传递, 所以对于数组或对象类型的prop属性, 如果在组件中
直接修改prop, vue不会报错并且修改成功. 对于该问题, 为避免影响到父组件, 可以在data中拷贝对象
进行处理, 代码如下:
```txt
<div id="c7">
      <wtt-com :init-num="{val: 88}"></wtt-com>
</div>
var wttCom = {name: 'wtt-com',
      props: {
            initNum: Object
      },
      data: function(){
          return {
                  wttCount: Object.assign({}, initNum)
          }
      },
      template: '<div><p>initNum is { {initNum}}</p><p>wttCount is { {wttCount}}</p>' +
              '<button @click="wttCount.val++">increment wttCount</button></div>'};

var c7 = new Vue({
      el: '#c7',
      components: {
              'wtt-com': wttCom
      }
})
```
注: 使用时同样需注意Object.assign的浅拷贝问题.

#### prop验证 
prop除了可以指定类型外, 还可以指定是否必输, 默认值, 自定义验证函数等. 如
```txt
props: {
  wttProp: {
    type: Number,
    required: true,
    default: 100,    // 对象或数组的默认值是从函数获得
    validator: funtion(val){  // 值必须是66, 77, 88之一
      return [66, 77, 88].indexOf(val) != -1;  
    }
  } 
}
```
prop验证是在组件实例创建前完成, 所以default, validator函数不能使用data, computed等中的值.

注: 除基本类型外, prop还可以为自定义对象类型, 如`props: {man: Person}`, validator中可以用
instanceof验证类型.

#### 非prop的特性
某些场景下, 子组件没有定义某个prop, 这时可以直接传递需要的prop值, 如给某些组件打上是否
激活的标记, 如`<wtt-com :disabled="true"></wtt-com>`, wtt-com中可以不用定义disabled特性,
该特性会被添加到组件根元素下,外界需要判断时直接判断即可.

外部传入的prop属性通常会替换组件模板内已定义的值, 而class和style特性会将两者合并起来.

### 自定义事件
教程中说:子组件产出的事件名和父组件监听的事件名必须保持一致(事件名与prop属性不同, 
不会进行camelCase和kebab-case的转化), 即this.$emit('myEvent')只有@myEvent才能监听到, 
但myEvent事件的监听会被dom自动转化为全小写.所以@myEvent监听不到.**但经实际测试, 可以监听到....**




### 插槽
### 动态组件&异步组件
### 处理边界情况


### 过渡&动画

### 进入/离开&列表过渡
### 状态过渡


### 可复用性&组合

### 混入
### 自定义指令
### 渲染函数&JSX
### 插件
### 过滤器


### 工具

### 单文件组件 
### 单元测试
### TypeScript支持
### 生产环境部署


### 规模化

### 路由 
### 状态管理
### 服务端渲染


### 内在

### 深入响应式原理

## springboot整合vue
1. 建立父项目, 有2个模块. 在父项目中定义spring-boot-starter-parent版本
2. 用springboot initializer新建子模块backend, 依赖选starter-web和mybatis, 建立后修改parent
改为第一步中新建的父项目, 修改build 插件实现拷贝vue相关静态文件到backend的static目录下.  
3. 使用windows安装包安装node, 安装过程中选择第二个带npm的选项.
4. `npm install -g @vue/cli`, 完成后使用`vue --version`查看版本.
5. 在frontend目录下执行`vue create frontend`, 删除frontend下的src目录, 将生成的vue项目
frontend下的所有内容提到上一级的frontend目录中.
6. 编写后台代码, 启动测试后台服务
7. 添加axios. frontend目录下执行`npm install axios --save`.
8. 使用vue-cli-plugin-element添加element-ui组件.frontend目录下执行命令为`vue add element`
9. idea添加vue.js插件(网络不好未安装); 
   filetypes - html - .vue; 
   javascript es6;
   editor - file and code templates -> + Vue File, extension vue, open with html format
10. 修改element.js, 引入table, tableColumn组件, 修改App.vue, 使用axios请求后台.
后台服务地址暂定为请求根目录`/xxx`.
11. 在backend中执行`mvn process-resources`将frontend dist全部内容拷贝到backend 
`src/main/resources`中.
12. 启动BackendApplication main方法.
13. frontend下添加.eslintrc.js, 添加devServe配置, 使得npm run serve时可以访问后端服务.  

别人的架子
1. 安装node, npm
2. 执行命令`npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass`  
3. frontend下npm install
4. npm run serve查看页面
5. npm run build生成
6. 主目录执行`mvn --projects backend springboot:run --settings d://alimaven//settings.xml`.

## webpack 4.41.2使用
### 概念
1. entry
处理依赖的起始位置 默认./src
2. output
打包输出(emit)信息,包括路径,文件名等
3. loader
loader可以将非js文件转换为依赖处理. 可以在module.rules中配置.
test选中处理目标(可以用正则表达式), use指明使用哪个loader.
4. plugins
实现如打包优化和压缩等一系列功能.
5. 模式
开发或生产模式, 启用webpack内置优化

### 指南
#### 起步
1. npm init -y
   npm i webpack webpack-cli --save-dev
2. 新建dist/index.html, src/index.js, 修改package.json为private
3. npm i --save lodash
4. npx webpack  该命令是运行`node_modules`中的webpack命令, 将src/index.js转变为dist/main.js
5.  使用浏览器打开index.html查看效果
6. 新建webpack.config.js, 其中output修改为dist/bundle.js, 所以dist/html中也需要修改.
7. npm webpack --config webpack.config.js  这里--config可省略,默认即为webpack.config.js
8. 添加npm脚本, npm run build代替npx命令

#### 管理资源
1. npm i --save-dev style-loader css-loader  
2. 修改webpack.config.js指定使用style-loader, css-loader加载css文件. 
3. 新建src/style.css, 修改index.js import './style.css'; element.classList.add('hello');
4. npm run build
5. 浏览器打开index.html查看效果, 通过dev-tool查看网页代码head标签, 源码被压缩无法查看

图片
1. npm i file-loader --save-dev
2. 修改webpack.config.js使用fileloader处理png, jpg等格式文件
3. 在src下添加图片, src/index.js引入图片, src/style.css使用该图片作为背景图片
4. npm run build
5. 浏览器打开index.html查看效果, 通过dev-tool查看网页代码head标签, 源码被压缩无法查看

字体
file-loader同样可以处理字体, 具体过程同上, src/style.css中可以使用@font-face引入

加载本地数据
使用csv-loader, xml-loader可以加载本地的csv/tsv, xml数据文件
还可以处理json格式数据, src/index.js中引入的变量为解析后的JSON数据(经测试xml实际被转换为
一个对象, 根节点为属性名).

#### 管理输出
多入口
1. 新建src/print.js, 修改src/index.js使用print.js, 修改webpack.config.js添加入口,并修改
输出文件名.
2. npm run build
3. index.html查看效果

使用HtmlWebpackPlugin生成index.html文件
到目前为止,webpack帮我们将src/index.js等文件连同依赖进行打包, 但dist/index.html还是我们
自己手动写的标签, 当上面的输出文件如dist/xx.bundle.js名字修改后,还要手动修改dist/index.html,
这时我们可以使用该插件自动生成dist/index.html文件
1. npm i html-webpack-plugin --save-dev
2. 修改webpack.config.js引入该插件
3. npm run build
可以看到, `*.bundle.js, index.html`都是webpack生成(emit)的, webpack plugin中设置的title即为
页面title, 相应的script标签内嵌在body标签中.

清理dist文件夹
1. npm i clean-webpack-plugin --save-dev
2. 修改webpack.config.js引入该插件
3. npm run build
这里发现使用的clean-webpack-plugin版本为3.0.0, 文档写法报错CleanWebpackPlugin is not a 
constructor, 改为const {CleanWebpackPlugin} = require('..'); 
plugins中写new CleanWebpackPlugin()即可. 这里的变量名不可修改, 否则同样报错not a constructor.

#### 开发
source map
追踪错误具体位置, 修改webpack.config.js后重新编译即可.
source map是js自带功能, 无需使用插件.它有很多选项, 针对开发环境和生产环境有不同的推荐, 
经测试发现inline-source-map可以显示原代码的js文件名称和行数, 适合开发环境错误定位.

开发工具
前面每次修改完配置或代码, 都需要重新编译生成文件,非常麻烦, 这里同样可以使用webpack提供的
多种方法自动编译.
1. watch
修改package.json, 建立一个npm脚本命令"watch": "webpack --watch".使用`npm run watch`执行该
脚本. 这里其实是用`npm run watch`代替执行`npm run build`, 不同的是命令会一直执行, 始终监控.

修改src/print.js后发现脚本有自动重新编译, 但是需要刷新浏览器才能看见效果.

2. webpack-dev-server
这是webpack提供的一个web服务器, 可以实现自动刷新(live reload). 
   1. npm i webpack-dev-server --save-dev
   2. 修改webpack.config.js指定devServer代码加载位置
   3. 修改package.json添加npm start脚本启动devServer.
经测试, 执行`npm start`后自动打开`localhost:8080`页面, 修改文件后自动刷新生效.

3. webpack-dev-middleware
webpack-dev-server内部使用了该middleware, 它也可以单独使用, 进行自定义配置, 这里略过.

最后提到, 文件编辑器的safe-write功能可能影响重新编译, 应该是说dist目录不能被重新编译结果
自动覆盖.vim中没有发现该问题, 后面遇到再说.



#### HMR hot module replacement
无需完全刷新可以热加载模块, 如样式等. 暂时未发现用途, 暂略

#### tree shaking
打包时去除没有被引用的模块.
简单的修改package.json, 指定mode: "production"可以压缩打包输出, 也可以使用命令行
`npm run build --optimize-minimize`来启用webpack内部的压缩插件UglifyJsPlugin.
1. npm i uglifyjs-webpack-plugin
2. 修改webpack.config.js引入该plugin
3. npm run build
查看dist目录大小, 发现压缩后目录小了10倍!


#### 生产环境配置
同spring相同, webpack也可以对于开发和生产环境进行不同的配置, 并且它可以将公共的部分提取出来,
再使用webpack-merge工具将配置进行整合.
1. 删除webpack.config.js, 新建webpack.common.js, webpack.dev.js, webpack.prod.js, 
2. npm i webpack-merge --save-dev
3. 修改package.json将start定义为生产环境启动脚本, build定义为打生产环境包. 

生产环境的sourceMap可以在webconfig.prod.js的UglifyJsPlugin中指定. 
另外, `process.env.NODE_ENV`是个重要的环境变量, 因为在webpack.config.js中无法直接赋值(是个
bug?), 所以需要通过new webpack.DefinePlugin(...)的形式赋值, 赋值后所有依赖包括用户自己的
代码都可以使用, 如代码中可以判断该变量得到当前环境是开发还是生产环境来进行逻辑处理.

分离CSS文件适用于css文件较大的情况, 暂时略过.

可以看到, common中配置的是共同配置, dev和prod配置中通过引入merge模块对象, 聚合了common配置
和自己额外添加的配置. start和build脚本通过前面提过的--config指定自己需要的配置文件.
注意:
1. css loader也需要添加到common配置中
2. clean webpack plugin使用方式需如上修改
3. npm start后可以发现dist中没有文件生成, 它只是启动了内置web服务器, 用于开发调试, 需要生成
文件时仍需npm run build

#### 代码分离
前面的src/index.js中引入了loadash模块, 如果添加另外一个入口src/b.js, b.js中如果也引入了
loadash模块, 那么打包时就会将该模块重复打入2个bundle中. 因为文档中的插件CommonsChunkPlugin
已过时,现在只能使用SplitChunksPlugin插件进行提取公共依赖.

1. 修改webpack.common.js, 这里我们简单的加上配置
```txt
  optimization: {
    splitChunks: {
      chunks: 'all'
    }}
```
2. npm run build后发现, 输出目录中多了一个vendors~app~b.bundle.js文件, 其中即包含了共同依赖
loadash, 再查看app.bundle.js, b.bundle.js文件, 可以看见其中已经都没有了loadash模块.

动态导入
前面使用模块是import xx from xx 或 import {xx} from xx的形式, ES5还有动态加载import(...)方法,
它基于异步操作, webpack将它作为分离的模块起点, 打包时(包括子模块)会作为一个单独的chunk包.
因为import无法设置模块名称和属性, 所以webpack只能通过注释来定义这里的chunk名称!
这个功能暂时略过。

bundle分析
可以通过工具分析生成的bundle, 具体以后使用到再看。

#### 懒加载 
懒加载提高了应用的启动速度，灵外某些模块可能永远不会被加载(如用户没有触发该动作)。
上面的分离chunks是从技术上提高了加载速度，但不属于懒加载。
下面操作只有在用户点击按钮时才加载src/print.js模块。

1. 修改print.js, index.js中使用动态加载import().
2. 修改webpack.common.js指定非入口chunk名称，即动态加载的模块名称，其中的name如上面所说是
动态加载时通过注释指定的。

经测试，npm run build会uglifyjs插件会报错。暂时注释后运行成功，点击按钮后print.js模块才会
加载。另外，我们在webpack.common.js中只指定了app和b2个入口，编译后发现多了一个print.bundle.js,
说明动态加载确实默认是作为分离入口。

以上uglifyjs报错，是因为uglifyjs不支持es6(上面的动态加载使用了es6的语法), 可以不用uglifyjs
插件，转而使用支持es6的插件terser-webpack-plugin, 在webpack.prod.js中这样配置:
```txt
const webpack = require('webpack');
const merge = require('webpack-merge');
//const UglifyJSPlugin = require('uglifyjs-webpack-plugin');
const common = require('./webpack.common.js');
const TerserPlugin = require('terser-webpack-plugin');

module.exports = merge(common, {
  devtool: 'source-map',
  plugins: [
    //   new UglifyJSPlugin({
    //     sourceMap: true
    //   }),
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify('production')
    }),
  ],
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        sourceMap: true,
      }),
    ],
  },
});
```
总体来说，这个问题可以使用babel解决。

教程最后提到， react, vue, angular都有自己的方式实现懒加载，如vue router和vuex都可以实现
懒加载。这里简单记录下，后面再看具体原理。
```txt
//vue router
// Instead of: import Login from './login'
const Login = () => import("./login");

new VueRouter({
  routes: [{ path: "/login", component: Login }]
});


//vuex module
const store = new Vuex.Store()

// Assume there is a "login" module we wanna load
import('./store/login').then(loginModule => {
  store.registerModule('login', loginModule)
})
```

#### 缓存 
在开发过程中可以通过禁用浏览器缓存或刷新缓存的方式来加载新编译的文件，但生产环境中不可能
要求用户这样做，这就要求webpack重新编译后能自动刷新客户端的缓存。实际在现实中，都是部署完
以后再让用户使用，线上升级还是比较少。这里的缓存个人感觉主要还是提高了开发过程中浏览器的
缓存性能，提高开发效率。尤其是模块依赖比较多的情况。

实际上，缓存复用的基础是文件名相同，所以我们可以让每次修改后文件名发生变动即可。即
webpack.common.js中output的配置由`filename: '[name].bundle.js`改为
`filename: [name].[chunkhash].js`, 可以看到这里输出的文件名中包含了编译时的hash值。

注: 经过以上测试后，不修改文件的情况下重复编译发现哈希码没有变化，说明新版本没有文档中说的
hash问题。

anyway, 为了利用缓存提高性能，主要是需要进行拆分:
1. 将模板代码(主要指manifest的内容)和引入的第三方依赖模块提取出来，这里也需要用到前面的
自动切分插件SplitChunksPlugin.
2. 分离后主要有三块内容，自己的业务逻辑代码main bundle, 依赖包vendor bundle，以及样板
manifest bundle。
除了删除vendor依赖的情况外，其他情况vendor bundle都不应当发生变化(指其文件名的hash值)。
这里它变化的原因在于hash值是根据module.id生成的，而module.id会受解析顺序的影响。
```txt
也就是说，当解析顺序发生变化，ID 也会随之改变。因此，简要概括：
main bundle 会随着自身的新增内容的修改，而发生变化。
vendor bundle 会随着自身的 module.id 的修改，而发生变化。
manifest bundle 会因为当前包含一个新模块的引用，而发生变化。
第一个和最后一个都是符合预期的行为 -- 而 vendor 的 hash 发生变化是我们要修复的。
```
为了解决vendor的问题，即我们不应当使用module.id来生成hash值，webpack提供了NamedModulesPlugin,
HashedModuleIdsPlugin, 它们的原理都是根据文件路径来生成hash值，这样就解决了没有进行修改
vendor也会发生变化的问题。

注: 对于runtime chunk问题，在默认的SplitChunksPlugin中没有测试出该问题。所以使用SplitChunksPlugin
的默认配置即可，默认为async.

为了查看具体的输出打包效果，这里需要先配置图形化工具，这里使用Webpack bundle analyzer plugin.
1. npm i webpack-bundle-analyzer --save-dev
2. 为了灵活方便，先生成json文件，再查看该文件。修改webpack.prod.js引入插件，修改package.json
编写npm脚本启动服务展示。查看完以后，修改webpack.prod.js中的generateStatsFile为false即可
避免生成json文件。
```txt
webpack.prod.js

const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'disabled', // 不启动展示打包报告的http服务器
      generateStatsFile: true, // 是否生成stats.json文件
    }),
  ],

package.json
    // 这句实际可省略，因为在webpack.prod.js配置后，可由npm run build代替
    "getjson": "webpack --profile --json > ./dist/stats.json",  
    "analyze": "webpack-bundle-analyzer --port 8888 ./dist/stats.json"
```

splitcChunksPlugin配置意义:
插件默认将`node_modules`中所有的模块划为一个缓存组vendors, 所有重复的依赖划为缓存组default。
default组默认优先级为-20, vendors默认优先级为-10.

1. optimization.splitChunks.chunks有3种值，async, initial, all
async: 只对异步加载的chunk处理。即任意一个动态引入的依赖都会被切分为一个新chunk, 
静态的依赖即使有重复依赖也不会优化。

initial: 对初始chunk处理，初始有重复引入的依赖将被切分。而异步加载的依赖根据动态引入的默认
处理方式也会被切分，最后结果即为静态和动态导入的包都可以得到优化。它的问题在于对静态和动态
依赖的区分处理，这种区分会导致某些既有静态又有动态引入的相同模块被重复打包。为避免该问题，
应使用下面的all方式。

all: 即不区分动态和静态引入，统一处理。针对上面既有动态又有静态引入的相同模块，从结果看
是统一作为动态引入处理(由最终bundle名称确定，未亲自测试)。

这样看，默认的async没有优化重复的静态引入，应当使用all方式。
另外，应当使用optimization.runtimeChunk: "single", 经测试几行代码打出的包就有几k大小，将
webpack运行时单独打一个包后回到正常的几百字节。修改js文件内容不影响打出的runtime文件。

## webpack4 整合vue

Vue-loader
### 起步
1. npm i -D vue-loader vue-template-compiler 
**npm install xxx 默认是生产模式，依赖追加到dependencies; npm install -D xxx 相当于--save-dev**
2. 修改webpack.common.js引入vue-loader plugin, 并针对.vue, .css文件进行处理。

其中loader除了配置外，还需要引入插件，这样如对js配置babel处理时，vue文件中的script块才能
同样得到处理. 

### 处理资源路径
vue-loader会自动将template中的资源转化为模块请求, 对css文件配置了css-loader后, css块中的资源
同样也会被转化为模块请求, 这是vue文件的资源处理机制.

注: 
1. 资源路径中如果以@开头, 会被看作是模块依赖, 可以在webpack中给@设置别名.如/src目录.
2. url-loader会将小文件转化为内联base64编码的url地址,减少http请求次数, 文件过大后使用
file-loader. 使用base64编码的图片体积会变大, 影响加载css文件速度.

### 使用预处理器
#### Sass
现在有三大CSS预处理器, sass/scss, less, stylus, 经查找scss用的较多,较为一般性. 
1. npm i -D sass-loader node-sass
2. 修改webpack.common.js, 针对.scss文件处理
这时可以在.vue文件中使用`<style lang="scss">...</style>`使用scss.

注: sass-loader默认不处理基于缩进的sass语法.需要额外配置, 这里暂不使用, 略过. 

#### postcss
postcss是一款使用插件转换css的工具,经查看, 总体实用性不强, 其中autoprefixer和stylelint
还可以, 暂略过.也可以注意到vue loader默认不应用postcss变换.

#### babel
轻松编写es6语法代码无需担心浏览器支持的神器, 必装.
1. npm i -D @babel/core @babel/preset-env babel-loader
2. 修改webpack.common.js对.js文件使用babel-loader, 同时排除掉`node_modules`目录中的文件,
但如果`node_modules`目录中有vue单文件组件, 还是应当使用babel转化, 所以需要进行判断筛选.
3. babel转换代码有时会产生重复代码, 如对class类的编译会产生多个工具函数. 这个问题可以通过
babel插件实现: `npm i -D @babel/plugin-transform-runtime @babel/runtime`.
4. polyfill可以提供某些不支持的特性, 从而支持完整的ES2015+环境.`npm i -D @babel/polyfill`.
5. 编写babel.config.js文件
```txt
module.exports = {
    presets: [
            '@babel/preset-env',
            {
                useBuiltIns: 'usage', // usage-按需引入 entry-入口引入（整体引入） false-不引入polyfill
                corejs: 3  // 2-corejs@2  3-corejs@3
            }
        ],
    plugins: ['@babel/plugin-transform-runtime']
};
6. npm i core-js@3 axios vue vue-router vuex
```

#### typescript
略
#### pug
是一个可以快速编写html标签的工具, 暂时不需要, 略过.

#### scoped css
暂略 
使用scoped后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件
的scoped CSS 和子组件的 scoped CSS 的影响。即子组件大部分是不受父组件影响, 只有其根节点例外,
如div标签等.

#### css modules
因为webpack现在是单入口或多入口, 引入css样式时非常容易造成全局命名冲突等问题, css模块化
依靠webpack等构建工具给出了解决方案. 具体就是编译过后样式名字会被自动加工.
具体略过, 个人推荐使用sass.

#### 热重载
略  
hmr会对打包的hash文件名报错, 经查找资料, 说开发环境不应当使用hash值作为输出文件名.
所以可以根据环境不同输出不同的名字.
```txt
主要是修改webpack.dev.js文件, hmr只用于开发环境

const merge = require('webpack-merge');
const common = require('./webpack.common.js');
const webpack = require('webpack');

module.exports = merge(common, {
  mode: 'development',
  devtool: 'inline-source-map',
  devServer: {
    contentBase: './dist',
    hot: true
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin()
  ],
});

webpack.common.js配置有关内容为:
提取css插件的支持:
      {
        test: /\.(sa|sc|c)ss$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
            options: {
              publicPath: './',
              hmr: devMode   // 开发环境开启hmr
            }
          },
          'css-loader',
          'sass-loader',
        ],
      },
主要是文件名的不同:
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: 'DemoHtml'
    }),
    new VueLoaderPlugin(),
    new MiniCssExtractPlugin({
      filename: devMode ? 'css/[name].css' : 'css/[name].[chunkhash].css',
      chunkFilename: devMode ? 'css/[id].css' : 'css/[id].[chunkhash].css',
    }),
  ],
  output: {
    filename: devMode ? '[name].js' : '[name].[chunkhash].js',
    chunkFilename: devMode ? '[name].js' : '[name].[chunkhash].js',
    path: path.resolve(__dirname, '..', 'dist')
  },
```

#### 函数式组件
略
#### 自定义块  
略
#### css提取  
1. npm i -D optimize-css-assets-webpack-plugin mini-css-extract-plugin 
2. 修改webpack配置文件
```txt
webpack.common.js:

const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const devMode = process.env.NODE_ENV !== 'production'

    rules: [
      {
        test: /\.(sa|sc|c)ss$/,
        use: [
          devMode ? 'vue-style-loader' : MiniCssExtractPlugin.loader,
          'css-loader',
          'sass-loader',
        ],
      },

    new MiniCssExtractPlugin({
      // Options similar to the same options in webpackOptions.output
      // both options are optional
      filename: devMode ? '[name].css' : '[name].[hash].css',
      chunkFilename: devMode ? '[id].css' : '[id].[hash].css',
    })

webpack.prod.js

const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");

 optimization: {
    minimizer: [new OptimizeCSSAssetsPlugin({})],
    splitChunks: {
      cacheGroups: {
        styles: {
          name: 'styles',
          test: /\.(sa|sc|c)ss$/,
          chunks: 'all',
          enforce: true,
        },
      }
    },
  }
```
####  

## 其他
### 引入依赖的路径和省略后缀符问题
在build中写util.js定义resolve寻找项目根路径,assetsPath是静态资源目录, 在webpack.common.js中
引入util.js对.js, .vue, .json后缀名的文件进行解析.,

### 图片拷贝问题
1. npm i -D copy-webpack-plugin
2. 修改webpack.common.js
```txt
const devMode = process.env.NODE_ENV !== 'production';

new CopyWebpackPlugin([{
      from: utils.resolve('static/img'),
      to: utils.resolve('dist/static/img'),
      toType: 'dir'
    }])
```

## vue-router
### 起步

不同的组件都有一个路径值, 路径匹配后router将该组件渲染到指定位置.
1. router-link是路由入口,通过to属性指定跳转路径,可以有多个; router-view标签输出匹配的组件.
2. 新建VueRouter实例并将其放入Vue根实例中.

### 动态路由匹配
路径中使用冒号开头的参数可以匹配不同的值, 参数名是键, 参数值为键值, 作为对象放入$route.params中,
如`/usr/:name/post/:postid`匹配到`/usr/wtt/post/123`时, $route.params为
`{name: 'wtt', postid: '123'}`.

路由变化时会复用组件, 所以生命周期不会被调用. 可以通过watch $route对象在路由变化时进行操作.
匹配优先级: 当一个路径同时匹配多个路由时, 优先定义的优先匹配

### 嵌套路由 
`<router-view></router-view>`输出匹配路由的组件。但该组件本身也可以使用
`<router-view></router-view`调用另外一个路由组件，这就构成了路由嵌套。
这时使用children属性在路由参数中进行配置。
注: 可以提供空的子路由组件便于子路径参数为空时时使用。

### 编程式的导航
`<router-link :to="...">`标签内部其实调用了this.$router.push(...)方法，所以我们可以直接调用
该方法进行自定义跳转。
注: params与path不能同时使用(在push方法和to属性中)，用以下写法:
```txt
const userId = '123'
router.push({name: 'user, params: {userId}})
router.push({path: `/user/${userId}`})
```
push方法后面还有onComplete和onAbort参数，适用于完成路由跳转或终止时调用。
但如果路由路径不变，只有参数发生变化时，这两个参数无法被调用，需要使用beforeRouteUpdate属性
进行处理。
router.replace方法不会向history添加记录，而是替换当前history记录。
router.go(n)在记录中向前或向后多少步。负数为后退，正数为前进。

### 命名路由 
可以给路由命名，使用name属性，这与上面的push使用name属性跳转是相同的。

### 命名视图
前面的`<router-view></router-view>`只有一个路由出口，如果想要对一个路由同时展示2个不同的
组件时(如侧边栏和主栏), 这时候就需要用到命名视图了。这时，该路由对应的就是多个组件，即
使用`components`属性而不是`component`.
router-view通过name属性指定不同的名字，components中通过name指定不同的组件。

嵌套路由可以和命名视图组合起来使用实现复杂的页面视图控制。
注: 命名视图如果在配置中找不到同名的组件，就不会显示组件内容。
`<router-view></router-view>`默认命名是default.

可以看到:
1. 嵌套路由就是组件中以直接或间接的方式(用组件封装起来，如UserSettingsNav组件)给出子路由的
链接, 即
```txt
<router-link to='/xxx/a'></router-link> 
<router-link to='/xxx/b'></router-link>
```
并使用children属性配置子路由的组件。
2. 命名就是组件中使用多个`router-view`出口，用name属性区分开。并在路由配置中使用components
属性指定每个名字视图对应的组件。

结合起来，嵌套路由和命名视图同时使用时就是多个router-link和router-view同时使用。

### 重定向和别名   
在routes配置中也可以配置重定向，将`{path: '/a', component: Foo}`改为
`{path: '/a', redirect: '/b'}`即可实现重定向。或者redirect: {name: 'xx'}重定向到命名视图。 

重定向是从/a跳转到/b, 然后匹配路由/b，而别名是跳转时保持url为/b, 但实际匹配为/a.
语法为`{path: '/a', component: xx, alias: '/b'}`. 
别名如在嵌套路由中匹配`/a/b/c/xxx`, 这时可以设置别名`/y`，访问`/y`时实际匹配`/a/b/c/xxx`,
感觉同linux的别名功能是相同的。

### 路由组件传参
前面定义组件时，有用到`<div>$route.params.id</div>`，看到这样的写法就应当意识到通过路由
显示该组件时，该路由需要有一个动态参数如xxx/:id进行匹配。这种组件定义明显限制了组件的
使用范围，所以我们不应当使用$route.params来获取路由传递的参数，而使用props代替。routes配置:
`{path: '/xxx/:id', component: User, props: true}`, 对于命名视图，需要一一对应定义props:
```txt
{
  path: 'xx/:id',
  components: {default: User, another: Another},
  props: {default: true, another: false}
}
```
这里的路由id是传给默认的User组件，所以props User为true, another为false.
注: 反过来想，我们通过路由参数给组件的属性进行了赋值操作。
即props设置为true时即将$route.params设置为了组件属性.同时，props还可以是对象或一个函数，
这2种情况下相应的路由值也会作为属性传递给组件。
### html5 history模式
vue-router默认hash(指`#`号)模式，即`http://www.baidu.com/#/hello`中的hash值为`#/hello`, 改变这个hash
值，页面不会向服务端发送请求，这就是单页应用的关键。

因为`#`号夹杂在url中不好看，所以可以使用history模式，前端在路由配置中覆盖所有路由情况，
在最后配置一个404页面，同时后端也需要在匹配不到任何路径时也返回一个页面，防止后端报404错误。

注: history模式不能刷新和地址栏访问页面, 需要后端对每个url地址进行处理, 所以相比hash模式,
history模式更麻烦, 同时它还有publicPath的问题, 需要修改图片等资源才能正常加载, 如无必要使用
hash模式即可.

## vuex
### 简单store模式 without vuex
当组件变多后,组件间参数传递变的复杂,而且经常有多个组件依赖一个数据源进行渲染, 或多个组件
同时更新一个数据源的情况,这时就需要进行状态管理, 这就是vuex的作用.
但是当应用很简单时, 可以简单使用store模式即可.

简单来说, 单纯使用一个对象state来记录状态,当组件改变它时, 没有修改记录, 所以无法追踪和控制, 我
们将该state对象封装到另外一个对象store中, 然后通过set方法去改变state属性, 这样就实现了
历史记录和统一管理.可以看出这种设计符合了面向对象编程的封装变化的设计原则.

以上简单store模式建立的是action -> store -> view的数据流向图. 这里action直接改变store, 
大部分时候这样做是不安全的, 而且不利于管理, 所以flux架构在中间加了一层, 变为
action -> dispatcher -> store -> view模式.这种模式即称为单向数据流, 任意邻近的2个节点之间
没有往返的数据流动.借助dispatcher我们可以实现状态快照, 状态时间旅行调试等高级调试功能.

flux架构就像眼镜, 你知道什么时候需要它. 意思即为当你的组件间状态开始变得复杂时, 一个好的
解耦架构可以带来轻松的管理体验.

### vuex
#### 开始
从基本的vuex计数器例子中可以看出:
1. 计数值使用计算属性显示,这样state变化时能进行响应.
2. 点击按钮的方法不直接修改store.state, 而使用store.commit('methodName'),这样利用调试管理.
3. 在中间层的store中定义state对象, mutation中定义操作方法, 直接写操作方法的定义时, 
store.commit()中参数默认即方法名.简单方法可以使用nameA: x => x + x;这样的箭头函数定义.

#### 核心概念
1. state
每个应用只应当维护一个store实例, 这样应用的每一刻状态都可以进行控制.
前面view响应store的变化最简单的方式就是通过计算属性, 但每个子组件都必须引入store实例, 比较
麻烦, 可以在根实例中注册store实例, 它会自动"注入"所有子组件, 子组件中不用引入,直接使用
this.$store.state.xxx即可.

mapState:
上面的计数器例子中, 页面通过计算属性显示该state状态, 计算属性这样定义:
```txt
computed: {
  count(){
    return this.$store.state.count;
  } 
}
```
当需要根据state生成多个用于显示的计算属性时(还可能加上组件自己的data属性), 这样做就会有很多
的重复.vuex提供了mapState函数, 可用于简化该计算属性的编写. 当只需要显示state属性并且计算属性
名和state属性名相同时, 可以直接在mapState函数中传递字符串数组, 这是最简洁的定义方式.

注: 当需要使用组件自身的this属性时, 只能使用普通函数定义, 箭头函数是不绑定this的.
注2: this其实就是call方法的第一个参数, 常规的方法调用如foo()其实是标准形式foo.call()的变体.
如调用foo.call(obj)时方法内的this指向的就是obj对象, 但箭头函数无法通过这种形式改变this指向.
也就是说调用foo.call(a,b)时如果foo是一个箭头函数, a参数会被忽略, 而b参数会被当作第一个参数
传入方法内进行处理.

使用mapState时, 可以发现它"霸占"了整个computed属性, 如果这时想要定义本地局部的计算属性时,
可以使用对象展开运算符`...`, 即
```txt
computed: {
  localComputedProperty: function(){...},
  ...mapState(['xx', 'yy'])
}
```
注: 只有共享的状态才需要放入根实例store的state值中, 组件内部的状态还是应当放在组件内部.

2. getters
在组件增多时，如果多个组件对根store实例有一些共同的处理逻辑，我们完全可以将它们提取出来
放到store实例中进行定义，即store的getters属性。

在store中定义好getters后，组件中可以使用this.$store.getters.xxx进行属性调用;
还可以给getters传递参数实现动态处理，如传递索引值查询store实例中数组对应索引的值。这时getters
属性返回的是一个函数，利用到了函数式编程中的高阶函数特性。

与mapState方法相同，为了组件中方便编写计算属性，计算属性中使用getter属性时，可以使用
mapGetters方法。

3. mutations
类似于flux架构的dispatcher.(但只是其一部分, 另一部分为下面的action)
在store中定义mutations相当于注册了事件，mutation方法名为事件类型type, 具体方法为事件的
回调函数。在组件中使用this.$store.commit('mutationType').触发对应type的事件。

mutation handler接受state作为第一个参数，我们自己需要传递的参数可以加在后面(payload). 
对应的，组件中commit时第一个参数是事件类型type, 后面的参数可以写需要传递的payload参数，
还可以整体写为对象的形式， 即
```txt
this.$store.commit({
  type: 'typeName',
  payloadName: payloadValue
})
// 以下这种写法传递的payload是一个对象，store.mutations定义中接收时需要按对象处理
this.$store.commit('typeName', {
  payloadName: payloadValue
})
```
注: 可以将mutationTypes统一提取为常量，方便管理。
mutation中定义的方法都必须是同步方法，因为mutation的设计作用是对状态进行快照处理, 如果
它本身的定义中使用了异步方法,将无法实现该作用.

4. action
对于异步操作方法, 我们应将其提取到action中, 在action中使用异步方法commit mutation, 组件中
不能直接操作mutation, 改为操作相应的action方法.

action本身使用context代替store对象, 它有与store相同的方法和属性.即调用
context.commit('mutationType')进行处理. 这时可以使用es6的参数解构写法省略context对象, 
直接为commit('type').

组件中使用this.$store.dispatch('actionType').这里action带上参数payload的形式和mutation是
相同的.同样它也提供了mapActions辅助方法, 但个人认为, mapXXX可读性和实用性都不强, 不建议使用.

action方法之间同getters一样可以组合起来使用, 形成进一步更复杂的处理逻辑. 这是因为
store.dispatch('actionType')返回的是promise, 根据promise的特性可以使用如
store.dispatch('actionA').then(...)的方式调用下一个action. 
如果想进一步控制promise的同步进行, 还可以将action定义为async方法,通过await关键字先行
完成调用另一个action.

5. module
对于复杂的应用, 一个根store记录所有的状态会导致state, mutations, getters, actions变得非常
臃肿, 这时可以将该store拆分为模块.每个模块都有自己的state, mutations等属性. 这些属性默认
是全局命名的,如果想区分开, 可以设置namespaces: true. 
模块内部还可以访问rootState等全局属性.
如果想定义一个模块的多个实例, 可以像组件的data属性一样, 将其变为一个函数.
这种处理本质上就是用方法代替属性, 从而实现不同实例状态的分隔:
```txt
const obj = {place: 'default', data: {place: 'china'}};
变为
const ob2 = {place: 'default', data: function(place){return {place: this.place}}};
测试如下:
const a = obj;
const b = obj;
b.data;
a.data.place = 'usa';
b.data;  // usa

const c = ob2;
const d = ob2;
c.data('usa');  // default  this指向c对象
c.data.call({place: 'usa'}) // usa 明确绑定this对象

const ob3 = {place: 'default', data: place => {return {place: this.place}}}; //undefined
// 箭头函数不能作为方法定义 
// 这个例子中应避免使用this指针, 组件中的this指向当前组件实例
const ob3 = {data: function(pl){return {place: pl}}};
```

#### 项目结构
略
#### 插件  
略
#### 严格模式 
如果发生了除mutation函数以外的状态变更将会报错, 这样利于调试.
但只应当在开发环境下开启.
#### 表单处理
当同时使用store的strict mode和v-model时, 如果v-model绑定的是store.state中的属性, 由于
v-model不是通过mutation改变的状态, 所以会报错.这时有2种办法:
1. `:value='x' @input='updateX'`, 这比简单的使用组件局部状态data要麻烦, 不推荐使用.
2. 使用计算属性的get, set方法双向绑定. 经测试, 这样做虽然很简洁, 但是计算属性值每次变化
都会触发mutation方法, 无法控制. vue教程中使用watch通过lodash通过停止操作的时间进行控制.
实用性不强. 所以,还是应当使用组件局部状态data.

#### 测试
略

## eslint 
1. npm i -D eslint eslint-plugin-vue
2. 根目录下新建.eslintrc.js文件, 写入
```txt
module.exports = {
  extends: [
    "plugin:vue/essential"
  ]
}
```
3. 修改package.json文件,加入eslint命令`eslint --ext .js,.vue src`.

## 单元测试
略
## element-ui theme
1. webpack中需要引入对字体文件的处理.
2. 全局引入element-ui. main.js中写入以下3行即可.
```txt
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';

Vue.use(ElementUI);
```

## java + vue Element 前后端分离独立项目 图形验证码的坑
use java to generate image (java awt) is easy, save the image text to session and return 
the image to frontend, frontend directly use src = interface to show the image is also 
straight-forward, then frontend use post method to request the server to login or add data, 
now the server needs to check the code, it needs to get the image text from session to 
compare it with post data text. And now comes the bug. 

the front and backend separated projects' session is different with the old one, even use
get method to get image, the jsessionid is different. After one day's searching and testing,
I finally fixed the bug:

1. do not use localhost with frontend service to test, as it will trigger cors problem,
the request will generate different session.

2. with front and backend separated projects, we need config axios withCredentials = true,
in this way, the request head will contain cookie,and cookie actually saves sessionid, 
so we can get our image generated session and get the text there!
```txt
import axios from 'axios'
var service = axios.create({
      baseURL: 'http://xxx:xxx:xxx:xxx:8200/resCenter', // api的base_url
      // timeout: 5000 // 请求超时时间
      withCredentials: true
})
export default service
```




<hr />
<img src="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20191119_1.jpg" class="full-image" />
