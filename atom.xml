<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TaoBlog</title>
  
  <subtitle>Sharing makes us better</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.taoblog.cn/"/>
  <updated>2020-05-28T08:39:38.000Z</updated>
  <id>http://www.taoblog.cn/</id>
  
  <author>
    <name>吴涛涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ModernJavaInActionNote</title>
    <link href="http://www.taoblog.cn/post/896258ed/"/>
    <id>http://www.taoblog.cn/post/896258ed/</id>
    <published>2020-05-12T23:08:24.000Z</published>
    <updated>2020-05-28T08:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>just the title<br><a id="more"></a></p><h2 id="part1-general"><a href="#part1-general" class="headerlink" title="part1 general"></a>part1 general</h2><h3 id="Java-9-to-11"><a href="#Java-9-to-11" class="headerlink" title="Java 9 to 11"></a>Java 9 to 11</h3><p>programming language climate changes</p><ol><li>programmers need to deal with big data, it need to use the multicore cpu and parallel<br>computing.  (stream api)</li><li>integrate old large subsystem with the new system (java9 module system and interface<br>default method)</li></ol><p>stream processing<br>   like unix pipeline commands or sql query, stream use concurrent processing.<br>behavior parameterization<br>   将方法作为参数<br>并行和共享的可变更数据<br>   需要并行处理时每一个操作步骤都必须是纯方法，无副作用或无状态方法。<br>   并发处理中使用synchronized性能损失非常大<br>使用java8 提高了java 程序员的竞争力</p><p>funtion和整型，对象引用等一样是一等公民 类也可以是(在js中已实现)<br>方法引用： 如 new File(“.”).listFiles(File::isHidden);<br><strong>方法引用和对象引用一样，方法和对象都是值, 方法作为值进行传递</strong><br>    在方法引用以前，需要传递方法只能将方法包裹在一个实例对象(匿名内部类)中进行传递, 现在<br>    可以直接传递方法。<br>方法引用只支持具名函数，即有名字的方法，没名字的只能使用匿名函数，或者lambda表达式。</p><p><strong>和对象使用接口类型进行传递一样，方法可以使用函数式接口(functional interface)进行传递</strong><br>如Predicate, Supplier, Consumer等，顶层是Function接口</p><p>低频使用’方法值’是lambda表达式，多次或’方法值’很长就需要方法引用语法</p><p>use stream.collect(groupingBy(Cst::getSliceTime)) to group a list with sliceTime<br>将展开的结果列表分组聚合，特别适用于树形数据的聚合！</p><p>自己使用for循环逐个遍历处理是外部遍历，使用stream不具体处理遍历过程是内部遍历<br>stream利用了多核cpu的并行计算能力。</p><p>list.stream().filter(…).collect(Collectors.toList());<br>和<br>list.parallelStream().filter(…).collect(Collectors.toList());<br>性能差异, 后者随着测试数据量增大和中间操作步骤增多, 性能优势体现明显.<br>注: 并行执行要求无共享的可变状态对象 mutable shared state</p><p><code>optional&lt;T&gt;</code> can avoid null pointer exception</p><p>pattern matching:  can decompose type object to its components,such as<br><code>obj instanceof String s</code><br><code>switch(obj) case String s: ...; Double d: ...</code><br>    // also called visitor patterns, walk through a family classes and do sth to each one</p><h3 id="passing-code-with-behavior-parameterization"><a href="#passing-code-with-behavior-parameterization" class="headerlink" title="passing code with behavior parameterization"></a>passing code with behavior parameterization</h3><h4 id="经常变动的需求"><a href="#经常变动的需求" class="headerlink" title="经常变动的需求"></a>经常变动的需求</h4><p>挑选苹果<br>  绿色, 红色 -&gt; color parameter<br>  轻重   -&gt; weight parameter<br> 以上条件有重复的模板代码, 如果需要优化挑选的代码性能, 需要修改每一个方法!</p><p> 本质需求:输入是一个苹果, 根据苹果的某些性质输出一个boolean值, 所以可以采用策略模式, 将其<br> 定义为一个接口类型predicate, 应用方法接受该接口作为参数进行处理.</p><h4 id="real-examples"><a href="#real-examples" class="headerlink" title="real examples"></a>real examples</h4><ol><li><p>comparator<br><code>Collections.sort(cstDtos, Comparator.comparing(CstDto::getBeginDate));</code></p></li><li><p>java.lang.Runnable<br>// because thread.run method is void run(), no parameters and no return value<br><code>Thread t = new Thread(() -&gt; System.out.println(&quot;hello&quot;));</code> </p></li><li><p>java.util.concurrent.Callable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Callable is also a functional interface,  it has V call()</span><br><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">Future&lt;String&gt; threadName = executor.submit(() -&gt; Thread.currentThread.getName());</span><br></pre></td></tr></table></figure></li><li><p>gui event handler<br>void handle(ActionEvent event){}<br>代码略</p></li></ol><h3 id="lambda-expression"><a href="#lambda-expression" class="headerlink" title="lambda expression"></a>lambda expression</h3><h2 id="part2-stream"><a href="#part2-stream" class="headerlink" title="part2 stream"></a>part2 stream</h2><h2 id="part3-lambda-and-stream"><a href="#part3-lambda-and-stream" class="headerlink" title="part3 lambda and stream"></a>part3 lambda and stream</h2><h2 id="part4-everyDay-Java"><a href="#part4-everyDay-Java" class="headerlink" title="part4 everyDay Java"></a>part4 everyDay Java</h2><h2 id="part5-concurrency"><a href="#part5-concurrency" class="headerlink" title="part5 concurrency"></a>part5 concurrency</h2><h2 id="part6-function-programming-and-java-future"><a href="#part6-function-programming-and-java-future" class="headerlink" title="part6 function programming and java future"></a>part6 function programming and java future</h2><p>##</p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20200513_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;just the title&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.taoblog.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.taoblog.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>DockerNote</title>
    <link href="http://www.taoblog.cn/post/b53499ee/"/>
    <id>http://www.taoblog.cn/post/b53499ee/</id>
    <published>2020-04-29T23:48:09.000Z</published>
    <updated>2020-12-21T00:58:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker and Kubernetes note<br><a id="more"></a></p><h2 id="App-note"><a href="#App-note" class="headerlink" title="App note"></a>App note</h2><p>下面是开发时需要用到的环境配置, 从最底层<br>os:<br>input method: sougou/fcitx<br>xmonad/amethyst<br>autohotKey karabiner/cmder/Context schroo/listary/<br>fish shell<br>…</p><p>init:<br>vim  .vimrc<br>git   username, email<br>jdk   path<br>maven  settings<br>idea   ideaSettings or ideaConfig dir</p><p>container(docker):<br>mysql/oracle<br>redis<br>rocketMQ<br>tomcat</p><h2 id="Mariadb"><a href="#Mariadb" class="headerlink" title="Mariadb"></a>Mariadb</h2><p>按照docker hub上的文档说明启动容器，需要加上端口映射 -p 3306:3306<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mydb -v /Users/wutaotao/stuff/mysqlData:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xxx -p 3306:3306 -d mariadb</span><br></pre></td></tr></table></figure></p><h2 id="oracle"><a href="#oracle" class="headerlink" title="oracle"></a>oracle</h2><p>docker hub和github上的image都可以使用，按对应文档启动容器即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker hub</span><br><span class="line">docker run -d -it --name oracle -v /Users/wutaotao/stuff/oracleData:/ORCL -p 1521:1521 -p 5500:5500 store/oracle/database-enterprise:12.2.0.1</span><br><span class="line"></span><br><span class="line">quay.io/maksymbilenko/oracle-12c github</span><br><span class="line">docker run -d -p 1521:1521 -v /Users/wutaotao/stuff/oracleData/:/u01/app/oracle quay.io/maksymbilenko/oracle-12c</span><br></pre></td></tr></table></figure></p><h2 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo</span><br><span class="line">docker run --name mongo -p 27017:27017 -v /Users/wutaotao/stuff/mongodb:/data/db -d mongo --auth</span><br><span class="line"></span><br><span class="line">// enter into container</span><br><span class="line">docker exec -it mongo /bin/bash</span><br><span class="line">mongo   //or mongo --port 27017  </span><br><span class="line"></span><br><span class="line">// create admin</span><br><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: &quot;admin&quot;,</span><br><span class="line">    pwd: passwordPrompt(), // or cleartext password</span><br><span class="line">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125;, &quot;readWriteAnyDatabase&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">exit   // exit mongo shell</span><br><span class="line">mongo -u &apos;admin&apos; -p &apos;admin&apos; --authenticationDatabase &apos;admin&apos;</span><br><span class="line">// or auth after connected </span><br><span class="line">mongo</span><br><span class="line">use admin  // change database</span><br><span class="line">show dbs  // nothing</span><br><span class="line">db.auth(&apos;admin&apos;, &apos;admin&apos;)</span><br><span class="line">show dbs  // successfully show dbs</span><br><span class="line"></span><br><span class="line">// add extra user wtt with auth to database vue</span><br><span class="line">ues vue</span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: &quot;wtt&quot;,</span><br><span class="line">    pwd:  passwordPrompt(),   // or cleartext password</span><br><span class="line">    roles: [&#123; role: &quot;readWrite&quot;, db: &quot;vue&quot; &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">exit</span><br><span class="line">docker exec -it mongo mongo -u &apos;wtt&apos; -p &apos;wtt&apos; --authenticationDatabase &apos;vue&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mongo university atlas learning cluster</span><br><span class="line">docker exec -it mongo mongo &quot;mongodb+srv://cluster0-jxeqq.mongodb.net/test&quot; --username m001-student -password m001-mongodb-basics</span><br><span class="line"></span><br><span class="line">atlas 是数据库服务平台，多个服务实例复制相同的数据实现可用性，每个集群只有一个主服务.</span><br><span class="line">database - collection</span><br><span class="line">database.collection 构成了命名空间 </span><br><span class="line">这里感觉collection和表的概念差不多，后面再验证</span><br><span class="line"></span><br><span class="line">show dbs</span><br><span class="line">use video</span><br><span class="line">show collections  -- collectionName is movies</span><br><span class="line">db.movies.find().pretty()   -- db.collectionName.find().pretty()</span><br><span class="line"></span><br><span class="line">create atlas account and use free tier</span><br><span class="line">all ip whitelist and database users(admin rights)</span><br><span class="line">download the load.js file</span><br><span class="line">move the load.js file to the host mongodb directory for docker to use, inside</span><br><span class="line">mongo container the mapped location(as above commannd) is /data/db</span><br><span class="line"></span><br><span class="line">docker exec -it mongo /bin/bash</span><br><span class="line">mv /db/load.js /home/</span><br><span class="line">mongo &quot;mongodb+srv://sandbox-pbr9e.mongodb.net/test&quot; --username wtt </span><br><span class="line">enter password  (ignore log warn)</span><br><span class="line">load(&apos;/home/load.js&apos;)   // return true</span><br><span class="line"></span><br><span class="line">use video</span><br><span class="line">create collection test in compass</span><br><span class="line">db.test.insertOne(&#123;name: &apos;wtt&apos;, age: 30, salary: 2333.44&#125;)</span><br><span class="line">//  `each _id value is unique in each collection, like table primary key`</span><br><span class="line">// default ordered is true, so when error reported, mongodb will not insert any more</span><br><span class="line">`db.test.insertMany([&#123;_id: &apos;001&apos;,name: &apos;wtt&apos;, age: 30, salary: 2333.44&#125;,</span><br><span class="line">&#123;_id: &apos;001&apos;,name: &apos;wtt&apos;, age: 30&#125;, &#123;name: &apos;test&apos;&#125;])`</span><br><span class="line"></span><br><span class="line">// when ordered is false, it will insert any data that is good</span><br><span class="line">`db.test.insertMany([&#123;_id: &apos;001&apos;,name: &apos;wtt&apos;, age: 30, salary: 2333.44&#125;,</span><br><span class="line">&#123;_id: &apos;001&apos;,name: &apos;wtt&apos;, age: 30&#125;, &#123;name: &apos;test&apos;&#125;], &#123;ordered: false&#125;)`</span><br><span class="line"></span><br><span class="line">query</span><br><span class="line">db.collectionName.find().pretty()</span><br><span class="line">db.collectionName.find(&#123;&apos;name&apos;: &apos;wtt&apos;&#125;).pretty()</span><br><span class="line">// hierarchical query using dot notation and quote the key to query</span><br><span class="line">db.collectionName.find(&#123;&apos;wind.direction.angle&apos;: 999&#125;).pretty()</span><br><span class="line"></span><br><span class="line">lab answer:</span><br><span class="line">db.movieDetails.find(&#123;&apos;awards.wins&apos;: 2, &apos;awards.nominations&apos;: 2&#125;).count()</span><br><span class="line">db.movieDetails.find(&#123;&apos;rated&apos;: &apos;PG&apos;, &apos;awards.nominations&apos;: 10&#125;).count()</span><br><span class="line"></span><br><span class="line">**mongo shell: ctrl + u is clearing the input text**</span><br><span class="line">**mongodb中document和object是相同的意思，即文档类型就是Object对象类型**</span><br><span class="line"></span><br><span class="line">array query</span><br><span class="line">// match the whole array</span><br><span class="line">db.coll.find(&#123;&apos;array&apos;: [&apos;a&apos;, &apos;b&apos;]&#125;).pretty()</span><br><span class="line"></span><br><span class="line">// match one of the array elements, with a included</span><br><span class="line">db.coll.find(&#123;&apos;array&apos;: &apos;a&apos;&#125;).pretty()</span><br><span class="line"></span><br><span class="line">// match a at the specific position</span><br><span class="line">db.coll.find(&#123;&apos;array.1&apos;: &apos;a&apos;&#125;).pretty()</span><br><span class="line"></span><br><span class="line">find()方法返回的是一个迭代器, mongo shell中默认每次迭代展示20条记录</span><br><span class="line">find()方法可以传递第二个参数，对返回的结果集中的字段进行限定，类似select语句的限定字段，</span><br><span class="line">它叫projection, 值为0代表不包含，1代表包含, `_id`默认是包含的</span><br><span class="line">`db.coll.find(&#123;&apos;array.1&apos;: &apos;a&apos;&#125;, &#123;title: 1, _id: 0&#125;).pretty()`</span><br><span class="line"></span><br><span class="line">updateOne</span><br><span class="line">db.coll.updateOne(&#123;</span><br><span class="line">  title: &apos;test&apos;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  $set: &#123;user: &apos;ss&apos;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">// updateOne will update only the first record matching the title = test, usually we</span><br><span class="line">pass the `_id` to get the only one record needed to be update once.</span><br><span class="line">// the second argument is the newItem, it will add new field if the old one do not exist</span><br><span class="line">or update the old field if it existed</span><br><span class="line"></span><br><span class="line">update other operators</span><br><span class="line"></span><br><span class="line">// $set   update or add fields</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $set: &#123;</span><br><span class="line">       updateBy: &apos;wtt&apos;,</span><br><span class="line">       updateTime: &apos;20200518&apos;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">// unset     remove fields, value can be anything, do not matter</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $unset: &#123;</span><br><span class="line">       updateBy: &apos;xx&apos;,</span><br><span class="line">       updateTime: &apos;xx&apos;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">// $rename  rename fields name</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $rename: &#123;</span><br><span class="line">       updateBy: &apos;newUpdate&apos;,</span><br><span class="line">       updateTime: &apos;newUpdateTime&apos;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;)</span><br><span class="line">// $inc $max $min $mul   used for numeric field values to increase some number</span><br><span class="line">// or get the maxValue of the old, new one,  get the minValue of the old, new one</span><br><span class="line">// multiply the value by set value</span><br><span class="line"></span><br><span class="line">// $currentDate</span><br><span class="line">// the result gets updateBy: ISODate(&quot;2020...&quot;)</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $currentDate: &#123;</span><br><span class="line">       updateBy: true,</span><br><span class="line">       updateTime: true</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;)</span><br><span class="line">// this gets the same result</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $currentDate: &#123;</span><br><span class="line">       updateBy: &#123;$type: &apos;date&apos;&#125;,</span><br><span class="line">       updateTime: &#123;$type: &apos;date&apos;&#125;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;)</span><br><span class="line">// this gets timeStamp result</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $currentDate: &#123;</span><br><span class="line">       updateBy: &#123;$type: &apos;timestamp&apos;&#125;,</span><br><span class="line">       updateTime: &#123;$type: &apos;timestamp&apos;&#125;</span><br><span class="line">      &#125; </span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">// array</span><br><span class="line">// **mongodb 作用最大的树级结构数据存储，嵌套属性是必须的，所以array update 操作符很实用**</span><br><span class="line">// push to an  array, it will create the array field if not existed</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $push: &#123;</span><br><span class="line">      myArr: &#123;</span><br><span class="line">        name: &apos;wtt&apos;,</span><br><span class="line">        age: 30,</span><br><span class="line">        sex: &apos;M&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">// push many items once to an array</span><br><span class="line">// using $each modifier, its value is an array below</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $push: &#123;</span><br><span class="line">      myArr: &#123;</span><br><span class="line">        $each: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;wtt&apos;,</span><br><span class="line">            age: 30,</span><br><span class="line">            sex: &apos;M&apos;</span><br><span class="line">          &#125;, </span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;cll&apos;,</span><br><span class="line">            age: 27,</span><br><span class="line">            sex: &apos;F&apos;</span><br><span class="line">          &#125;, </span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;wwt&apos;,</span><br><span class="line">            age: 25,</span><br><span class="line">            sex: &apos;M&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">// pop  pop expects 1 or -1</span><br><span class="line">// 1 means the last item, -1 means the first item</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $pop: &#123;</span><br><span class="line">      myArr: -1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">// $pull</span><br><span class="line">// remove all items of myArr whose sex is M</span><br><span class="line">// pull use query condition</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $pull: &#123;</span><br><span class="line">      myArr: &#123;</span><br><span class="line">        &quot;sex&quot;: &quot;M&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">// $pullAll remove items in a list from an array</span><br><span class="line">// useful with repeated elements in an array</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   title: &apos;Star Trek&apos;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $pullAll: &#123;</span><br><span class="line">      myArr: [&#123;...&#125;, &#123;...&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">// updateMany</span><br><span class="line">// batch update many documents</span><br><span class="line">db.movieDetails.updateMany(&#123;</span><br><span class="line">  &quot;awards.wins&quot;: 2</span><br><span class="line">   &#125;, &#123;</span><br><span class="line">  $inc: &#123;</span><br><span class="line">     &quot;awards.wins&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// upset</span><br><span class="line">// 类似saveOrUpdate, 条件不满足时新增document</span><br><span class="line">db.movieDetails.updateOne(&#123;</span><br><span class="line">   &quot;id&quot;: detail.id</span><br><span class="line">&#125;, &#123;</span><br><span class="line">      $set: detail</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    upsert: true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">**mongo shell实际上是js解析器，同console类似，可以在上面执行js语句**</span><br><span class="line">// replaceOne命令与updateOne类似，但它替换的是整个匹配到的document对象</span><br><span class="line">let filter = &#123;title: &apos;Wild Wild West&apos;&#125;</span><br><span class="line">let doc = db.movieDetails.findOne(filter)   // 不能使用find()方法</span><br><span class="line">doc.updatedBy = &apos;wtt&apos;</span><br><span class="line">db.movieDetails.replaceOne(filter, doc)   // update succeed</span><br><span class="line"></span><br><span class="line">// deleteOne</span><br><span class="line">// deleteMany</span><br><span class="line"></span><br><span class="line">query operators</span><br><span class="line">$eq $gt $gte $lt $lte  $ne(not equal include field do not exist at all)</span><br><span class="line">$in $nin(the value type is an array)</span><br><span class="line"></span><br><span class="line">// use $in to judge the array contains a or b</span><br><span class="line">db.movieDetails.find(&#123;writers: &#123;$in: [&apos;a&apos;, &apos;b&apos;]&#125;&#125;).count()</span><br><span class="line">// arrayName: [] match the overall array, and arrayName: &#123;&#125; judges the array elements</span><br><span class="line"></span><br><span class="line">//element query operators</span><br><span class="line">$exists   filter a field exists in documents  &#123;name: &#123;$exists: true&#125;&#125;</span><br><span class="line">$type   filter a specific type field in documents  &#123;name: &#123;$type: bool&#125;&#125;</span><br><span class="line">// &#123;name: null&#125; will get the null value field documents and non-existed field documents</span><br><span class="line"></span><br><span class="line">//logical operators</span><br><span class="line">$or   selectors only need one is true, value is an array, contains all selectors</span><br><span class="line">     db.test.find(&#123;$or: [&#123;&apos;sex&apos;: &apos;m&apos;&#125;, &#123;&apos;age&apos;: 30&#125;]&#125;)  // sex is man or age = 30</span><br><span class="line"></span><br><span class="line">$and   because filtors are default and, so $and is used for same field name needing to be used</span><br><span class="line">      more than once:</span><br><span class="line">        db.test.find(&#123;$and: [&#123;&apos;name&apos;: &#123;$ne: null&#125;&#125;, &#123;&apos;name&apos;: &#123;exists: true&#125;&#125;]&#125;)</span><br><span class="line">         //  find documents whose name value is not null and does exist</span><br><span class="line"></span><br><span class="line">// array operators</span><br><span class="line">$all  &#123;arrayName: &#123;$all: [&apos;b&apos;, &apos;c&apos;]&#125;&#125;</span><br><span class="line">  // need the array contains b and c element</span><br><span class="line"></span><br><span class="line">$size  &#123;arrayName: &#123;$size: 2&#125;&#125;</span><br><span class="line">  // match the array whose size is 2</span><br><span class="line"></span><br><span class="line">$elemMatch  </span><br><span class="line">    // this query only need the array contains an item whose name = wtt, and contais</span><br><span class="line">    // another item&apos;s age = 30, do not need to be the same item</span><br><span class="line">   db.test.find(&#123;arrayName: &#123;&apos;name&apos;: &apos;wtt&apos;, &apos;age&apos;: 30&#125;&#125;)</span><br><span class="line"></span><br><span class="line">   // when we need the same item to be matched, use $elemMatch</span><br><span class="line">   // $elemMatch match for one item, so it uses &#123;&#125;(like document) to get result</span><br><span class="line">   db.test.find(&#123;arrayName: &#123;$elemMatch: &#123;&apos;name&apos;: &apos;wtt&apos;, &apos;age&apos;: 30&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">$regex</span><br><span class="line">   // 想想可以在sql中使用正则表达式！</span><br><span class="line">   // mysql  regexp 关键字(同like类似)</span><br><span class="line">   // `select * from my_user where name regexp &apos;^[0-9]&#123;3&#125;$&apos;`</span><br><span class="line">   // oracle中有`regexp_like, regexp_instr, regexp_substr, regexp_replace`关键字</span><br><span class="line">   // use regular expression for text string match</span><br><span class="line">可以写为 db.test.find(&#123;name: &#123;$regex: &apos;pattern&apos;, $options: &apos;options&apos;&#125;&#125;)</span><br><span class="line">或 db.test.find(&#123;name: &#123;$regex: /pattern/options&#125;&#125;)</span><br><span class="line">或最简单实用的 直接省略$regex关键字</span><br><span class="line">db.test.find(&#123;name: /pattern/options&#125;)  </span><br><span class="line">  //在某些场景下必须使用$regex或必须使用/pattern/语法, 具体见文档</span><br></pre></td></tr></table></figure><h2 id="ubuntu-in-docker"><a href="#ubuntu-in-docker" class="headerlink" title="ubuntu in docker"></a>ubuntu in docker</h2><ol><li>docker pull ubuntu   // 现在默认是20.04 LTS版本</li><li>docker run –name ubuntu -v /Users/wutaotao/stuff/ubuntu/:/home/ \<br>-it -e LANG=C.UTF-8 -e LC_ALL=C.UTF-8 ubuntu </li><li>apt update</li><li>apt install vim</li><li><p>cp /etc/apt/sources.lst /etc/apt/sources.lst.bak<br>vim /etc/apt/sources.list<br>// 20.04的源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></li><li><p>apt install git curl </p></li><li>adduser tao</li><li>apt install sudo -y</li><li>passwd  // change root user passwd</li><li><code>echo &quot;Set disable_coredump false&quot; &gt;&gt; /etc/sudo.conf</code>  // fix the sudo warning bug  </li><li>su - tao</li><li>sudo ls   // check sudo command, first time need to input password </li><li>git clone <a href="https://github.com/VundleVim/Vundle.vim.git" target="_blank" rel="noopener">https://github.com/VundleVim/Vundle.vim.git</a> ~/.vim/bundle/Vundle.vim</li><li>copy .vimrc</li><li>:PluginInstall </li><li>sudo apt install fcitx fcitx-pinyin  // need gui to config fcitx, let’s do this!</li><li><p>in mac terminal:(version 10.15.2 catalina)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">brew cask install xquartz</span><br><span class="line">open -a XQuartz</span><br><span class="line">check security - allow connect from network</span><br><span class="line">brew install socat</span><br><span class="line">// login as tao, not root</span><br><span class="line">docker exec -it ubuntu /bin/bash -c &apos;su - tao &amp;&amp; /bin/bash&apos;</span><br><span class="line">vi .bash_profile</span><br><span class="line">// export EDITOR=/usr/bin/vim</span><br><span class="line">// export DISPLAY=192.168.x.x:0  # the host machine&apos;s ip</span><br><span class="line">// export LANG=C.UTF-8</span><br><span class="line">exit</span><br><span class="line">docker stop ubuntu</span><br><span class="line">docker start ubuntu</span><br><span class="line">// with xquartz opened, install socat and start it to connect xquartz and docker eontainer</span><br><span class="line">brew install socat</span><br><span class="line">socat TCP-LISTEN:6000,reuseaddr,fork UNIX-CLIENT:\&quot;$DISPLAY\&quot; &amp;</span><br></pre></td></tr></table></figure></li><li><p>docker exec -it ubuntu /bin/bash -c ‘su - tao &amp;&amp; /bin/bash’<br>fcitx-configtool</p></li><li>open xquartz, use command + alt + a to show its window</li><li><strong>input method list is empty, and fcitx error</strong></li><li>sudo apt remove fcitx fcitx-pinyin</li><li>sudo apt autoremove</li><li>sudo apt autoclean</li></ol><p>由以上测试可以看出，docker ubuntu想要完全替代虚拟机还是不可行的，但我只是想用ubuntu里的<br>fcitx-vim插件方便在vim中输入中文而已(因为上面记载的mac版fcitx-vim插件有bug)，<br>然后我发现了下面这个插件: <strong>vimIM</strong>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">brew install wget</span><br><span class="line">// download the specific version berkeley-db and manual make it accessible to homebrew</span><br><span class="line">sudo su -</span><br><span class="line">wget http://download.oracle.com/berkeley-db/db-6.1.26.tar.gz</span><br><span class="line">tar xvf db-6.1.26.tar.gz</span><br><span class="line">cd db-6.1.26/build_unix</span><br><span class="line">mkdir -p /usr/local/Cellar/berkeley-db/6.1.26</span><br><span class="line">../dist/configure --prefix=/usr/local/Cellar/berkeley-db/6.1.26</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">// ctrl + d exit to normal user</span><br><span class="line">brew link berkeley-db</span><br><span class="line"></span><br><span class="line">sudo su -</span><br><span class="line">easy_install pip</span><br><span class="line">YES_I_HAVE_THE_RIGHT_TO_USE_THIS_BERKELEY_DB_VERSION=1 BERKELEYDB_DIR=/usr/local/Cellar/berkeley-db/6.1.26 pip install bsddb3</span><br><span class="line"></span><br><span class="line">// ctrl + d exit to normal user</span><br><span class="line">// edit .vimrc and add vimIM plugin to vundle</span><br><span class="line">// but when in insert mode, after ctrl /, vim报错找不到模式，个人感觉是词典的问题。而且</span><br><span class="line">// vimIM不一定有我想要的小鹤双拼输入法。</span><br><span class="line"></span><br><span class="line">// 后来github上找到一个基于小鹤双拼的vimIM插件修改版，经测试可以使用，但是它的词库</span><br><span class="line">// 选词太少了，又在网上找到一个小鹤双拼的词库，稍微多一点，但还是容量有限，感觉没有</span><br><span class="line">// 真正的小鹤双拼输入法好用。这时找到emacs编辑器中有个pyim的插件可以完美解决中英文输入的</span><br><span class="line">// 问题，试试吧。</span><br><span class="line">// 具体的emacs实验过程转移到vim tips文章。</span><br></pre></td></tr></table></figure></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>docker image ls<br>docker container ls -a<br>// -d daemon  -it iteractive terminal -name containerName -v datasource dir  -p port<br>docker run -d -it -name -v -p iamgeName</p><p>docker logs -f containerName<br>docker ps<br>// check container ip and ports info<br>docker inspect containerName<br>docker stop containerName<br>docker rm containerName<br>docker rmi imageId</p><h2 id="kubernete-install"><a href="#kubernete-install" class="headerlink" title="kubernete install"></a>kubernete install</h2><ol><li>install ubuntu 18.04 server vmware workstation guest system on win10<br>pay attention to the network setting, use bridged network to make it accessible to network</li><li>install docker using apt<br>add current user tao to usergroup docker, edit aliyun mirror</li><li>install kubectl using curl<br>move it to /usr/local/bin</li><li>install minikube using curl<br>install it to /usr/local/bin, verify it with minicube version</li><li>error: requires conntrack to be installed in root’s path<br>fix: sudo apt install conntrack<br>then run the command again<br>sudo minikube start –vm-driver=docker –image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</li><li>chown -R tao ~/.kube ~/.minikube  // use this to avoid using sudo<br>create a service to test the minicube:<br>kubectl create deployment hello –image=tomcat</li><li>kubectl expose deployment hello –type=NodePort –port=8080</li><li>kubectl get pod</li><li>minikube service hello –url<br>ps: kubectl bash completion set:<br><code>echo &#39;source &lt;(kubectl completion bash)&#39; &gt;&gt;~/.bashrc)</code><br>at this time, we visit the result url at win10 host machine, it returns 404</li><li>kubectl dashboard<br>we can use kubectl proxy to make the host to be able to visit dashboard:<br> kubectl proxy –address=’0.0.0.0’ –accept-hosts=’^*$’<br>and the output is stuck like using python httpServer, we can visit it with vmware url:<br> http://{vmware guest ip}:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/overview?namespace=default<br> ps: initial judgement is security reason, the tomcat webpage can not be visited, need<br> to be tested on archlinux with google chrome.</li><li>vmware tools install grey and disabled problem:<br>set the guest machine dvd, dvd2, software as hardware and auto-detect.<br>after clicking the reinstall button, use lsblk -f command to check it and mount it, execute<br>the vmware-install.pl script.</li></ol><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20200505_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker and Kubernetes note&lt;br&gt;
    
    </summary>
    
      <category term="Container" scheme="http://www.taoblog.cn/categories/Container/"/>
    
    
      <category term="Container" scheme="http://www.taoblog.cn/tags/Container/"/>
    
      <category term="Docker" scheme="http://www.taoblog.cn/tags/Docker/"/>
    
      <category term="K8s" scheme="http://www.taoblog.cn/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>VueNote</title>
    <link href="http://www.taoblog.cn/post/999fed8a/"/>
    <id>http://www.taoblog.cn/post/999fed8a/</id>
    <published>2019-11-19T09:23:01.000Z</published>
    <updated>2021-03-18T10:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>note on learning Vue<br><a id="more"></a></p><h2 id="官网教程"><a href="#官网教程" class="headerlink" title="官网教程"></a>官网教程</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>直接下载vue.js并在html中引用即可。这里使用的vue版本为2.6.10.</p><h3 id="声明式渲染，条件与循环等"><a href="#声明式渲染，条件与循环等" class="headerlink" title="声明式渲染，条件与循环等"></a>声明式渲染，条件与循环等</h3><p>数据可以绑定到DOM文本:如文本插值<code>{ { message }}</code>,<br>DOM属性: 如直接在html标签中使用指令v-bind:title=”eleTitle”改变鼠标悬停效果,<br>DOM结构: 如使用指令v-if=”seen”控制是否显示标签(控制结构时还可以提供fade in, out等其他动画效果)</p><p>v-for=”item in itemList”在li标签中的应用。<br>v-on:click=”afterClick”绑定点击事件为afterClick方法。<br>v-model=”message”为双向数据绑定。</p><p>可以通过如下方式自定义组件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;todo&apos;, &#123;</span><br><span class="line">  props: [&apos;prop1&apos;, &apos;prop2&apos;],</span><br><span class="line">  template: &apos;&lt;li&gt;&#123; &#123; prop1.text &#125;&#125;&lt;/li&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var ele = new Vue(&#123;</span><br><span class="line"> el: &apos;#ap5&apos;,</span><br><span class="line"> data: &#123;</span><br><span class="line">   list: [</span><br><span class="line">    &#123;id: 0, text: &apos;one&apos;&#125;,</span><br><span class="line">    &#123;id: 1, text: &apos;two&apos;&#125;,</span><br><span class="line">    &#123;id: 2, text: &apos;three&apos;&#125;</span><br><span class="line">   ]  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>自定义组件，使用时如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&apos;ap5&apos;&gt;</span><br><span class="line">  &lt;todo v-for=&quot;item in list&quot; v-bind:prop1=&quot;item&quot; v-bind:key=&quot;item.id&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到，自定义组件todo使用组件属性prop使得组件动态显示外界传递的数据内容。这与上面的<br>v-bind:title=”message”是一样的。</p><h3 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h3><p>在vue中，一个组件实际上是一个预定义的Vue实例。每个Vue实例可以接受多个选项。</p><ol><li>数据选项 data<br>当实例创建时，data选项中已经存在的属性会被加入到vue的响应式系统中，如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var dataSource = &#123;text: 1&#125;;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: dataSource </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>这时无论改变vm.text还是改变dataSource.text的值，另一个的值都会同步发生改变，即实现了数据<br>和视图的双向响应式变化。如果在vm实例创建后，对dataSource添加新属性是无法实现响应式变化的。</p><p>注: Object.freeze(dataSource)会阻止修改对象属性值。</p><p>实例属性和方法都有前缀$, 如vm.$el, vm.$data等。</p><p>实例提供了多个生命周期钩子，如created, mounted, updated, destroyed等，可以在选项中自定义<br>回调方法执行自定义操作。钩子的this关键字指向vue实例，避免使用箭头函数。</p><p>教程中给出了vue实例的整个生命周期流程，可以看到以下几点：</p><ol><li>如果没有指定el选项，可以使用vm.$mount(el)方法指定元素。</li><li>选项中如果有指定template模板，使用该模板进行渲染，否则就使用el的html标签进行渲染。这一点<br>也区分开了自定义组件和普通的html标签。</li><li>vue使用vm.$el替换原生的el标签实现虚拟DOM, 在此基础上实现响应式渲染。 </li></ol><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><ol><li>文本<br>双大括号为mustache语法，<code>{ { message }}</code>, 数据选项属性message发生变化，该文本值也会变化。<br>可以使用<code>&lt;p v-once&gt;{ { message }}&lt;/p&gt;</code>来实现一次性渲染.</li></ol><p>注: 类似document.getElementById().innerText = XXX;</p><ol start="2"><li>html标签<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&apos;ap6&apos;&gt;</span><br><span class="line">  &lt;p&gt;&lt;span v-html=&quot;sp&quot;/&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var ap6 = new Vue(&#123;</span><br><span class="line">  el: &apos;#ap6&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    sp: &apos;&lt;a style=&apos;color: red&apos;&gt;I am red&lt;/a&gt;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>对用户输入的内容使用html插值容易导致XSS攻击，应只对可信内容使用。</p><p>注: 类似<code>document.getElementById().innerHTML = &quot;&lt;x&gt;...&lt;/x&gt;&quot;;</code></p><ol start="3"><li><p>属性<br>同上面所说，标签属性的改变使用v-bind指令，如v-bind:disabled=”disableFlag”等, 其中disableFlag<br>必须为boolean值。</p></li><li><p>模板表达式<br>如<code>{ { num + 1}}</code>, <code>{ { ok ? &#39;yes&#39; : &#39;no&#39; }}</code>都会被当作js表达式解析，其中num作为v-model双向绑定时<br>是字符串类型，<code>{ {num+1}}</code>得到的是字符串的拼接。<br>模板表达式的解析是在沙盒中，只能访问如Math,Date等白名单对象，无法访问用户自定义全局变量，<br>访问时会报错该属性未定义。</p></li></ol><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>指令一般是作用于单个表达式，如v-on:click=’reverse’, v-if=’seen’等。</p><ol><li><p>参数<br>即指令名称冒号后的值，如v-bind:href=’url’, v-on:click=’reverse’中href, click都是参数，<br>等号后是参数值。</p></li><li><p>动态参数<br>如v-on:[event]=’dosth’, 其中event可以为一个js表达式，如实例中有一个数据属性为event,值为<br>focus, 那么它就等价为v-on:focus=’dosth’.通过这种形式，该标签就可以在不同时间以聚焦或点击<br>的不同动作调用相同的方法。(这种需求还是比较少见, 其他指令的参数动态性可能有点用)<br>动态表达式中不能有空格和引号，大写字母会被强制转换为小写。</p></li><li><p>修饰符<br>如v-on:submit.prevent=’sub’中参数submit后的.prevent指出该指令以特殊方式绑定，即调用<br>event.preventDefault()语句。</p></li></ol><h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><p>v-bind:href=’url’可以缩写为:href=’url’,<br>v-on:click=’dosth’可以缩写为@click=’dosth’.</p><h3 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h3><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>在模板表达式中写比较复杂的算式可读性不好，而且不方便复用。这时可以使用计算属性。如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123; &#123; reverseTxt &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">var ap7 = new Vue(&#123;</span><br><span class="line">  el: &apos;#ap7&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    txt: &apos;sdg&apos;  </span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    reverseTxt: function() &#123;</span><br><span class="line">      return this.txt.split(&apos;&apos;).reverse().join(&apos;&apos;);  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>计算属性与方法的不同在于计算属性自带缓存，当this.txt没有发生改变时，不会重新计算直接返回<br>缓存值。<br>计算属性与侦听器的不同在于计算属性可以同时监控多个属性的变化，而侦听器只能针对单个属性的变化<br>分别定义函数。<br>计算属性默认是get方法，即计算结果值由”监测”的属性计算得到，但也可以通过设置计算属性值反过来<br>设置监测的属性值。通过这种联动可以实现实例中属性的双向影响，感觉在某些场景中这种相互影响非常<br>实用。代码如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line"> reverseTxt: &#123;</span><br><span class="line">   get: function() &#123;</span><br><span class="line">      return this.txt.split(&apos;&apos;).reverse().join(&apos;&apos;);  </span><br><span class="line">   &#125;,</span><br><span class="line">   set: function(val) &#123;</span><br><span class="line">      this.txt = val.split(&apos;&apos;).reverse().join(&apos;&apos;);  </span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>侦听器在属性值发生变化时可以调用相应的函数，如发出ajax异步请求等。为防止请求过于频繁，教程中<br>使用lodash的debounce方法限制请求间隔，使用axios发出ajax请求。</p><h3 id="class与style绑定"><a href="#class与style绑定" class="headerlink" title="class与style绑定"></a>class与style绑定</h3><p>v-bind指令在设置标签的样式如class, style属性时除了字符串，还可以绑定一个对象或数组。</p><ol><li>class<br>传递对象:<br>如<code>&lt;p v-bind:class=&quot;{real: isReal, active: isActive}&quot;&gt;&lt;/p&gt;</code>,这个绑定的对象<br>除了可以在这里直接定义，还可以定义在实例的data选项属性中，或是计算属性中(更强大的控制)。</li></ol><p>其中，对象的属性名是具体的class名称，属性值是该class是否生效的boolean值。为truthy时该class<br>生效，为false时该class不生效。<br>注: <strong>js中除false, 0, “”, null, undefined, NaN以外，都是真值，即为truthy.</strong></p><p>实例中定义为<code>data: {isReal: true, isActive: false}</code>.</p><p>注: v-bind:class可以和普通的class属性共存。</p><p>传递数组:<br>比起使用boolean值控制class列表的对象语法，数组语法通过class列表的字符串数组进行控制，<br>如<code>v-bind:class=&quot;[aClass, bClass]&quot;</code>，同理，为实现控制，这里的aClass,bClass是实例的属性名，<br>实例中有<code>data: {aClass: &#39;a&#39;, bClass: &#39;b&#39;}</code>, a和b即为具体的class名称。当需要去除某个class时，<br>将对应属性值设置为’’即可。如果需要动态控制，可以在数组语法中嵌套使用对象语法，<br>如<code>v-bind:class=&#39;[{aClass: aflag}, bClass]</code>.</p><p>用在组件上:<br>在自定义组件中通过以上2种方式带数据绑定的class会追加到组件的根元素中，不会覆盖已有的class列表。 </p><ol start="2"><li>style<br>通过style绑定的是内联样式，直接指定样式，不需要中间的class层，适合样式少并分散的情况。</li></ol><p>对象语法:<br>如<code>v-bind:style=&quot;{color: acolor, fontSize: fs + &#39;px&#39;}&quot;</code>, 实例中定义<br><code>data: {acolor: &#39;red&#39;, fs: 30}</code>,<br>同样的，可以将该对象定义在实例data中，或使用计算属性。<br>如<code>v-bind:style=&quot;sty&quot;</code>, <code>data: {sty: {color: &#39;red&#39;, fontSize: &#39;30px&#39;}}</code>.</p><p>数组语法:<br>style的数组语法可以使用多个style对象进行控制，这里使用对象语法一个style对象即可以控制，<br>所以数组语法意义不大，就此略过。</p><p>自动添加前缀: 对于非标准的浏览器引擎CSS前缀，v-bind:style会自动添加前缀，可忽略。<br>多重值: style样式属性值除字符串外，还可以传递数组，vue会选择数组中最后一个支持的浏览器样式，<br>可忽略。</p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><ol><li>v-if<br>在单个标签中使用v-if=”seen”, 当seen为false时，刷新后该标签一闪而过后消失。应该是渲染的执行<br>顺序问题。当需要控制隐藏多个标签时，使用template标签并在其中使用v-if指令，发现没有出现闪烁<br>现象。</li></ol><p>v-if后可以使用v-else-if，v-else指令块控制多个元素的显式隐藏。要求必须相应的元素必须紧靠在<br>一起，否则无法识别。</p><p>当使用v-if切换2个template元素组时，vue会复用已经有的元素，这样在切换时会出现元素中已有的<br>值(如用户的输入值)不会被清空的情况。这时可以给这2个template中相同的元素设置key属性，相当于<br>指定了id, 通过设置不同的key值，vue就不会复用该元素。而未指定key时，vue将复用相同元素提高<br>渲染速度。</p><ol start="2"><li>v-show<br>v-show指令值为false时相当于style=’display:none”，所以v-show元素始终存在于dom中。</li></ol><p>注: v-if是真正的条件渲染，而且是惰性的(只有第一次为真时才开始渲染)，切换开销较大；而v-show<br>始终会渲染，初始开销大，但切换时只是CSS变换，切换开销小。<br>所以如果频繁切换应使用v-show, 切换较少时使用v-if.</p><p>注: 不应当在同一个元素内同时使用v-if和v-for指令，因为v-for指令优先级更高，这样当只需要渲染<br>其中一小部分元素时，却遍历了整个列表进行判断。这时应当使用计算属性过滤出需要的列表，对其<br>使用v-for指令渲染，这样更高效，而且将筛选逻辑解耦出来了(而且计算属性还自带缓存，可以复用)。</p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ol><li>渲染列表<br>v-for指令在li标签上使用可以渲染一个列表。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;item in items&quot;&gt;&#123; &#123; item.txt &#125;&#125;&lt;/li&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  items: [</span><br><span class="line">    &#123;txt: &quot;one&quot;&#125;,</span><br><span class="line">    &#123;txt: &quot;two&quot;&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>v-for还可以写为<code>v-for=&quot;(item, index) in items&quot;</code>, index为自动添加的索引。<br>还可以使用of代替in, 如<code>v-for=&quot;(item, index) of items&quot;</code>。</p><ol start="2"><li>v-for中使用对象<br>如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;value in obj&quot;&gt;&#123; &#123;value&#125;&#125;&lt;/li&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    title: &apos;tt&apos;,</span><br><span class="line">    name: &apos;ss&apos;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>同时显示对象属性名和值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;(value, name) in obj&quot;&gt;&#123; &#123;name&#125;&#125;: &#123; &#123;value&#125;&#125;&lt;/li&gt;</span><br><span class="line">或</span><br><span class="line">&lt;li v-for=&quot;(value, name, index) in obj&quot;&gt;&#123; &#123;index&#125;&#125;:&#123; &#123;name&#125;&#125;: &#123; &#123;value&#125;&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure></p><p>注: 模板表达式只能识别单个属性，<code>{ {name: value}}</code>会报错。<br>遍历顺序为Object.keys()结果。</p><ol start="3"><li><p>维护状态<br>同前面v-if的元素复用类似，v-for指令在未指定key时使用默认的”就地更新”策略，即不会主动更改<br>dom元素位置，而是更新每个元素值。这种模式很高效，但它只适用于输出的DOM非常简单的情况。<br>一般建议是在使用v-for指令时，同时使用v-bind:key=”item.id”值为每一个列表项指定id.<br>使用key后，会强制更新元素或组件而不是重复利用已有元素，适用于触发过渡效果。</p></li><li><p>数组更新检测<br>当v-for的数组内容发生变化时，对应的列表也会发生变化，数组变化的方法有<br>push, pop, shift, unshift, splice, sort, reverse.这些方法会改变原数组，而其他另外一些方法<br>如filter, concat, slice等没有改变原数组，这时如果想要重新渲染列表，可以使用计算属性，<br>在其中将得到的新数组替换原属性即可(vue会尽量复用已有DOM, 不会马上销毁原有DOM重新渲染)。</p></li></ol><p>注: 直接使用索引修改元素值如a[i] = 3和a.length = 3无法实现响应式更新。对于前者可以使用<br>Vue.set(vm.items, index, newValue)或vm.items.splice(index, 1, newValue),<br>对于后者可以使用vm.items.splice(newlength).</p><p>splice意思是拼接，splice(startIndex, deleteCount, item1, item2…)意为从startIndex(包括)开始删除<br>deleteCount个字符，并在相同位置插入元素item1, item2…, 该方法改变了原数组，方法的返回值是<br>被删除的元素数组。</p><ol start="5"><li>对象变更检测<br>前面说过，对于已经初始化完成的vue实例，后面再添加属性值是不支持响应式更新的。(即时支持<br>好像也没有实际作用)。但可以对属性对象进行修改。<br>如果添加单个属性可以使用<code>Vue.set(vm.obj, &#39;name&#39;, 29)</code>添加或修改属性，如果要添加多个时，<br>可以使用<code>vm.obj = Object.assign({}, vm.obj, {&#39;name&#39;:29, &#39;sex&#39;: &#39;m&#39;});</code><br>这里新建一个vm.obj对象而不是直接<code>Object.assign(vm.obj, {...})</code>的原因经网上搜索，说如果直接<br>修改vm对象，可能会导致基于vm的元素出现渲染问题，所以还是使用新对象较好。而且使用{}当vm.obj<br>对象为undefined时不会报错。即assign的源对象可以为undefined. </li></ol><p>注: Object.assign()复制的是属性值，为浅拷贝，如果需要深拷贝，可以json序列化后再解析，即<br>let copy = JSON.parse(JSON.stringify(source));</p><ol start="6"><li><p>显示过滤/排序后的结果<br>前面已经说过，需要过滤时应使用计算属性或方法对数组处理后再使用v-for指令渲染(直接使用v-if<br>性能低，耦合度高)。在使用v-for循环嵌套时，列表不是data属性(是数据内部的次级列表)，无法直接<br>访问所以不能使用计算属性，只能使用方法来处理。</p></li><li><p>v-for使用值范围<br><code>&lt;p v-for=&quot;n in 10&quot;&gt;{ {n}}&lt;/p&gt;</code>输出12345678910</p></li><li><p>template上使用v-for<br>对于一组需要多次重复的元素组，可以在template上使用v-for. 具体需求如表格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b4&quot;&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">              &lt;template v-for=&quot;row in rows&quot;&gt;</span><br><span class="line">                      &lt;tr&gt;</span><br><span class="line">                              &lt;td&gt;&#123; &#123;row.a&#125;&#125;&lt;/td&gt;</span><br><span class="line">                              &lt;td&gt;&#123; &#123;row.b&#125;&#125;&lt;/td&gt;</span><br><span class="line">                      &lt;/tr&gt;</span><br><span class="line">              &lt;/template&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var b4 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b4&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              rows: [</span><br><span class="line">                      &#123;a: &apos;11&apos;, b: &apos;12&apos;&#125;,</span><br><span class="line">                      &#123;a: &apos;21&apos;, b: &apos;22&apos;&#125;</span><br><span class="line">              ]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>组件上使用v-for<br>前面说过，组件中应使用key区分每个列表内元素保证渲染正确。同时组件有自己的作用域，需要使用<br>prop来传递数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li is=&quot;myComponent&quot; </span><br><span class="line">  v-for=&quot;(item,index) in list&quot; </span><br><span class="line">  :key = &quot;item.id&quot;</span><br><span class="line">  :content = &quot;item.text&quot;</span><br><span class="line">  @remove=&quot;list.splice(index, 1)&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li></ol><p>其中is=”myComponent”是因为html限制ul中只有li是有效标签，要在其中使用自定义元素myComponent<br>时，需要通过is进行标记。key为item.id, 组件props属性(数组)为<code>[&#39;content&#39;]</code>(即li标签显示内容),<br>赋值为item.text.最后是点击按钮触发remove事件时将数组中该项去除，这样会同步响应到视图中。</p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ol><li>内联语句<br>如v-on:click=”count += 1”可以让属性count自增1</li><li>绑定到方法<br>使用如v-on:click=”afterClicked”将动作绑定到实例方法，处理逻辑都在方法中定义。</li><li>内联语句中调用方法<br>如v-on:click=”say(‘oneClick’)”, 在内联语句中调用方法。此时可以用$event向方法中传入原生<br>DOM事件，如v-on:click=”say(‘oneClick’, $event)”.</li><li><p>事件修饰符<br>某些情况需要阻止事件的默认行为，如form表单提交的默认重载页面行为，一般是使用<br>event.preventDefault(), vue提供了修饰符简化该操作，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.stop 阻止事件继续传播 </span><br><span class="line">.prevent 阻止事件默认行为</span><br><span class="line">.capture 捕获内部元素事件，捕获处理完毕后再交还子元素</span><br><span class="line">.self 只处理自身的事件，内部元素触发的事件不进入该处理</span><br><span class="line">.once 该事件方法只会被调用一次</span><br><span class="line">.passive 告诉浏览器执行事件的默认行为(正好与.prevent相反), </span><br><span class="line">         与.prevent一起使用时.prevent会被忽略</span><br></pre></td></tr></table></figure></li><li><p>按键修饰符<br>监听键盘事件时，可以指定按键。<br>如v-on:keyup.enter=”submit”回车键调用submit方法，<br>v-on:keyup.page-down=”onPageDown”按下pageDown键时调用onPageDown方法。<br>键名可以使用KeyboardEvent.key得到。<br>可以通过以下方式获取:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;b5&quot;&gt;</span><br><span class="line">      &lt;input @keyup=&quot;go($event)&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var b5 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b5&apos;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">              go: function (e) &#123;</span><br><span class="line">                      console.log(e.key);</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>注：按键码keycode用法已经被废弃，应避免使用</p><ol start="6"><li>系统修饰键<br>键盘修饰键只有在按下时才能触发，有<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ctrl</span><br><span class="line">.alt</span><br><span class="line">.shift</span><br><span class="line">.meta</span><br></pre></td></tr></table></figure></li></ol><p>如alt+c触发clear方法: <code>&lt;input @keyup.alt.c=&quot;clear&quot;&gt;</code>，<br>完整代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b5&quot;&gt;</span><br><span class="line">    &lt;input @keyup.alt.c=&quot;clear&quot; v-model=&quot;mess&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var b5 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b5&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              mess: &apos;&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">              clear: function () &#123;</span><br><span class="line">                      this.mess = &apos;&apos;;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的<a href="mailto:`@keyup.alt.c" target="_blank" rel="noopener">`@keyup.alt.c</a>=”clear”<code>当alt和其他的修饰键如ctrl, shift等一起按下时也会调用，使用.exact修饰符可以控制只有alt被按下时才会调用clear方法,代码为</code>@keyup.alt.exact.c=”clear”`.</p><ol start="7"><li>鼠标按钮修饰符<br>.left .right .middle</li></ol><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>v-model实际是语法糖，它监听用户的输入事件并更新数据。<br>v-model适用于input, textarea, checkbox, radio, select元素。</p><p>text, textarea, select根据value属性的变化触发input事件。<br>checkbox, radio根据checked属性的变化触发change事件。</p><p>v-model绑定的值为元素值。如<code>&lt;input type=&#39;checkbox&#39; value=&#39;one&#39; v-model=&#39;arr&#39;&gt;</code>中，复选框<br>选中时arr数组中有值one, 未勾选时无值one. 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b6&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; value=&quot;one&quot; v-model=&quot;arr&quot;/&gt;&lt;label&gt;one&lt;/label&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; value=&quot;two&quot; v-model=&quot;arr&quot;/&gt;&lt;label&gt;two&lt;/label&gt;</span><br><span class="line">      &lt;p&gt;&#123; &#123;arr&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var b6 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b6&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              arr: []</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用<code>&lt;textarea&gt;{ {mess}}&lt;/textarea&gt;</code>无法实现双向绑定，只有初始时可以成功渲染mess值，用户<br>在输入文本后，mess值并不会相应的变化，若要实现双向绑定必须使用<code>&lt;textarea v-model=&#39;mess&#39;/&gt;</code>.</p><p>select下拉框:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b7&quot;&gt;</span><br><span class="line">      &lt;select v-model=&quot;sel&quot;&gt;</span><br><span class="line">              &lt;option disabled value=&quot;&quot;&gt;please select&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;A&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;B&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;C&lt;/option&gt;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">      &lt;p&gt;&#123; &#123;sel&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var b7 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b7&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              sel: &apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>多选下拉框除绑定到一个数组外，标签使用multiple标记为可多选，具体选择时按住ctrl键可多选<br><code>&lt;select v-model=&#39;selected&#39; multiple&gt;...&lt;/select&gt;</code></p><h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p>以上使用v-model时单选框，复选框，下拉框的值都是静态的，为字符串(复选框可以为boolean值)。<br>实际使用时如下拉框，选中的选项需要绑定到一个对象，这时简单的绑定方式<code>&lt;option&gt;A&lt;/option&gt;</code><br>(该选项值为A)就不能满足需求，这时可以进一步对选项的值进行绑定，即值绑定。</p><p>即<code>&lt;option v-bind:value=&quot;{name: &#39;zs&#39;, age: 20}&quot;</code>.这样通过v-bind指令对value属性进一步绑定<br>即可满足要求。</p><p>如下代码展示了下拉框联动后获取子下拉框选择的具体对象信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;b8&quot;&gt;</span><br><span class="line">      &lt;select v-model=&quot;parent&quot; @change=&quot;changeList&quot;&gt;</span><br><span class="line">              &lt;option disabled value=&quot;&quot;&gt;please select one&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;a&lt;/option&gt;</span><br><span class="line">              &lt;option&gt;b&lt;/option&gt;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">      &lt;select v-model=&quot;child&quot;&gt;</span><br><span class="line">              &lt;option disabled value=&quot;&quot;&gt;please select one&lt;/option&gt;</span><br><span class="line">              &lt;option v-for=&quot;item in list&quot; :key=&quot;item.id&quot; :value=&quot;item&quot;&gt;&#123; &#123; item.name &#125;&#125;&lt;/option&gt;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">      &lt;p&gt;id: &#123; &#123;child.id&#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;name: &#123; &#123;child.name&#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;age: &#123; &#123;child.age&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var b8 = new Vue(&#123;</span><br><span class="line">      el: &apos;#b8&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">              parent: &apos;&apos;,</span><br><span class="line">              child: &#123;&#125;,</span><br><span class="line">              list: []</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">            changeList: function () &#123;</span><br><span class="line">                  if (this.parent == &apos;a&apos;) &#123;</span><br><span class="line">                          this.list = [</span><br><span class="line">                                  &#123;id: 1, name: &apos;a1&apos;, age: 11&#125;,</span><br><span class="line">                                  &#123;id: 2, name: &apos;a2&apos;, age: 22&#125;];</span><br><span class="line">                  &#125;else&#123;</span><br><span class="line">                          this.list = [</span><br><span class="line">                                  &#123;id: 3, name: &apos;b1&apos;, age: 33&#125;,</span><br><span class="line">                                  &#123;id: 4, name: &apos;b2&apos;, age: 44&#125;];</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可以注意到，要获取子下拉框选择的对象信息，直接绑定<code>:value=&quot;item&quot;</code>.</p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>.lazy<br><code>&lt;input v-model.lazy=&quot;mess&quot; /&gt;&lt;p&gt;{ {mess}}&lt;/p&gt;</code>, 这时输入字符时显示文本不会马上改变，而是<br>回车或tab键后改变，即.lazy使用change事件，而不是input事件。</p><p>.number<br><code>&lt;input v-model.number=&#39;age&#39; type=&#39;number&#39;/&gt;</code>将用户输入值变为数字类型。经测试，type=’number’<br>有上下调整按钮，并且无法输入数字。不使用.number时typeof(b9.num)返回string类型。</p><p>.trim<br><code>&lt;input v-model.trim=&#39;txt&#39;/&gt;</code>去除首尾空白字符。</p><h3 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h3><h4 id="组件data必须是一个函数"><a href="#组件data必须是一个函数" class="headerlink" title="组件data必须是一个函数"></a>组件data必须是一个函数</h4><p>自定义组件代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c1&quot;&gt;</span><br><span class="line">      &lt;clock&gt;&lt;/clock&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;clock&apos;, &#123;</span><br><span class="line">      data: function () &#123;</span><br><span class="line">              return &#123; count: 0 &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: &apos;&lt;button @click=&quot;count++&quot;&gt;&#123; &#123;count&#125;&#125;&lt;/button&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c1 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c1&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>组件是可以复用的vue实例，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;clock /&gt;</span><br><span class="line">  &lt;clock /&gt;</span><br><span class="line">  &lt;clock /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>其中每个clock都是一个不同的实例，都有自己的属性定义。所以组件定义中data属性不能同上面一样<br>是一个简单的对象，而需要是一个函数，该函数返回需要的data对象，这样每个实例就有自己的对象了。</p><p><code>c1=new Vue({el: &#39;#c1})</code>中c1是根实例，el是根实例特有的属性。</p><p>经测试发现，组件复用时这种写法<code>&lt;clock/&gt;&lt;clock/&gt;</code>只有一个组件会显示，而<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;clock&gt;&lt;/clock&gt;</span><br><span class="line">&lt;clock&gt;&lt;/clock&gt;</span><br></pre></td></tr></table></figure></p><p>这种写法才能正确的显示多个自定义组件，原因不明。</p><h4 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h4><p>组件是通过嵌套树的形式进行组织的。<code>Vue.component(&#39;(xxx&#39;, {...})</code>的形式是全局注册。<br>在全局注册后任意新创建的Vue根实例和子组件实例(即为全局)都可以使用该组件，<br>经测试将上面的组件定义和根实例定义顺序颠倒，vue报错<code>unknown custom element</code>.</p><h4 id="通过prop向子组件传递数据"><a href="#通过prop向子组件传递数据" class="headerlink" title="通过prop向子组件传递数据"></a>通过prop向子组件传递数据</h4><p>为了给组件传递值，Vue使用props属性将需要传递的属性名集合为一个数组，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;xx&apos;, &#123;</span><br><span class="line">  props: [&apos;title&apos;],</span><br><span class="line">  template: &apos;&lt;p&gt;&#123; &#123;title&#125;&#125;&lt;/p&gt;&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在组件模板中可以像访问data中的值一样访问props中的属性。<br>传值时只需要像普通html标签的属性值赋值一样即可，如<code>&lt;clock title=&#39;wttClock&#39;/&gt;</code>.<br>同理，当属性值是动态值(如v-for列表中)时，一样使用如<code>v-bind:title=&#39;item.title&#39;</code>进行属性绑定。</p><p>组件属性prop除了可以是字符串类型的属性外，还支持将一个对象作为属性。这样向组件传值时就<br>不需要逐个具体指明对象的属性值，只需要绑定该对象即可。<br>需要注意的是，传值时不能同字符串一样直接赋值，需要使用v-bind标签绑定值对象。即前面的缩写<br>冒号不可少。代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c1&quot;&gt;</span><br><span class="line">      &lt;clock&gt;&lt;/clock&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;clock&apos;, &#123;</span><br><span class="line">      data: function () &#123;</span><br><span class="line">              return &#123; count: 0 &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: &apos;&lt;button @click=&quot;count++&quot;&gt;&#123; &#123;count&#125;&#125;&lt;/button&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c1 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c1&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;c1&quot;&gt;</span><br><span class="line">      &lt;clock :property=&quot;&#123;name: &apos;wttClock&apos;, color: &apos;red&apos;&#125;&quot;&gt;&lt;/clock&gt;</span><br><span class="line">      &lt;clock :property=&quot;&#123;name: &apos;wttClock2&apos;, color: &apos;red2&apos;&#125;&quot;&gt;&lt;/clock&gt;</span><br><span class="line">      &lt;clock :property=&quot;&#123;name: &apos;wttClock3&apos;, color: &apos;red3&apos;&#125;&quot; other=&quot;GGG&quot;&gt;&lt;/clock&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;clock&apos;, &#123;</span><br><span class="line">      data: function () &#123;</span><br><span class="line">              return &#123; count: 0&#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      props: [&apos;property&apos;, &apos;other&apos;],</span><br><span class="line">      template: &apos;&lt;div&gt;&apos; +</span><br><span class="line">              &apos;&lt;p&gt;&#123; &#123;property.name&#125;&#125; is &#123; &#123;property.color&#125;&#125;&lt;/p&gt;&apos; +</span><br><span class="line">              &apos;&lt;button @click=&quot;count++&quot;&gt; and &#123; &#123;other&#125;&#125;,&apos; +</span><br><span class="line">              &apos; clicked &#123; &#123;count&#125;&#125; times&lt;/button&gt;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var c1 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c1&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>同时，需要注意的是，组件模板中使用了property属性对象的相关信息进行显示，使用组件时必须给出<br>property属性值，否则会报错。如这里会报错<code>cannot read property: name of undefined</code>, 对应着<br>模板第一处的<code>{ {property.name}}</code>。</p><h4 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h4><p>组件模板template中只能包含一个根元素，所以当模板中存在多个平级标签时，必须使用一个元素标签<br>将多个元素”包裹”起来。</p><h4 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h4><p>有时候需要根据组件内部子元素的事件修改自定义组件所在元素(即其父组件)的状态，如点击按钮修改<br>父组件中所有文本的字体大小, 这时就需要将自定义组件内部的事件”传播”给其父组件进行处理,<br>反过来也可以说父组件监听子组件的事件.</p><p>实现该功能需要两步设置.</p><ol><li>在子组件上”发射”事件.如<code>&lt;button @click=&quot;$emit(&#39;afterClicked&#39;)&quot;&gt;&lt;/button&gt;</code>, 其中将点击<br>操作通过内建的$emit方法触发一个事件, 指定事件名为afterClicked.</li><li>在父组件中使用如<code>&lt;self-component v-on:afterClicked=&quot;doSth&quot;&gt;&lt;/self-component&gt;</code>,<br>这里需要注意的是这里的响应函数属于父组件,处理的属性也是父组件的属性,不可与子组件混淆.</li></ol><p>具体代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c2&quot; :style=&quot;&#123;fontSize: fs&#125;&quot;&gt;</span><br><span class="line">      &lt;p&gt;I am Text being affected by wtt click event&lt;/p&gt;</span><br><span class="line">  &lt;wtt v-on:ee=&quot;cfs&quot;&gt;&lt;/wtt&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;wtt&apos;, &#123;</span><br><span class="line">   data: function () &#123;</span><br><span class="line">         return &#123;</span><br><span class="line">                 acolor: &apos;red&apos;</span><br><span class="line">         &#125;;</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">           changeColor: function () &#123;</span><br><span class="line">                   this.acolor = &apos;black&apos;;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   template: &apos;&lt;div :style=&quot;&#123;color: acolor&#125;&quot;&gt;&apos; +</span><br><span class="line">           &apos;&lt;p&gt;WTT GO FUN&lt;/p&gt;&apos; +</span><br><span class="line">           &apos;&lt;button @click=&quot;changeColor&quot; :style=&quot;&#123;color: acolor&#125;&quot;&gt;call wtt component inner methods to change color of&apos; +</span><br><span class="line">           &apos; wtt&lt;/button&gt;&lt;br&gt;&lt;br&gt;&apos;+</span><br><span class="line">           &apos;&lt;button @click=&quot;$emit(\&apos;ee\&apos;, 20)&quot; :style=&quot;&#123;color: acolor&#125;&quot;&gt;change parent text fontSize&lt;/button&gt;&apos;+</span><br><span class="line">           &apos;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c2 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c2&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">            fs: 10</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">              cfs: function (am) &#123;</span><br><span class="line">                    this.fs = am;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>其中,可以看到$emit方法还可以传递第二个参数, 这里代表新的字体大小, 即子组件触发事件时可以给出<br>更具体的信息或指令. 父组件进行响应处理时如果是表达式, 用$event可以得到该参数值,如果是方法,<br>直接如上使用第一个参数即可.</p><h4 id="组件上使用v-model"><a href="#组件上使用v-model" class="headerlink" title="组件上使用v-model"></a>组件上使用v-model</h4><p>普通标签的v-model实际上是语法糖, 即<code>&lt;input v-model=&#39;it&#39; /&gt;</code>它等价于<br><code>&lt;input :value=&#39;it&#39; :input=&#39;it = $event.target.value&#39; /&gt;</code>, 即input标签的值取属性it的值,<br>同时将input标签的输入值赋值给属性it, 这样就实现了双向绑定.</p><p>自定义组件实现双向绑定,同理如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;wtt :value=&apos;it&apos; :input=&apos;it = $event&apos;&gt;&lt;/wtt&gt;</span><br></pre></td></tr></table></figure></p><p>其中, 首先wtt组件需要有value这个属性, 即props中有属性value; 再是wtt组件中的input标签同前面<br>所说需要触发一个事件名为’input’. 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c3&quot;&gt;</span><br><span class="line">      &lt;wtt-input :value=&quot;mess&quot; @input=&quot;mess=$event&quot;&gt;&lt;/wtt-input&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;wtt-input&apos;, &#123;</span><br><span class="line">    props: [&apos;value&apos;],</span><br><span class="line">    template: &apos;&lt;div&gt;\</span><br><span class="line">                &lt;p&gt;wtt-input value is &#123; &#123;value&#125;&#125;&lt;/p&gt;\</span><br><span class="line">                &lt;input @input=&quot;$emit(\&apos;input\&apos;, $event.target.value)&quot; :value=&quot;value&quot;&gt;\</span><br><span class="line">               &lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c3 = new Vue(&#123;</span><br><span class="line">    el: &apos;#c3&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">          mess: &apos;xxx&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>其中为了让组件内的值与prop mess同步显示, 使用了<code>:value=&quot;value&quot;</code>进行绑定.<br>这时就可以在input框中输入值,通过p标签查看prop值; 同时在console中使用<code>c3.mess = &#39;gogo&#39;</code>命令<br>后可以看到input框的值同步发生了改变, 从而验证出确实实现了双向绑定.</p><h4 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h4><p>以上的自定义组件使用时是这种模板<code>&lt;wtt&gt;&lt;/wtt&gt;</code>, 如果想要像普通元素一样在标签中传值,如<br><code>&lt;p&gt;message&lt;/p&gt;</code>, 可以使用Vue的自定义元素slot, 使用时<code>&lt;wtt&gt;Hello World&lt;/wtt&gt;</code>或直接内嵌<br>其他标签<code>&lt;wtt&gt;&lt;div&gt;&lt;p&gt;GO FUN&lt;/p&gt;&lt;button&gt;click me&lt;/button&gt;&lt;/div&gt;&lt;/wtt&gt;</code>.然后只需要在组件<br>定义模板中插入<code>&lt;slot&gt;&lt;/slot&gt;</code>即可.具体代码略.</p><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><p>某些场景下需要一个动态的组件, 即根据不同的条件该组件的类型可以切换.<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c5&quot;&gt;</span><br><span class="line">      &lt;button @click=&quot;cc&quot;&gt;change the component type&lt;/button&gt;</span><br><span class="line">      &lt;component :is=&quot;curComp&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;wtt-a&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;I am A&lt;/p&gt;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(&apos;wtt-b&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;I am B&lt;/p&gt;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(&apos;wtt-c&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;I am C&lt;/p&gt;&lt;/div&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c5 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c5&apos;,</span><br><span class="line">      data: &#123;</span><br><span class="line">            comps: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;],</span><br><span class="line">              index: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">            curComp: function () &#123;</span><br><span class="line">                  return &apos;wtt-&apos; + this.comps[this.index];</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">              cc: function () &#123;</span><br><span class="line">                      this.index = ++this.index % this.comps.length;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>编写过程中发现几点要注意:</p><ol><li>组件名要多个单词, 自定义高一点, 使用如a作为组件名时(a是超链接…), vue会给出警告.</li><li>计算属性中不要忘记使用this引用data中的属性.</li></ol><p>从代码中可以看出, 组件动态化主要就是利用了Vue的Component标签配合其is属性, 在is属性中指定<br>具体的组件名称即可实现组件类型的切换.</p><p>注: 除了可以使用具体的完整组件名称, 还可以使用一个对象数组, 对象属性包括组件名称和组件模板,<br>具体代码略过.</p><h4 id="解析DOM模板需要注意内容"><a href="#解析DOM模板需要注意内容" class="headerlink" title="解析DOM模板需要注意内容"></a>解析DOM模板需要注意内容</h4><p>如前面说过的, 某些标签如<code>&lt;ul&gt;</code>中只允许出现<code>&lt;li&gt;</code>标签,这时如果在其中加入自定义组件会被视为<br>无效标签而被提取到<code>&lt;ul&gt;</code>标签外,渲染出现问题.<br>如以下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c6&quot;&gt;</span><br><span class="line">      &lt;p&gt;Hello world&lt;/p&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">              &lt;wtt-row&gt;&lt;/wtt-row&gt;</span><br><span class="line">              &lt;tr&gt;&lt;td&gt;Done&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;wtt-row&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;tr&gt;&lt;td&gt;I am wtt-row&lt;/td&gt;&lt;/tr&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">var c6 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c6&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>通过devTool查看元素可以看到,wtt-row被提取到table标签外, 渲染错误.这时可以使用<br><code>&lt;tr is=&#39;wtt-row&#39;&gt;&lt;/tr&gt;</code>代替<code>&lt;wtt-row&gt;&lt;/wtt-row&gt;</code>.再次查看, 可见渲染成功.<br>这是在普通的html页面中使用出现的问题,如果是在以下场景中使用就没有该问题,<br>不需要使用is特性:</p><ol><li><p>字符串中, 如以上例子这样写也可以成功渲染.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c6&quot;&gt;</span><br><span class="line">      &lt;p&gt;Hello world&lt;/p&gt;</span><br><span class="line">      &lt;wtt-table&gt;&lt;/wtt-table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&apos;wtt-row&apos;, &#123;</span><br><span class="line">      template: &apos;&lt;tr&gt;&lt;td&gt;I am wtt-li&lt;/td&gt;&lt;/tr&gt;&apos;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.component(&apos;wtt-table&apos;, &#123;</span><br><span class="line">      template: &quot; &lt;table&gt; &lt;wtt-row&gt;&lt;/wtt-row&gt; &lt;tr&gt;&lt;td&gt;Done&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var c6 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c6&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>单文件组件.vue, 暂略</p></li><li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code>, 暂略</li></ol><h3 id="深入了解组件"><a href="#深入了解组件" class="headerlink" title="深入了解组件"></a>深入了解组件</h3><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><h4 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h4><p>组件名推荐使用多个小写单词, 并且必须包含一个连字符, 这样可以避免与已有或未来的html标签名<br>冲突.</p><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>前面使用Vue.component(‘xx’, {…})的方式即为全局注册, 在注册以后后面创建的vue根实例都可以<br>使用该组件, 其他组件也能使用.</p><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>全局注册的问题在于即使没有使用该组件,该组件注册后仍然会在最终的依赖结果中.这时可以使用局部<br>注册.代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c6&quot;&gt;</span><br><span class="line">      &lt;p&gt;Hello world&lt;/p&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">              &lt;tr is=&quot;wtt-row&quot;&gt;&lt;/tr&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var wttRow=&#123;name: &apos;wtt-row&apos;,</span><br><span class="line">      template: &apos;&lt;tr&gt;&lt;td&gt;I am wtt-row&lt;/td&gt;&lt;/tr&gt;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">var c6 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c6&apos;,</span><br><span class="line">      components: &#123;</span><br><span class="line">              &apos;wtt-row&apos;: wttRow</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>可以看出, 局部注册就是在需要使用自定义组件的vue实例中使用components属性列出所有需要的组件,<br>列出组件名称和对应的组件对象, 组件对象有name属性和template属性(与全局注册组件一致).</p><p>经测试wttRow也不能放在c6 vue实例后面定义, 否则报错<code>unknown custom element</code>, 对于这个问题<br>组件对象本身的定义位置无影响, 应该是vue渲染的顺序性(或者生命周期?)要求导致.</p><p>注: 局部注册的组件在子组件中不可用.<br>这应该是显而易见的, 子组件中也可用的组件是全局注册的组件.</p><h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h4><p>暂略</p><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><h4 id="prop的大小写"><a href="#prop的大小写" class="headerlink" title="prop的大小写"></a>prop的大小写</h4><p>组件属性在定义时使用正常变量命名规范驼峰式命名方式(camelCase)如<code>wttTxt</code>, 但在html Dom中使用时如果<br>直接使用这种命名如<code>&lt;wtt-com wttTxt=&#39;mes&#39;&gt;&lt;/wtt-com&gt;</code>, 浏览器无法正常显示, 在devTool中vue<br>显示了一个tip, 告知这种情况下, 应使用kebab-case方式, 即<code>&lt;wtt-com wtt-txt=&#39;mes&#39;&gt;&lt;/wtt-com&gt;</code>.</p><h4 id="prop类型"><a href="#prop类型" class="headerlink" title="prop类型"></a>prop类型</h4><p>属性除了有字符串类型, 还有其他类型, 如布尔型<code>checked=true</code>, 数字型<code>width=100</code>等,这时props<br>字符串数组无法满足需求, 可以使用对象来定义props. 如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  message: String,</span><br><span class="line">  checked: Boolean,</span><br><span class="line">  width: Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中, 对象属性名为prop名称, 对应属性值为prop类型. 其他类型有Array, Object, Function,<br>Promise.</p><h4 id="传递静态或动态prop"><a href="#传递静态或动态prop" class="headerlink" title="传递静态或动态prop"></a>传递静态或动态prop</h4><p>如前面所说, 在传递prop属性值时, 直接赋值如<code>&lt;wtt-com num=&#39;88&#39;&gt;&lt;/wtt-com&gt;</code>,这时属性<br>num的值是字符串”88”, 如果需要传递数字类型, 需要使用v-bind指令,如<br><code>&lt;wtt-com :num=&#39;88&#39;&gt;&lt;/wtt-com&gt;</code>. 这时<code>props: {num: Number}</code>即可正常工作.<br>其他类型, Boolean, Array, Object类型同理都需要使用v-bind指令.</p><p>注: 不带参数的v-bind指令如<code>&lt;wtt-com v-bind=&#39;obj&#39;&gt;&lt;/wtt-com&gt;</code>是将obj的所有属性作为prop传入,<br>代码略.</p><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>有时候组件需要”修改”通过prop属性传递进来的值, 主要就是将传进来的该属性值作为初始值,<br>后续在组件内部进行修改.如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c7&quot;&gt;</span><br><span class="line">      &lt;wtt-com :init-num=&quot;88&quot;&gt;&lt;/wtt-com&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var wttCom = &#123;name: &apos;wtt-com&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">            initNum: Number</span><br><span class="line">      &#125;,</span><br><span class="line">      data: function()&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">                  wttCount: this.initNum</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">          add: function () &#123;</span><br><span class="line">                this.wttCount++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;&#123; &#123;wttCount&#125;&#125;&lt;/p&gt;&lt;button @click=&quot;initNum++&quot;&gt;increment&apos; +</span><br><span class="line">              &apos; wttTxt&lt;/button&gt;&lt;/div&gt;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">var c7 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c7&apos;,</span><br><span class="line">      components: &#123;</span><br><span class="line">              &apos;wtt-com&apos;: wttCom</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>运行代码, vue给出报错信息:<code>应避免直接修改一个prop属性, 应使用data或计算属性</code>, 这里我们改成<br><code>wttCount++</code>即可实现功能.</p><p>另外, 经测试, 如果这样写<code>@click=&#39;this.initNum++&#39;</code>, 点击按钮无反应, 可以想到template中的<br>this已经没有指向该组件实例了(可能是渲染时的其他中间对象). 但如果绑定到方法上<code>@click=&#39;add&#39;</code>,<br>这时就需要如上面代码所写<code>this.wttCount++</code>, 因为这时this确实是指向该组件实例的, 不加this<br>则会报错.</p><p>这种只能从父组件传递数据到子组件, 而子组件不能直接修改prop的方式即为单向数据流.</p><p>不过, 因为javascript中对象和数组是引用传递, 所以对于数组或对象类型的prop属性, 如果在组件中<br>直接修改prop, vue不会报错并且修改成功. 对于该问题, 为避免影响到父组件, 可以在data中拷贝对象<br>进行处理, 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;c7&quot;&gt;</span><br><span class="line">      &lt;wtt-com :init-num=&quot;&#123;val: 88&#125;&quot;&gt;&lt;/wtt-com&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var wttCom = &#123;name: &apos;wtt-com&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">            initNum: Object</span><br><span class="line">      &#125;,</span><br><span class="line">      data: function()&#123;</span><br><span class="line">          return &#123;</span><br><span class="line">                  wttCount: Object.assign(&#123;&#125;, initNum)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: &apos;&lt;div&gt;&lt;p&gt;initNum is &#123; &#123;initNum&#125;&#125;&lt;/p&gt;&lt;p&gt;wttCount is &#123; &#123;wttCount&#125;&#125;&lt;/p&gt;&apos; +</span><br><span class="line">              &apos;&lt;button @click=&quot;wttCount.val++&quot;&gt;increment wttCount&lt;/button&gt;&lt;/div&gt;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">var c7 = new Vue(&#123;</span><br><span class="line">      el: &apos;#c7&apos;,</span><br><span class="line">      components: &#123;</span><br><span class="line">              &apos;wtt-com&apos;: wttCom</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>注: 使用时同样需注意Object.assign的浅拷贝问题.</p><h4 id="prop验证"><a href="#prop验证" class="headerlink" title="prop验证"></a>prop验证</h4><p>prop除了可以指定类型外, 还可以指定是否必输, 默认值, 自定义验证函数等. 如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  wttProp: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    required: true,</span><br><span class="line">    default: 100,    // 对象或数组的默认值是从函数获得</span><br><span class="line">    validator: funtion(val)&#123;  // 值必须是66, 77, 88之一</span><br><span class="line">      return [66, 77, 88].indexOf(val) != -1;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>prop验证是在组件实例创建前完成, 所以default, validator函数不能使用data, computed等中的值.</p><p>注: 除基本类型外, prop还可以为自定义对象类型, 如<code>props: {man: Person}</code>, validator中可以用<br>instanceof验证类型.</p><h4 id="非prop的特性"><a href="#非prop的特性" class="headerlink" title="非prop的特性"></a>非prop的特性</h4><p>某些场景下, 子组件没有定义某个prop, 这时可以直接传递需要的prop值, 如给某些组件打上是否<br>激活的标记, 如<code>&lt;wtt-com :disabled=&quot;true&quot;&gt;&lt;/wtt-com&gt;</code>, wtt-com中可以不用定义disabled特性,<br>该特性会被添加到组件根元素下,外界需要判断时直接判断即可.</p><p>外部传入的prop属性通常会替换组件模板内已定义的值, 而class和style特性会将两者合并起来.</p><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>教程中说:子组件产出的事件名和父组件监听的事件名必须保持一致(事件名与prop属性不同,<br>不会进行camelCase和kebab-case的转化), 即this.$emit(‘myEvent’)只有@myEvent才能监听到,<br>但myEvent事件的监听会被dom自动转化为全小写.所以@myEvent监听不到.<strong>但经实际测试, 可以监听到….</strong></p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h3 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件&amp;异步组件"></a>动态组件&amp;异步组件</h3><h3 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h3><h3 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡&amp;动画"></a>过渡&amp;动画</h3><h3 id="进入-离开-amp-列表过渡"><a href="#进入-离开-amp-列表过渡" class="headerlink" title="进入/离开&amp;列表过渡"></a>进入/离开&amp;列表过渡</h3><h3 id="状态过渡"><a href="#状态过渡" class="headerlink" title="状态过渡"></a>状态过渡</h3><h3 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性&amp;组合"></a>可复用性&amp;组合</h3><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><h3 id="渲染函数-amp-JSX"><a href="#渲染函数-amp-JSX" class="headerlink" title="渲染函数&amp;JSX"></a>渲染函数&amp;JSX</h3><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h3 id="TypeScript支持"><a href="#TypeScript支持" class="headerlink" title="TypeScript支持"></a>TypeScript支持</h3><h3 id="生产环境部署"><a href="#生产环境部署" class="headerlink" title="生产环境部署"></a>生产环境部署</h3><h3 id="规模化"><a href="#规模化" class="headerlink" title="规模化"></a>规模化</h3><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><h3 id="内在"><a href="#内在" class="headerlink" title="内在"></a>内在</h3><h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><h2 id="springboot整合vue"><a href="#springboot整合vue" class="headerlink" title="springboot整合vue"></a>springboot整合vue</h2><ol><li>建立父项目, 有2个模块. 在父项目中定义spring-boot-starter-parent版本</li><li>用springboot initializer新建子模块backend, 依赖选starter-web和mybatis, 建立后修改parent<br>改为第一步中新建的父项目, 修改build 插件实现拷贝vue相关静态文件到backend的static目录下.  </li><li>使用windows安装包安装node, 安装过程中选择第二个带npm的选项.</li><li><code>npm install -g @vue/cli</code>, 完成后使用<code>vue --version</code>查看版本.</li><li>在frontend目录下执行<code>vue create frontend</code>, 删除frontend下的src目录, 将生成的vue项目<br>frontend下的所有内容提到上一级的frontend目录中.</li><li>编写后台代码, 启动测试后台服务</li><li>添加axios. frontend目录下执行<code>npm install axios --save</code>.</li><li>使用vue-cli-plugin-element添加element-ui组件.frontend目录下执行命令为<code>vue add element</code></li><li>idea添加vue.js插件(网络不好未安装);<br>filetypes - html - .vue;<br>javascript es6;<br>editor - file and code templates -&gt; + Vue File, extension vue, open with html format</li><li>修改element.js, 引入table, tableColumn组件, 修改App.vue, 使用axios请求后台.<br>后台服务地址暂定为请求根目录<code>/xxx</code>.</li><li>在backend中执行<code>mvn process-resources</code>将frontend dist全部内容拷贝到backend<br><code>src/main/resources</code>中.</li><li>启动BackendApplication main方法.</li><li>frontend下添加.eslintrc.js, 添加devServe配置, 使得npm run serve时可以访问后端服务.  </li></ol><p>别人的架子</p><ol><li>安装node, npm</li><li>执行命令<code>npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass</code>  </li><li>frontend下npm install</li><li>npm run serve查看页面</li><li>npm run build生成</li><li>主目录执行<code>mvn --projects backend springboot:run --settings d://alimaven//settings.xml</code>.</li></ol><h2 id="webpack-4-41-2使用"><a href="#webpack-4-41-2使用" class="headerlink" title="webpack 4.41.2使用"></a>webpack 4.41.2使用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>entry<br>处理依赖的起始位置 默认./src</li><li>output<br>打包输出(emit)信息,包括路径,文件名等</li><li>loader<br>loader可以将非js文件转换为依赖处理. 可以在module.rules中配置.<br>test选中处理目标(可以用正则表达式), use指明使用哪个loader.</li><li>plugins<br>实现如打包优化和压缩等一系列功能.</li><li>模式<br>开发或生产模式, 启用webpack内置优化</li></ol><h3 id="指南"><a href="#指南" class="headerlink" title="指南"></a>指南</h3><h4 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h4><ol><li>npm init -y<br>npm i webpack webpack-cli –save-dev</li><li>新建dist/index.html, src/index.js, 修改package.json为private</li><li>npm i –save lodash</li><li>npx webpack  该命令是运行<code>node_modules</code>中的webpack命令, 将src/index.js转变为dist/main.js</li><li>使用浏览器打开index.html查看效果</li><li>新建webpack.config.js, 其中output修改为dist/bundle.js, 所以dist/html中也需要修改.</li><li>npm webpack –config webpack.config.js  这里–config可省略,默认即为webpack.config.js</li><li>添加npm脚本, npm run build代替npx命令</li></ol><h4 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h4><ol><li>npm i –save-dev style-loader css-loader  </li><li>修改webpack.config.js指定使用style-loader, css-loader加载css文件. </li><li>新建src/style.css, 修改index.js import ‘./style.css’; element.classList.add(‘hello’);</li><li>npm run build</li><li>浏览器打开index.html查看效果, 通过dev-tool查看网页代码head标签, 源码被压缩无法查看</li></ol><p>图片</p><ol><li>npm i file-loader –save-dev</li><li>修改webpack.config.js使用fileloader处理png, jpg等格式文件</li><li>在src下添加图片, src/index.js引入图片, src/style.css使用该图片作为背景图片</li><li>npm run build</li><li>浏览器打开index.html查看效果, 通过dev-tool查看网页代码head标签, 源码被压缩无法查看</li></ol><p>字体<br>file-loader同样可以处理字体, 具体过程同上, src/style.css中可以使用@font-face引入</p><p>加载本地数据<br>使用csv-loader, xml-loader可以加载本地的csv/tsv, xml数据文件<br>还可以处理json格式数据, src/index.js中引入的变量为解析后的JSON数据(经测试xml实际被转换为<br>一个对象, 根节点为属性名).</p><h4 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h4><p>多入口</p><ol><li>新建src/print.js, 修改src/index.js使用print.js, 修改webpack.config.js添加入口,并修改<br>输出文件名.</li><li>npm run build</li><li>index.html查看效果</li></ol><p>使用HtmlWebpackPlugin生成index.html文件<br>到目前为止,webpack帮我们将src/index.js等文件连同依赖进行打包, 但dist/index.html还是我们<br>自己手动写的标签, 当上面的输出文件如dist/xx.bundle.js名字修改后,还要手动修改dist/index.html,<br>这时我们可以使用该插件自动生成dist/index.html文件</p><ol><li>npm i html-webpack-plugin –save-dev</li><li>修改webpack.config.js引入该插件</li><li>npm run build<br>可以看到, <code>*.bundle.js, index.html</code>都是webpack生成(emit)的, webpack plugin中设置的title即为<br>页面title, 相应的script标签内嵌在body标签中.</li></ol><p>清理dist文件夹</p><ol><li>npm i clean-webpack-plugin –save-dev</li><li>修改webpack.config.js引入该插件</li><li>npm run build<br>这里发现使用的clean-webpack-plugin版本为3.0.0, 文档写法报错CleanWebpackPlugin is not a<br>constructor, 改为const {CleanWebpackPlugin} = require(‘..’);<br>plugins中写new CleanWebpackPlugin()即可. 这里的变量名不可修改, 否则同样报错not a constructor.</li></ol><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p>source map<br>追踪错误具体位置, 修改webpack.config.js后重新编译即可.<br>source map是js自带功能, 无需使用插件.它有很多选项, 针对开发环境和生产环境有不同的推荐,<br>经测试发现inline-source-map可以显示原代码的js文件名称和行数, 适合开发环境错误定位.</p><p>开发工具<br>前面每次修改完配置或代码, 都需要重新编译生成文件,非常麻烦, 这里同样可以使用webpack提供的<br>多种方法自动编译.</p><ol><li>watch<br>修改package.json, 建立一个npm脚本命令”watch”: “webpack –watch”.使用<code>npm run watch</code>执行该<br>脚本. 这里其实是用<code>npm run watch</code>代替执行<code>npm run build</code>, 不同的是命令会一直执行, 始终监控.</li></ol><p>修改src/print.js后发现脚本有自动重新编译, 但是需要刷新浏览器才能看见效果.</p><ol start="2"><li><p>webpack-dev-server<br>这是webpack提供的一个web服务器, 可以实现自动刷新(live reload). </p><ol><li>npm i webpack-dev-server –save-dev</li><li>修改webpack.config.js指定devServer代码加载位置</li><li>修改package.json添加npm start脚本启动devServer.<br>经测试, 执行<code>npm start</code>后自动打开<code>localhost:8080</code>页面, 修改文件后自动刷新生效.</li></ol></li><li><p>webpack-dev-middleware<br>webpack-dev-server内部使用了该middleware, 它也可以单独使用, 进行自定义配置, 这里略过.</p></li></ol><p>最后提到, 文件编辑器的safe-write功能可能影响重新编译, 应该是说dist目录不能被重新编译结果<br>自动覆盖.vim中没有发现该问题, 后面遇到再说.</p><h4 id="HMR-hot-module-replacement"><a href="#HMR-hot-module-replacement" class="headerlink" title="HMR hot module replacement"></a>HMR hot module replacement</h4><p>无需完全刷新可以热加载模块, 如样式等. 暂时未发现用途, 暂略</p><h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h4><p>打包时去除没有被引用的模块.<br>简单的修改package.json, 指定mode: “production”可以压缩打包输出, 也可以使用命令行<br><code>npm run build --optimize-minimize</code>来启用webpack内部的压缩插件UglifyJsPlugin.</p><ol><li>npm i uglifyjs-webpack-plugin</li><li>修改webpack.config.js引入该plugin</li><li>npm run build<br>查看dist目录大小, 发现压缩后目录小了10倍!</li></ol><h4 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h4><p>同spring相同, webpack也可以对于开发和生产环境进行不同的配置, 并且它可以将公共的部分提取出来,<br>再使用webpack-merge工具将配置进行整合.</p><ol><li>删除webpack.config.js, 新建webpack.common.js, webpack.dev.js, webpack.prod.js, </li><li>npm i webpack-merge –save-dev</li><li>修改package.json将start定义为生产环境启动脚本, build定义为打生产环境包. </li></ol><p>生产环境的sourceMap可以在webconfig.prod.js的UglifyJsPlugin中指定.<br>另外, <code>process.env.NODE_ENV</code>是个重要的环境变量, 因为在webpack.config.js中无法直接赋值(是个<br>bug?), 所以需要通过new webpack.DefinePlugin(…)的形式赋值, 赋值后所有依赖包括用户自己的<br>代码都可以使用, 如代码中可以判断该变量得到当前环境是开发还是生产环境来进行逻辑处理.</p><p>分离CSS文件适用于css文件较大的情况, 暂时略过.</p><p>可以看到, common中配置的是共同配置, dev和prod配置中通过引入merge模块对象, 聚合了common配置<br>和自己额外添加的配置. start和build脚本通过前面提过的–config指定自己需要的配置文件.<br>注意:</p><ol><li>css loader也需要添加到common配置中</li><li>clean webpack plugin使用方式需如上修改</li><li>npm start后可以发现dist中没有文件生成, 它只是启动了内置web服务器, 用于开发调试, 需要生成<br>文件时仍需npm run build</li></ol><h4 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h4><p>前面的src/index.js中引入了loadash模块, 如果添加另外一个入口src/b.js, b.js中如果也引入了<br>loadash模块, 那么打包时就会将该模块重复打入2个bundle中. 因为文档中的插件CommonsChunkPlugin<br>已过时,现在只能使用SplitChunksPlugin插件进行提取公共依赖.</p><ol><li><p>修改webpack.common.js, 这里我们简单的加上配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: &apos;all&apos;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>npm run build后发现, 输出目录中多了一个vendors~app~b.bundle.js文件, 其中即包含了共同依赖<br>loadash, 再查看app.bundle.js, b.bundle.js文件, 可以看见其中已经都没有了loadash模块.</p></li></ol><p>动态导入<br>前面使用模块是import xx from xx 或 import {xx} from xx的形式, ES5还有动态加载import(…)方法,<br>它基于异步操作, webpack将它作为分离的模块起点, 打包时(包括子模块)会作为一个单独的chunk包.<br>因为import无法设置模块名称和属性, 所以webpack只能通过注释来定义这里的chunk名称!<br>这个功能暂时略过。</p><p>bundle分析<br>可以通过工具分析生成的bundle, 具体以后使用到再看。</p><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>懒加载提高了应用的启动速度，灵外某些模块可能永远不会被加载(如用户没有触发该动作)。<br>上面的分离chunks是从技术上提高了加载速度，但不属于懒加载。<br>下面操作只有在用户点击按钮时才加载src/print.js模块。</p><ol><li>修改print.js, index.js中使用动态加载import().</li><li>修改webpack.common.js指定非入口chunk名称，即动态加载的模块名称，其中的name如上面所说是<br>动态加载时通过注释指定的。</li></ol><p>经测试，npm run build会uglifyjs插件会报错。暂时注释后运行成功，点击按钮后print.js模块才会<br>加载。另外，我们在webpack.common.js中只指定了app和b2个入口，编译后发现多了一个print.bundle.js,<br>说明动态加载确实默认是作为分离入口。</p><p>以上uglifyjs报错，是因为uglifyjs不支持es6(上面的动态加载使用了es6的语法), 可以不用uglifyjs<br>插件，转而使用支持es6的插件terser-webpack-plugin, 在webpack.prod.js中这样配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">//const UglifyJSPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);</span><br><span class="line">const common = require(&apos;./webpack.common.js&apos;);</span><br><span class="line">const TerserPlugin = require(&apos;terser-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  devtool: &apos;source-map&apos;,</span><br><span class="line">  plugins: [</span><br><span class="line">    //   new UglifyJSPlugin(&#123;</span><br><span class="line">    //     sourceMap: true</span><br><span class="line">    //   &#125;),</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      &apos;process.env.NODE_ENV&apos;: JSON.stringify(&apos;production&apos;)</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: true,</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserPlugin(&#123;</span><br><span class="line">        sourceMap: true,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>总体来说，这个问题可以使用babel解决。</p><p>教程最后提到， react, vue, angular都有自己的方式实现懒加载，如vue router和vuex都可以实现<br>懒加载。这里简单记录下，后面再看具体原理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//vue router</span><br><span class="line">// Instead of: import Login from &apos;./login&apos;</span><br><span class="line">const Login = () =&gt; import(&quot;./login&quot;);</span><br><span class="line"></span><br><span class="line">new VueRouter(&#123;</span><br><span class="line">  routes: [&#123; path: &quot;/login&quot;, component: Login &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//vuex module</span><br><span class="line">const store = new Vuex.Store()</span><br><span class="line"></span><br><span class="line">// Assume there is a &quot;login&quot; module we wanna load</span><br><span class="line">import(&apos;./store/login&apos;).then(loginModule =&gt; &#123;</span><br><span class="line">  store.registerModule(&apos;login&apos;, loginModule)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>在开发过程中可以通过禁用浏览器缓存或刷新缓存的方式来加载新编译的文件，但生产环境中不可能<br>要求用户这样做，这就要求webpack重新编译后能自动刷新客户端的缓存。实际在现实中，都是部署完<br>以后再让用户使用，线上升级还是比较少。这里的缓存个人感觉主要还是提高了开发过程中浏览器的<br>缓存性能，提高开发效率。尤其是模块依赖比较多的情况。</p><p>实际上，缓存复用的基础是文件名相同，所以我们可以让每次修改后文件名发生变动即可。即<br>webpack.common.js中output的配置由<code>filename: &#39;[name].bundle.js</code>改为<br><code>filename: [name].[chunkhash].js</code>, 可以看到这里输出的文件名中包含了编译时的hash值。</p><p>注: 经过以上测试后，不修改文件的情况下重复编译发现哈希码没有变化，说明新版本没有文档中说的<br>hash问题。</p><p>anyway, 为了利用缓存提高性能，主要是需要进行拆分:</p><ol><li>将模板代码(主要指manifest的内容)和引入的第三方依赖模块提取出来，这里也需要用到前面的<br>自动切分插件SplitChunksPlugin.</li><li>分离后主要有三块内容，自己的业务逻辑代码main bundle, 依赖包vendor bundle，以及样板<br>manifest bundle。<br>除了删除vendor依赖的情况外，其他情况vendor bundle都不应当发生变化(指其文件名的hash值)。<br>这里它变化的原因在于hash值是根据module.id生成的，而module.id会受解析顺序的影响。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">也就是说，当解析顺序发生变化，ID 也会随之改变。因此，简要概括：</span><br><span class="line">main bundle 会随着自身的新增内容的修改，而发生变化。</span><br><span class="line">vendor bundle 会随着自身的 module.id 的修改，而发生变化。</span><br><span class="line">manifest bundle 会因为当前包含一个新模块的引用，而发生变化。</span><br><span class="line">第一个和最后一个都是符合预期的行为 -- 而 vendor 的 hash 发生变化是我们要修复的。</span><br></pre></td></tr></table></figure></li></ol><p>为了解决vendor的问题，即我们不应当使用module.id来生成hash值，webpack提供了NamedModulesPlugin,<br>HashedModuleIdsPlugin, 它们的原理都是根据文件路径来生成hash值，这样就解决了没有进行修改<br>vendor也会发生变化的问题。</p><p>注: 对于runtime chunk问题，在默认的SplitChunksPlugin中没有测试出该问题。所以使用SplitChunksPlugin<br>的默认配置即可，默认为async.</p><p>为了查看具体的输出打包效果，这里需要先配置图形化工具，这里使用Webpack bundle analyzer plugin.</p><ol><li>npm i webpack-bundle-analyzer –save-dev</li><li>为了灵活方便，先生成json文件，再查看该文件。修改webpack.prod.js引入插件，修改package.json<br>编写npm脚本启动服务展示。查看完以后，修改webpack.prod.js中的generateStatsFile为false即可<br>避免生成json文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">webpack.prod.js</span><br><span class="line"></span><br><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin</span><br><span class="line">  plugins: [</span><br><span class="line">    new BundleAnalyzerPlugin(&#123;</span><br><span class="line">      analyzerMode: &apos;disabled&apos;, // 不启动展示打包报告的http服务器</span><br><span class="line">      generateStatsFile: true, // 是否生成stats.json文件</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">package.json</span><br><span class="line">    // 这句实际可省略，因为在webpack.prod.js配置后，可由npm run build代替</span><br><span class="line">    &quot;getjson&quot;: &quot;webpack --profile --json &gt; ./dist/stats.json&quot;,  </span><br><span class="line">    &quot;analyze&quot;: &quot;webpack-bundle-analyzer --port 8888 ./dist/stats.json&quot;</span><br></pre></td></tr></table></figure></li></ol><p>splitcChunksPlugin配置意义:<br>插件默认将<code>node_modules</code>中所有的模块划为一个缓存组vendors, 所有重复的依赖划为缓存组default。<br>default组默认优先级为-20, vendors默认优先级为-10.</p><ol><li>optimization.splitChunks.chunks有3种值，async, initial, all<br>async: 只对异步加载的chunk处理。即任意一个动态引入的依赖都会被切分为一个新chunk,<br>静态的依赖即使有重复依赖也不会优化。</li></ol><p>initial: 对初始chunk处理，初始有重复引入的依赖将被切分。而异步加载的依赖根据动态引入的默认<br>处理方式也会被切分，最后结果即为静态和动态导入的包都可以得到优化。它的问题在于对静态和动态<br>依赖的区分处理，这种区分会导致某些既有静态又有动态引入的相同模块被重复打包。为避免该问题，<br>应使用下面的all方式。</p><p>all: 即不区分动态和静态引入，统一处理。针对上面既有动态又有静态引入的相同模块，从结果看<br>是统一作为动态引入处理(由最终bundle名称确定，未亲自测试)。</p><p>这样看，默认的async没有优化重复的静态引入，应当使用all方式。<br>另外，应当使用optimization.runtimeChunk: “single”, 经测试几行代码打出的包就有几k大小，将<br>webpack运行时单独打一个包后回到正常的几百字节。修改js文件内容不影响打出的runtime文件。</p><h2 id="webpack4-整合vue"><a href="#webpack4-整合vue" class="headerlink" title="webpack4 整合vue"></a>webpack4 整合vue</h2><p>Vue-loader</p><h3 id="起步-1"><a href="#起步-1" class="headerlink" title="起步"></a>起步</h3><ol><li>npm i -D vue-loader vue-template-compiler<br><strong>npm install xxx 默认是生产模式，依赖追加到dependencies; npm install -D xxx 相当于–save-dev</strong></li><li>修改webpack.common.js引入vue-loader plugin, 并针对.vue, .css文件进行处理。</li></ol><p>其中loader除了配置外，还需要引入插件，这样如对js配置babel处理时，vue文件中的script块才能<br>同样得到处理. </p><h3 id="处理资源路径"><a href="#处理资源路径" class="headerlink" title="处理资源路径"></a>处理资源路径</h3><p>vue-loader会自动将template中的资源转化为模块请求, 对css文件配置了css-loader后, css块中的资源<br>同样也会被转化为模块请求, 这是vue文件的资源处理机制.</p><p>注: </p><ol><li>资源路径中如果以@开头, 会被看作是模块依赖, 可以在webpack中给@设置别名.如/src目录.</li><li>url-loader会将小文件转化为内联base64编码的url地址,减少http请求次数, 文件过大后使用<br>file-loader. 使用base64编码的图片体积会变大, 影响加载css文件速度.</li></ol><h3 id="使用预处理器"><a href="#使用预处理器" class="headerlink" title="使用预处理器"></a>使用预处理器</h3><h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>现在有三大CSS预处理器, sass/scss, less, stylus, 经查找scss用的较多,较为一般性. </p><ol><li>npm i -D sass-loader node-sass</li><li>修改webpack.common.js, 针对.scss文件处理<br>这时可以在.vue文件中使用<code>&lt;style lang=&quot;scss&quot;&gt;...&lt;/style&gt;</code>使用scss.</li></ol><p>注: sass-loader默认不处理基于缩进的sass语法.需要额外配置, 这里暂不使用, 略过. </p><h4 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a>postcss</h4><p>postcss是一款使用插件转换css的工具,经查看, 总体实用性不强, 其中autoprefixer和stylelint<br>还可以, 暂略过.也可以注意到vue loader默认不应用postcss变换.</p><h4 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h4><p>轻松编写es6语法代码无需担心浏览器支持的神器, 必装.</p><ol><li>npm i -D @babel/core @babel/preset-env babel-loader</li><li>修改webpack.common.js对.js文件使用babel-loader, 同时排除掉<code>node_modules</code>目录中的文件,<br>但如果<code>node_modules</code>目录中有vue单文件组件, 还是应当使用babel转化, 所以需要进行判断筛选.</li><li>babel转换代码有时会产生重复代码, 如对class类的编译会产生多个工具函数. 这个问题可以通过<br>babel插件实现: <code>npm i -D @babel/plugin-transform-runtime @babel/runtime</code>.</li><li>polyfill可以提供某些不支持的特性, 从而支持完整的ES2015+环境.<code>npm i -D @babel/polyfill</code>.</li><li>编写babel.config.js文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    presets: [</span><br><span class="line">            &apos;@babel/preset-env&apos;,</span><br><span class="line">            &#123;</span><br><span class="line">                useBuiltIns: &apos;usage&apos;, // usage-按需引入 entry-入口引入（整体引入） false-不引入polyfill</span><br><span class="line">                corejs: 3  // 2-corejs@2  3-corejs@3</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    plugins: [&apos;@babel/plugin-transform-runtime&apos;]</span><br><span class="line">&#125;;</span><br><span class="line">6. npm i core-js@3 axios vue vue-router vuex</span><br></pre></td></tr></table></figure></li></ol><h4 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h4><p>略</p><h4 id="pug"><a href="#pug" class="headerlink" title="pug"></a>pug</h4><p>是一个可以快速编写html标签的工具, 暂时不需要, 略过.</p><h4 id="scoped-css"><a href="#scoped-css" class="headerlink" title="scoped css"></a>scoped css</h4><p>暂略<br>使用scoped后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件<br>的scoped CSS 和子组件的 scoped CSS 的影响。即子组件大部分是不受父组件影响, 只有其根节点例外,<br>如div标签等.</p><h4 id="css-modules"><a href="#css-modules" class="headerlink" title="css modules"></a>css modules</h4><p>因为webpack现在是单入口或多入口, 引入css样式时非常容易造成全局命名冲突等问题, css模块化<br>依靠webpack等构建工具给出了解决方案. 具体就是编译过后样式名字会被自动加工.<br>具体略过, 个人推荐使用sass.</p><h4 id="热重载"><a href="#热重载" class="headerlink" title="热重载"></a>热重载</h4><p>略<br>hmr会对打包的hash文件名报错, 经查找资料, 说开发环境不应当使用hash值作为输出文件名.<br>所以可以根据环境不同输出不同的名字.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">主要是修改webpack.dev.js文件, hmr只用于开发环境</span><br><span class="line"></span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const common = require(&apos;./webpack.common.js&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  devtool: &apos;inline-source-map&apos;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &apos;./dist&apos;,</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">webpack.common.js配置有关内容为:</span><br><span class="line">提取css插件的支持:</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sa|sc|c)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: &apos;./&apos;,</span><br><span class="line">              hmr: devMode   // 开发环境开启hmr</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          &apos;sass-loader&apos;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">主要是文件名的不同:</span><br><span class="line">  plugins: [</span><br><span class="line">    new CleanWebpackPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;DemoHtml&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    new VueLoaderPlugin(),</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: devMode ? &apos;css/[name].css&apos; : &apos;css/[name].[chunkhash].css&apos;,</span><br><span class="line">      chunkFilename: devMode ? &apos;css/[id].css&apos; : &apos;css/[id].[chunkhash].css&apos;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: devMode ? &apos;[name].js&apos; : &apos;[name].[chunkhash].js&apos;,</span><br><span class="line">    chunkFilename: devMode ? &apos;[name].js&apos; : &apos;[name].[chunkhash].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;..&apos;, &apos;dist&apos;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>略</p><h4 id="自定义块"><a href="#自定义块" class="headerlink" title="自定义块"></a>自定义块</h4><p>略</p><h4 id="css提取"><a href="#css提取" class="headerlink" title="css提取"></a>css提取</h4><ol><li>npm i -D optimize-css-assets-webpack-plugin mini-css-extract-plugin </li><li>修改webpack配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">webpack.common.js:</span><br><span class="line"></span><br><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">const devMode = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class="line"></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(sa|sc|c)ss$/,</span><br><span class="line">        use: [</span><br><span class="line">          devMode ? &apos;vue-style-loader&apos; : MiniCssExtractPlugin.loader,</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          &apos;sass-loader&apos;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      // Options similar to the same options in webpackOptions.output</span><br><span class="line">      // both options are optional</span><br><span class="line">      filename: devMode ? &apos;[name].css&apos; : &apos;[name].[hash].css&apos;,</span><br><span class="line">      chunkFilename: devMode ? &apos;[id].css&apos; : &apos;[id].[hash].css&apos;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">webpack.prod.js</span><br><span class="line"></span><br><span class="line">const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line"> optimization: &#123;</span><br><span class="line">    minimizer: [new OptimizeCSSAssetsPlugin(&#123;&#125;)],</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        styles: &#123;</span><br><span class="line">          name: &apos;styles&apos;,</span><br><span class="line">          test: /\.(sa|sc|c)ss$/,</span><br><span class="line">          chunks: &apos;all&apos;,</span><br><span class="line">          enforce: true,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="引入依赖的路径和省略后缀符问题"><a href="#引入依赖的路径和省略后缀符问题" class="headerlink" title="引入依赖的路径和省略后缀符问题"></a>引入依赖的路径和省略后缀符问题</h3><p>在build中写util.js定义resolve寻找项目根路径,assetsPath是静态资源目录, 在webpack.common.js中<br>引入util.js对.js, .vue, .json后缀名的文件进行解析.,</p><h3 id="图片拷贝问题"><a href="#图片拷贝问题" class="headerlink" title="图片拷贝问题"></a>图片拷贝问题</h3><ol><li>npm i -D copy-webpack-plugin</li><li>修改webpack.common.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const devMode = process.env.NODE_ENV !== &apos;production&apos;;</span><br><span class="line"></span><br><span class="line">new CopyWebpackPlugin([&#123;</span><br><span class="line">      from: utils.resolve(&apos;static/img&apos;),</span><br><span class="line">      to: utils.resolve(&apos;dist/static/img&apos;),</span><br><span class="line">      toType: &apos;dir&apos;</span><br><span class="line">    &#125;])</span><br></pre></td></tr></table></figure></li></ol><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="起步-2"><a href="#起步-2" class="headerlink" title="起步"></a>起步</h3><p>不同的组件都有一个路径值, 路径匹配后router将该组件渲染到指定位置.</p><ol><li>router-link是路由入口,通过to属性指定跳转路径,可以有多个; router-view标签输出匹配的组件.</li><li>新建VueRouter实例并将其放入Vue根实例中.</li></ol><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><p>路径中使用冒号开头的参数可以匹配不同的值, 参数名是键, 参数值为键值, 作为对象放入$route.params中,<br>如<code>/usr/:name/post/:postid</code>匹配到<code>/usr/wtt/post/123</code>时, $route.params为<br><code>{name: &#39;wtt&#39;, postid: &#39;123&#39;}</code>.</p><p>路由变化时会复用组件, 所以生命周期不会被调用. 可以通过watch $route对象在路由变化时进行操作.<br>匹配优先级: 当一个路径同时匹配多个路由时, 优先定义的优先匹配</p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code>输出匹配路由的组件。但该组件本身也可以使用<br><code>&lt;router-view&gt;&lt;/router-view</code>调用另外一个路由组件，这就构成了路由嵌套。<br>这时使用children属性在路由参数中进行配置。<br>注: 可以提供空的子路由组件便于子路径参数为空时时使用。</p><h3 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h3><p><code>&lt;router-link :to=&quot;...&quot;&gt;</code>标签内部其实调用了this.$router.push(…)方法，所以我们可以直接调用<br>该方法进行自定义跳转。<br>注: params与path不能同时使用(在push方法和to属性中)，用以下写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const userId = &apos;123&apos;</span><br><span class="line">router.push(&#123;name: &apos;user, params: &#123;userId&#125;&#125;)</span><br><span class="line">router.push(&#123;path: `/user/$&#123;userId&#125;`&#125;)</span><br></pre></td></tr></table></figure></p><p>push方法后面还有onComplete和onAbort参数，适用于完成路由跳转或终止时调用。<br>但如果路由路径不变，只有参数发生变化时，这两个参数无法被调用，需要使用beforeRouteUpdate属性<br>进行处理。<br>router.replace方法不会向history添加记录，而是替换当前history记录。<br>router.go(n)在记录中向前或向后多少步。负数为后退，正数为前进。</p><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>可以给路由命名，使用name属性，这与上面的push使用name属性跳转是相同的。</p><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p>前面的<code>&lt;router-view&gt;&lt;/router-view&gt;</code>只有一个路由出口，如果想要对一个路由同时展示2个不同的<br>组件时(如侧边栏和主栏), 这时候就需要用到命名视图了。这时，该路由对应的就是多个组件，即<br>使用<code>components</code>属性而不是<code>component</code>.<br>router-view通过name属性指定不同的名字，components中通过name指定不同的组件。</p><p>嵌套路由可以和命名视图组合起来使用实现复杂的页面视图控制。<br>注: 命名视图如果在配置中找不到同名的组件，就不会显示组件内容。<br><code>&lt;router-view&gt;&lt;/router-view&gt;</code>默认命名是default.</p><p>可以看到:</p><ol><li>嵌套路由就是组件中以直接或间接的方式(用组件封装起来，如UserSettingsNav组件)给出子路由的<br>链接, 即<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&apos;/xxx/a&apos;&gt;&lt;/router-link&gt; </span><br><span class="line">&lt;router-link to=&apos;/xxx/b&apos;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol><p>并使用children属性配置子路由的组件。</p><ol start="2"><li>命名就是组件中使用多个<code>router-view</code>出口，用name属性区分开。并在路由配置中使用components<br>属性指定每个名字视图对应的组件。</li></ol><p>结合起来，嵌套路由和命名视图同时使用时就是多个router-link和router-view同时使用。</p><h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><p>在routes配置中也可以配置重定向，将<code>{path: &#39;/a&#39;, component: Foo}</code>改为<br><code>{path: &#39;/a&#39;, redirect: &#39;/b&#39;}</code>即可实现重定向。或者redirect: {name: ‘xx’}重定向到命名视图。 </p><p>重定向是从/a跳转到/b, 然后匹配路由/b，而别名是跳转时保持url为/b, 但实际匹配为/a.<br>语法为<code>{path: &#39;/a&#39;, component: xx, alias: &#39;/b&#39;}</code>.<br>别名如在嵌套路由中匹配<code>/a/b/c/xxx</code>, 这时可以设置别名<code>/y</code>，访问<code>/y</code>时实际匹配<code>/a/b/c/xxx</code>,<br>感觉同linux的别名功能是相同的。</p><h3 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h3><p>前面定义组件时，有用到<code>&lt;div&gt;$route.params.id&lt;/div&gt;</code>，看到这样的写法就应当意识到通过路由<br>显示该组件时，该路由需要有一个动态参数如xxx/:id进行匹配。这种组件定义明显限制了组件的<br>使用范围，所以我们不应当使用$route.params来获取路由传递的参数，而使用props代替。routes配置:<br><code>{path: &#39;/xxx/:id&#39;, component: User, props: true}</code>, 对于命名视图，需要一一对应定义props:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &apos;xx/:id&apos;,</span><br><span class="line">  components: &#123;default: User, another: Another&#125;,</span><br><span class="line">  props: &#123;default: true, another: false&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的路由id是传给默认的User组件，所以props User为true, another为false.<br>注: 反过来想，我们通过路由参数给组件的属性进行了赋值操作。<br>即props设置为true时即将$route.params设置为了组件属性.同时，props还可以是对象或一个函数，<br>这2种情况下相应的路由值也会作为属性传递给组件。</p><h3 id="html5-history模式"><a href="#html5-history模式" class="headerlink" title="html5 history模式"></a>html5 history模式</h3><p>vue-router默认hash(指<code>#</code>号)模式，即<code>http://www.baidu.com/#/hello</code>中的hash值为<code>#/hello</code>, 改变这个hash<br>值，页面不会向服务端发送请求，这就是单页应用的关键。</p><p>因为<code>#</code>号夹杂在url中不好看，所以可以使用history模式，前端在路由配置中覆盖所有路由情况，<br>在最后配置一个404页面，同时后端也需要在匹配不到任何路径时也返回一个页面，防止后端报404错误。</p><p>注: history模式不能刷新和地址栏访问页面, 需要后端对每个url地址进行处理, 所以相比hash模式,<br>history模式更麻烦, 同时它还有publicPath的问题, 需要修改图片等资源才能正常加载, 如无必要使用<br>hash模式即可.</p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h3 id="简单store模式-without-vuex"><a href="#简单store模式-without-vuex" class="headerlink" title="简单store模式 without vuex"></a>简单store模式 without vuex</h3><p>当组件变多后,组件间参数传递变的复杂,而且经常有多个组件依赖一个数据源进行渲染, 或多个组件<br>同时更新一个数据源的情况,这时就需要进行状态管理, 这就是vuex的作用.<br>但是当应用很简单时, 可以简单使用store模式即可.</p><p>简单来说, 单纯使用一个对象state来记录状态,当组件改变它时, 没有修改记录, 所以无法追踪和控制, 我<br>们将该state对象封装到另外一个对象store中, 然后通过set方法去改变state属性, 这样就实现了<br>历史记录和统一管理.可以看出这种设计符合了面向对象编程的封装变化的设计原则.</p><p>以上简单store模式建立的是action -&gt; store -&gt; view的数据流向图. 这里action直接改变store,<br>大部分时候这样做是不安全的, 而且不利于管理, 所以flux架构在中间加了一层, 变为<br>action -&gt; dispatcher -&gt; store -&gt; view模式.这种模式即称为单向数据流, 任意邻近的2个节点之间<br>没有往返的数据流动.借助dispatcher我们可以实现状态快照, 状态时间旅行调试等高级调试功能.</p><p>flux架构就像眼镜, 你知道什么时候需要它. 意思即为当你的组件间状态开始变得复杂时, 一个好的<br>解耦架构可以带来轻松的管理体验.</p><h3 id="vuex-1"><a href="#vuex-1" class="headerlink" title="vuex"></a>vuex</h3><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>从基本的vuex计数器例子中可以看出:</p><ol><li>计数值使用计算属性显示,这样state变化时能进行响应.</li><li>点击按钮的方法不直接修改store.state, 而使用store.commit(‘methodName’),这样利用调试管理.</li><li>在中间层的store中定义state对象, mutation中定义操作方法, 直接写操作方法的定义时,<br>store.commit()中参数默认即方法名.简单方法可以使用nameA: x =&gt; x + x;这样的箭头函数定义.</li></ol><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol><li>state<br>每个应用只应当维护一个store实例, 这样应用的每一刻状态都可以进行控制.<br>前面view响应store的变化最简单的方式就是通过计算属性, 但每个子组件都必须引入store实例, 比较<br>麻烦, 可以在根实例中注册store实例, 它会自动”注入”所有子组件, 子组件中不用引入,直接使用<br>this.$store.state.xxx即可.</li></ol><p>mapState:<br>上面的计数器例子中, 页面通过计算属性显示该state状态, 计算属性这样定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  count()&#123;</span><br><span class="line">    return this.$store.state.count;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当需要根据state生成多个用于显示的计算属性时(还可能加上组件自己的data属性), 这样做就会有很多<br>的重复.vuex提供了mapState函数, 可用于简化该计算属性的编写. 当只需要显示state属性并且计算属性<br>名和state属性名相同时, 可以直接在mapState函数中传递字符串数组, 这是最简洁的定义方式.</p><p>注: 当需要使用组件自身的this属性时, 只能使用普通函数定义, 箭头函数是不绑定this的.<br>注2: this其实就是call方法的第一个参数, 常规的方法调用如foo()其实是标准形式foo.call()的变体.<br>如调用foo.call(obj)时方法内的this指向的就是obj对象, 但箭头函数无法通过这种形式改变this指向.<br>也就是说调用foo.call(a,b)时如果foo是一个箭头函数, a参数会被忽略, 而b参数会被当作第一个参数<br>传入方法内进行处理.</p><p>使用mapState时, 可以发现它”霸占”了整个computed属性, 如果这时想要定义本地局部的计算属性时,<br>可以使用对象展开运算符<code>...</code>, 即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputedProperty: function()&#123;...&#125;,</span><br><span class="line">  ...mapState([&apos;xx&apos;, &apos;yy&apos;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注: 只有共享的状态才需要放入根实例store的state值中, 组件内部的状态还是应当放在组件内部.</p><ol start="2"><li>getters<br>在组件增多时，如果多个组件对根store实例有一些共同的处理逻辑，我们完全可以将它们提取出来<br>放到store实例中进行定义，即store的getters属性。</li></ol><p>在store中定义好getters后，组件中可以使用this.$store.getters.xxx进行属性调用;<br>还可以给getters传递参数实现动态处理，如传递索引值查询store实例中数组对应索引的值。这时getters<br>属性返回的是一个函数，利用到了函数式编程中的高阶函数特性。</p><p>与mapState方法相同，为了组件中方便编写计算属性，计算属性中使用getter属性时，可以使用<br>mapGetters方法。</p><ol start="3"><li>mutations<br>类似于flux架构的dispatcher.(但只是其一部分, 另一部分为下面的action)<br>在store中定义mutations相当于注册了事件，mutation方法名为事件类型type, 具体方法为事件的<br>回调函数。在组件中使用this.$store.commit(‘mutationType’).触发对应type的事件。</li></ol><p>mutation handler接受state作为第一个参数，我们自己需要传递的参数可以加在后面(payload).<br>对应的，组件中commit时第一个参数是事件类型type, 后面的参数可以写需要传递的payload参数，<br>还可以整体写为对象的形式， 即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&#123;</span><br><span class="line">  type: &apos;typeName&apos;,</span><br><span class="line">  payloadName: payloadValue</span><br><span class="line">&#125;)</span><br><span class="line">// 以下这种写法传递的payload是一个对象，store.mutations定义中接收时需要按对象处理</span><br><span class="line">this.$store.commit(&apos;typeName&apos;, &#123;</span><br><span class="line">  payloadName: payloadValue</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>注: 可以将mutationTypes统一提取为常量，方便管理。<br>mutation中定义的方法都必须是同步方法，因为mutation的设计作用是对状态进行快照处理, 如果<br>它本身的定义中使用了异步方法,将无法实现该作用.</p><ol start="4"><li>action<br>对于异步操作方法, 我们应将其提取到action中, 在action中使用异步方法commit mutation, 组件中<br>不能直接操作mutation, 改为操作相应的action方法.</li></ol><p>action本身使用context代替store对象, 它有与store相同的方法和属性.即调用<br>context.commit(‘mutationType’)进行处理. 这时可以使用es6的参数解构写法省略context对象,<br>直接为commit(‘type’).</p><p>组件中使用this.$store.dispatch(‘actionType’).这里action带上参数payload的形式和mutation是<br>相同的.同样它也提供了mapActions辅助方法, 但个人认为, mapXXX可读性和实用性都不强, 不建议使用.</p><p>action方法之间同getters一样可以组合起来使用, 形成进一步更复杂的处理逻辑. 这是因为<br>store.dispatch(‘actionType’)返回的是promise, 根据promise的特性可以使用如<br>store.dispatch(‘actionA’).then(…)的方式调用下一个action.<br>如果想进一步控制promise的同步进行, 还可以将action定义为async方法,通过await关键字先行<br>完成调用另一个action.</p><ol start="5"><li>module<br>对于复杂的应用, 一个根store记录所有的状态会导致state, mutations, getters, actions变得非常<br>臃肿, 这时可以将该store拆分为模块.每个模块都有自己的state, mutations等属性. 这些属性默认<br>是全局命名的,如果想区分开, 可以设置namespaces: true.<br>模块内部还可以访问rootState等全局属性.<br>如果想定义一个模块的多个实例, 可以像组件的data属性一样, 将其变为一个函数.<br>这种处理本质上就是用方法代替属性, 从而实现不同实例状态的分隔:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;place: &apos;default&apos;, data: &#123;place: &apos;china&apos;&#125;&#125;;</span><br><span class="line">变为</span><br><span class="line">const ob2 = &#123;place: &apos;default&apos;, data: function(place)&#123;return &#123;place: this.place&#125;&#125;&#125;;</span><br><span class="line">测试如下:</span><br><span class="line">const a = obj;</span><br><span class="line">const b = obj;</span><br><span class="line">b.data;</span><br><span class="line">a.data.place = &apos;usa&apos;;</span><br><span class="line">b.data;  // usa</span><br><span class="line"></span><br><span class="line">const c = ob2;</span><br><span class="line">const d = ob2;</span><br><span class="line">c.data(&apos;usa&apos;);  // default  this指向c对象</span><br><span class="line">c.data.call(&#123;place: &apos;usa&apos;&#125;) // usa 明确绑定this对象</span><br><span class="line"></span><br><span class="line">const ob3 = &#123;place: &apos;default&apos;, data: place =&gt; &#123;return &#123;place: this.place&#125;&#125;&#125;; //undefined</span><br><span class="line">// 箭头函数不能作为方法定义 </span><br><span class="line">// 这个例子中应避免使用this指针, 组件中的this指向当前组件实例</span><br><span class="line">const ob3 = &#123;data: function(pl)&#123;return &#123;place: pl&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>略</p><h4 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h4><p>略</p><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>如果发生了除mutation函数以外的状态变更将会报错, 这样利于调试.<br>但只应当在开发环境下开启.</p><h4 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h4><p>当同时使用store的strict mode和v-model时, 如果v-model绑定的是store.state中的属性, 由于<br>v-model不是通过mutation改变的状态, 所以会报错.这时有2种办法:</p><ol><li><code>:value=&#39;x&#39; @input=&#39;updateX&#39;</code>, 这比简单的使用组件局部状态data要麻烦, 不推荐使用.</li><li>使用计算属性的get, set方法双向绑定. 经测试, 这样做虽然很简洁, 但是计算属性值每次变化<br>都会触发mutation方法, 无法控制. vue教程中使用watch通过lodash通过停止操作的时间进行控制.<br>实用性不强. 所以,还是应当使用组件局部状态data.</li></ol><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>略</p><h2 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h2><ol><li>npm i -D eslint eslint-plugin-vue</li><li><p>根目录下新建.eslintrc.js文件, 写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  extends: [</span><br><span class="line">    &quot;plugin:vue/essential&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改package.json文件,加入eslint命令<code>eslint --ext .js,.vue src</code>.</p></li></ol><h2 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h2><p>略</p><h2 id="element-ui-theme"><a href="#element-ui-theme" class="headerlink" title="element-ui theme"></a>element-ui theme</h2><ol><li>webpack中需要引入对字体文件的处理.</li><li>全局引入element-ui. main.js中写入以下3行即可.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &apos;element-ui&apos;;</span><br><span class="line">import &apos;element-ui/lib/theme-chalk/index.css&apos;;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure></li></ol><h2 id="java-vue-Element-前后端分离独立项目-图形验证码的坑"><a href="#java-vue-Element-前后端分离独立项目-图形验证码的坑" class="headerlink" title="java + vue Element 前后端分离独立项目 图形验证码的坑"></a>java + vue Element 前后端分离独立项目 图形验证码的坑</h2><p>use java to generate image (java awt) is easy, save the image text to session and return<br>the image to frontend, frontend directly use src = interface to show the image is also<br>straight-forward, then frontend use post method to request the server to login or add data,<br>now the server needs to check the code, it needs to get the image text from session to<br>compare it with post data text. And now comes the bug. </p><p>the front and backend separated projects’ session is different with the old one, even use<br>get method to get image, the jsessionid is different. After one day’s searching and testing,<br>I finally fixed the bug:</p><ol><li><p>do not use localhost with frontend service to test, as it will trigger cors problem,<br>the request will generate different session.</p></li><li><p>with front and backend separated projects, we need config axios withCredentials = true,<br>in this way, the request head will contain cookie,and cookie actually saves sessionid,<br>so we can get our image generated session and get the text there!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">var service = axios.create(&#123;</span><br><span class="line">      baseURL: &apos;http://xxx:xxx:xxx:xxx:8200/resCenter&apos;, // api的base_url</span><br><span class="line">      // timeout: 5000 // 请求超时时间</span><br><span class="line">      withCredentials: true</span><br><span class="line">&#125;)</span><br><span class="line">export default service</span><br></pre></td></tr></table></figure></li></ol><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20191119_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;note on learning Vue&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://www.taoblog.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://www.taoblog.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>VimNote</title>
    <link href="http://www.taoblog.cn/post/ddfb64ab/"/>
    <id>http://www.taoblog.cn/post/ddfb64ab/</id>
    <published>2019-10-29T07:49:16.000Z</published>
    <updated>2020-11-21T02:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>vim note<br><a id="more"></a><br>因为ToolTips博客超长，特地将vim部分单独拿出作为独立文章。</p><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h2 id="我的-vimrc配置-有修改会更新到这里，作为个人使用"><a href="#我的-vimrc配置-有修改会更新到这里，作为个人使用" class="headerlink" title="我的.vimrc配置(有修改会更新到这里，作为个人使用):"></a>我的.vimrc配置(有修改会更新到这里，作为个人使用):</h2><h2 id="vimrc-github-repo"><a href="#vimrc-github-repo" class="headerlink" title=".vimrc github repo"></a><a href="https://github.com/wutaotao2015/tao_config_repo/blob/master/HOME/.vimrc" target="_blank" rel="noopener">.vimrc github repo</a></h2><p>Vim自从去年年初开始学习以来，一直被我认为是编辑器之神,不说其他，光是最基本的h,j,k,l光标<br>移动就可以称得上是惊世神作！我在eclipse,Idea中也都下载了可以支持vim操作的插件，确实太<br>强了。<br>最近用vim写博客，因为图片地址的问题，需要用到vim的批量替换，正则表达式之前我还专门学习<br>过perl方面的东西，vim里好像有点不一样，今天上网搜了下，确实和perl有不同。</p><p>全文替换基本命令</p><blockquote><p>:%s/abc/wtt/g<br>:%s#abc#wtt/g<br>:%s@abc@wtt@g</p></blockquote><p>还可以使用其他分隔符，以上3种应该够用了。</p><p>选中文本内替换,这里可以用可视模式选中后，再输入:s即可</p><blockquote><p>:’&lt;,’&gt;s/abc/wtt/g</p></blockquote><p>vim的正则表达式</p><p> 2020-11-18 14:53:40 added:<br>vim matched whole object is <code>\0</code>, perl is $&amp;, and the matched before is $`, after is $’<br>such as<br>:s/wtt/\0WTT/<br>will get wttWTT</p><p>replace specific texts to incremental numbers tip, such as<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aoeiwtta</span><br><span class="line">wttoei</span><br><span class="line">aoeiwtt</span><br></pre></td></tr></table></figure></p><p>change to<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aoei1a</span><br><span class="line">2oei</span><br><span class="line">aoei3</span><br></pre></td></tr></table></figure></p><p>as the increment must use a variable, so we can use perl to do this<br><code>perl -pe &#39;BEGIN{$A=1;} s/wtt/$A++/ge&#39; test.txt}</code></p><p>vim的元字符vim默认需要在前面加上\,但是可以设置模式<br>vim可以设置</p><blockquote><p>:set magic      # 除了^ $ . * 外其他元字符都需要\<br>:set nomagic      # 除了^ $ 外其他元字符都需要\</p></blockquote><p>还可以在命令前临时切换</p><blockquote><p>/\m.<em>  # magic模式 查找任意字符串<br>/\M.</em>  # nomagic模式 查找.*字符串<br>\v   # very magic 模式 任意元字符都不用加\<br>\V   # very nomagic模式  任意元字符都要加\</p></blockquote><blockquote><p>/\v(a.c){3}$ # 查找行尾的abcaccadc very magic 括号，点号，大括号全部识别成功，3个字母重复3次<br>/\m(a.c){3}$ # 查找行尾的(abc){3}    magic  括号和大括号未识别成功,点号和结尾符识别成功<br>/\M(a.c){3}$ # 查找行尾的(a.c){3}    nomagic 只有结尾符识别成功，其他都是原符号<br>/\V(a.c){3}$ # 查找任意位置的(a.c){3}$  very nomagic  全部都匹配原字符<br>:s/\v(cll)/\1##/g     使用\m,\v等修饰符时需要放在第一个分隔符后，待处理字符串前面</p></blockquote><p>vim默认是magic模式,这也意味着用vim写正则表达式来搜索或替换时，除了开头结尾^$和.*以外，<br>经测试magic模式下字符组[]也不用加\,想使用其他元字符需要在前面加上\，但也有例外，具体常用如下</p><blockquote><p>捕获括号()  前后都要加\<br>字符组[]   字符组反而都不用加\,加了还报错<br>{n,m}  这个经过测试，前面加一个\就行，加2个也可以，为了规范好记，还是加2个吧<br>+   一个或多个<br>\?   0个或1个</p></blockquote><p>vim非贪婪匹配(lazy match)<br>贪婪的.*变为.{-}或.{-}<br>常用的和perl比较如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">perl     vim(magic mode)  vim(very magic mode)</span><br><span class="line">*        *                *     </span><br><span class="line">+        \+               +     </span><br><span class="line">?       \? or \=          ?     </span><br><span class="line">&#123;n,m&#125;     \&#123;n,m&#125;          &#123;n,m&#125; </span><br><span class="line">&#123;n,&#125;      \&#123;n,&#125;           &#123;n,&#125;  </span><br><span class="line">&#123;,m&#125;      \&#123;,m&#125;           &#123;,m&#125;  </span><br><span class="line">&#123;n&#125;       \&#123;n&#125;            &#123;n&#125;   </span><br><span class="line">&#123;n,m&#125;?    \&#123;-n,m&#125;         &#123;-n,m&#125;         n到m个 忽略优先</span><br><span class="line">*?        \&#123;-&#125;            &#123;-&#125;            0个或多个 忽略优先</span><br><span class="line">??        \&#123;-,1&#125;          &#123;-,1&#125;          0个或1个  忽略优先</span><br><span class="line">+?        \&#123;-1,&#125;          &#123;-1,&#125;          1个或多个 忽略优先</span><br></pre></td></tr></table></figure><p>vim还支持环视和固化分组功能<br>这里先记下，等以后需要时可以尝试使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">perl     vim</span><br><span class="line">(?=     \@=      正向肯定环视</span><br><span class="line">(?!     \@!      正向否定环视</span><br><span class="line">(?&lt;=    \@&lt;=     反向肯定环视</span><br><span class="line">(?&lt;!    \@&lt;!     反向否定环视</span><br><span class="line">(?&gt;     \@&gt;      固化分组</span><br><span class="line">(?:     \%(atom\)  相比正常的捕获型括号,前面一个括号加了一个%号</span><br></pre></td></tr></table></figure></p><p>匹配foobar中的bar,用环视来写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perl:  /(?&lt;=foo)bar/     # 需要判断的字符在环视符号内部</span><br><span class="line">vim:  /\(foo\)\@&lt;=bar/   # 需要判断的字符在环视符号前面</span><br></pre></td></tr></table></figure></p><p>注: 最近查找vim的单词边界符的时候, 发现perl中的\b对应着vim中的\&lt;和>, 同时网上给出了为什么<br>vim中的regex不同于PCRE(perl compatible regular expression), 因为vim的regex实现比perl早实现<br>了十年以上!<br>同时在vim中用命令:ver查看vim版本是否支持+perl或+perl/dyn, 如果支持, 就可以在vim中使用<br>命令:perldo s/xx/yy/g来使用PCRE写正则了!<br>试用下来, 发现perldo无法实现选中文本进行替换, 更不用说块选择模式中的神器\%V修饰符了, 所以<br>有时不想用vim的\@和{-}等符号时可以, 其他环境还是vim原生regex更强!</p><p>vim: maximize help tab  ctrl+w _ 发现途径 vim help文档<br>:h<br>forward   ctrl + ]<br>backward  ctrl + o</p><p>vim寄存器<br>用：reg命令查看寄存器内容<br>“” 匿名寄存器 set clipboard=unnamed 即是将系统剪贴板与匿名寄存器绑定到一起了<br>“0 复制内容寄存器<br>“- 小删除寄存器<br>“1 - “9 行级以上删除寄存器<br>“:  上一个vim命令寄存器<br>“/  上一个搜索内容寄存器</p><p>vim中先复制然后进行替换时，用d或s顶替了匿名寄存器””中的内容，<br>复制的时候内容会存到“0寄存器中，同时会同步到匿名寄存器中，<br>所以替换的时候如果用d，s删除旧内容后，可以用”0p来粘贴复制的新内容。<br>“0是记录上一个复制的内容，如果想实现多个复制记录表，<br>可以使用命名寄存器”a -&gt; “z<br>复制时指定寄存器  “ay<br>粘贴时也指定寄存器  “ap<br>一般用到a,b,c就够用了。</p><p>清楚a寄存器可以使用命令qaq<br>这里是录制一个空的宏命令。</p><p>粘贴最近复制的内容快捷键设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;leader&gt;v &quot;0p</span><br><span class="line">noremap &lt;leader&gt;V &quot;0Pl</span><br></pre></td></tr></table></figure></p><p>使用<code>&lt;leader&gt;</code>V时可以看到，粘贴内容粘贴在光标位置前，光标后内容自动向后移动。</p><p>vim将一列内容复制到另一列的结尾，<br><strong>vim块选择模式支持，ideaVim插件还不能支持该功能,sublimeText也不支持</strong><br>ctrl+v选择要粘贴的部分  d<br>到第一列第一行的结尾处 a  space p</p><p>在编辑文章时，可以使用’.跳转到上一个编辑修改的位置，<br>再用g;来跳转到更老的编辑位置。</p><p>写markdown时用<code>&gt;</code>有些字符如<code>*</code>会被当成md符号进行渲染从而显示不出来，所以还是多用文本引用，<br>这里特定定义了vim键位映射来方便书写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &lt;leader&gt;` i```txt&lt;CR&gt;```&lt;Esc&gt;O&lt;Esc&gt;</span><br></pre></td></tr></table></figure></p><p>因为<code>$</code>键需要按2个键，在命令模式和可视模式下确实不方便，所以看了看选择m键代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noremap m $</span><br><span class="line">vnoremap m $</span><br></pre></td></tr></table></figure></p><p>vim对选中的可视区域块内进行替换操作，相当于eclipse或idea中replace in selection功能<br>该方法支持可视化块模式(ctrl + v: visual block mode)选中后操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在正则表达式前加上\%V修饰符，如</span><br><span class="line">&apos;&lt;,&apos;&gt;s/\%Vwtt/GOGOGO/g</span><br><span class="line">同理，在选中区域内搜索也是一样，t</span><br><span class="line">&apos;&lt;,&apos;&gt;/\%Vwtt</span><br></pre></td></tr></table></figure></p><p>vim在匹配行前新增一行，使用\r<br>%s!\v(private String (.<em>);.</em>)!@JsonProperty(“\2”)\r\1!g</p><p>2019-04-24 16:57:49<br>工作中经常要面对一个小任务，删除文本中重复出现的单词，<br>网上搜了一下，发现vim的神命令<br><code>:sort u</code><br>该命令会将所有行进行排序，并删除重复的行，(该命令也可以快速空行，不用麻烦的%s/^$\n//g)<br>所以在使用该命令前，将每个单词单独列为一行即可。<br><code>%s/\&gt;/\r/g</code></p><p>2019-08-22 09:26:12 添加:<br>有时候需要同时编辑多个文件(在ide中可以使用快捷键切换——这是ide最重要的功能之一)，<br>vim可以使用以下2种方法:</p><ol><li>先打开一个文件，然后使用<code>:sp fileName</code>(水平分割)或<code>:vs fileName</code>(垂直分割)来分割窗口<br>打开另外一个文件，该功能适合需要同时看到多个文件的场景，如比较并操作等。</li><li>使用命令<code>vi -o fileName1 fileName2</code>(水平分割)或<code>vi -O fileName1 fileName2</code>(垂直分割)<br>实现以上相同的功能。</li><li>使用命令<code>vi -p fileName1 fileName2</code>可以打开多个tab页，使用命令<code>gt</code>和<code>gT</code>进行切换。<br>注: 如果需要只读方式打开一个文件(防止误修改), 可以使用命令<code>vi -m fileName</code>，它允许修改，但<br>无法保存。命令<code>vi -M fileName</code>更进一步，无法进行任何改动。一般只查看时使用<code>-M</code>即可。<br>view命令修改时只会给出警告，还是可以使用命令如<code>:w!</code>进行修改。</li></ol><p>2019-09-17 15:01:36 添加:<br>通过指定行数来选择大段的文本的方法。<br>由于之前写的JavaCoreNote的长文实在太长，最近想用typora导出pdf发现太大会崩溃，所以需要将<br>这个大文件拆分，但如何快速选择其中一大段文本呢。可以利用vim提供的标记mark来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for example: select line 5 to 10</span><br><span class="line">:5</span><br><span class="line">ma   # make mark at line 5</span><br><span class="line">:10</span><br><span class="line">shift + v # enter line selection mode</span><br><span class="line">&apos;a   # go to mark! done!</span><br></pre></td></tr></table></figure></p><p>经测试，ma始终没有效果，最后突然想起来我把它映射成$了，难怪没有效果…(m都用了好久了….)<br>现在将$改为<code>&lt;leader&gt;l</code>.<br>小写的标记是在当前编辑文件的buffer中使用，如’a是跳到标记的那一行，`a是跳到那一行，那一列，<br>相对来说更精确，而使用大写的标记如mA则是标记某一个文件中的位置。<br>每一个文件可以有自己的a标记，但所有文件中只能有一个A标记(大写标记是唯一的), 重复定义大写<br>会覆盖之前的大写标记。可以利用大写标记配合vim tab来快速编辑多个文件，这样就不用使用麻烦的<br>gt切换标签了。</p><p>可以使用:marks来查看所有标记.使用:delmarks aA删除标记a和A, :delmarks!删除所有小写标记。</p><p>2019-09-18 14:06:54 添加:<br>vim中换行符在匹配表达式中是\n, 用于替换的文本为\r, :%s表示的是全文替换, 默认的:s是单行模式,<br>所以可以测试出如果表达式使用了换行符\n, 必须使用%来进行全文匹配才可以生效。<br>同时使用默认的^和$时匹配的是光标所在行的开头和结尾，使用%就是每一行的开头和结尾，若需要<br>全文开头和全文结尾，可以使用\A和\Z.<br>下面是我将自己的博客转化为pdf时使用vim正则表达式进行处理后转移到sed命令中的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// vim</span><br><span class="line">%s#&lt;img src=&quot;.*&quot;\s*/&gt;##</span><br><span class="line">%s#!\[.*\](.*)##</span><br><span class="line">%s@&lt;hr\s*/&gt;@@g</span><br><span class="line">%s@&lt;!-- more --&gt;@@g</span><br><span class="line">%s@---@```@g</span><br><span class="line">%s@\v(```\ntitle:(.*))@#\2\r\1@g</span><br><span class="line">s@\A@[toc]\r\r@</span><br><span class="line"></span><br><span class="line">// sed  开启扩展模式-r, 元字符无需转义 如?, +, &#123;&#125;, | 同vim的\v very magic模式基本是相同的</span><br><span class="line">sed -i &apos;s#&lt;img src=&quot;.*&quot;\s*/&gt;##g&apos; taoblog$&#123;now&#125;.md</span><br><span class="line">sed -i &apos;s#!\[.*\](.*)##g&apos; taoblog$&#123;now&#125;.md</span><br><span class="line">sed -i &apos;s@&lt;hr\s*/&gt;@@g&apos; taoblog$&#123;now&#125;.md</span><br><span class="line">sed -i &apos;s@---@```@g&apos; taoblog$&#123;now&#125;.md</span><br><span class="line">sed -i &apos;s@&lt;!--\s*more\s*--&gt;@@g&apos; taoblog$&#123;now&#125;.md</span><br><span class="line"></span><br><span class="line"># sed默认是单行模式，虽然它也支持多行模式，但涉及很多sed本身的语法，所以为了简便，这里使用</span><br><span class="line"># 学习正则表达式时就接触的perl. 如下sed语句是无效的.</span><br><span class="line">#sed -ir &apos;s@(```\ntitle:(.*))@#\2\r\1@g&apos; taoblog$&#123;now&#125;.md</span><br><span class="line"># perl --version   perl 5, version 26</span><br><span class="line">perl -0777 -pi -e &apos;s@(```\ntitle:(.*))@#$2\n$1@g&apos; test</span><br><span class="line"># 最后加上目录标签，方便typora渲染 sed不支持\A</span><br><span class="line"># sed -i &apos;s@\A@[toc]\r\r@&apos; taoblog$&#123;now&#125;.md</span><br><span class="line">sed -i &apos;1s@^@[toc]\n\n@&apos; taoblog$&#123;now&#125;.md</span><br></pre></td></tr></table></figure></p><p>其中在文件开头添加文本除了可以使用\A匹配外，还可以使用cat命令来做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 读取输入 输出到新文件</span><br><span class="line">cat &lt;(echo &quot;before&quot;) text.txt &gt; newfile.txt</span><br><span class="line">(echo &quot;to be prepended&quot;; cat text.txt) &gt; newfile.txt</span><br></pre></td></tr></table></figure></p><p>另外sed功能还是十分强大的，结合管道符可以进行很多文件处理。如之前我使用vim的mark标记来<br>拆分长篇博客为短篇文章,完全可以使用sed来完成拆分工作。<br>如t1文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1ss</span><br><span class="line">2sfsdfsd</span><br><span class="line">3sfsdfsdfsdf</span><br><span class="line">4xx</span><br></pre></td></tr></table></figure></p><p>我想将t1文件的2到3行内容剪贴到t2文件中，可以使用以下命令</p><p><code>sed -n &#39;2,3p&#39; t1 &gt;&gt; t2; sed -i &#39;2,3d&#39; t1</code></p><p>其中-n是silent模式，屏蔽掉自动打印匹配内容，只打印2,3p匹配的内容, 追加到t2后，再紧接着<br>执行-i ‘2,3d’操作来删除2,3行内容。简单的’2,3dp’是不支持的，还是要将剪贴操作分为复制和删除<br>两个操作。</p><p>perl处理多行相关参数总结:<br>可以开启perl的debug模式输出匹配过程，利于表达式的调试，e.g.,</p><p>`perl -Mre=debug -pi -e ‘s/^<figure class="highlight plain"><figcaption><span>test`</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">但它输出的内容很多，可读性不好，网上搜索到perl有个Debugger模块实现了可视化的正则表达式调试</span><br><span class="line">过程，需要先安装该模块。</span><br><span class="line">```txt</span><br><span class="line">cpan   # ubuntu 18.04下可以直接输入，已经预先安装好build-essential</span><br><span class="line"># 第一次运行会提示配置和下载cpan相关内容。</span><br><span class="line">make install</span><br><span class="line">install Bundle::CPAN</span><br><span class="line">install Regexp::Debugger</span><br></pre></td></tr></table></figure></p><p>装好以后，直接输入rxrx即可进入调试界面，用/regexp/输入正则表达式，’string’输入要匹配的字符<br>串，d解析表达式内容，m进行匹配。匹配时按?可以查看帮助。</p><p>perl默认也是按行读取处理的(毕竟这是最常见的场景), 但我需要在每一篇博客上加一个<code>#</code>标签，<br>这就涉及到多行读取进行匹配。sed的语法比较晦涩，perl稍微好点，但也需要指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -0777 -pi -e &apos;s@(```\ntitle:(.*))@#$2\n$1@g&apos; test</span><br></pre></td></tr></table></figure></p><p>-0777 即指定perl多行读取(关键参数!)<br>The special value 00 will cause Perl to slurp files in paragraph mode.<br>Any value 0400 or above will cause Perl to slurp files whole, but by convention the<br>value 0777 is the one normally used for this purpose.</p><p>-p print code execution result<br>-i make changes take place in the file 同sed<br>-e execute code snippet behind, no need to write a file to run perl<br>表达式最后的模式修饰符</p><p>/m /s的区别和用途<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">no modifiers: Default behavior. &apos;.&apos; matches any character except &quot;\n&quot; . </span><br><span class="line">&apos;^&apos; matches only at the beginning of the string and &apos;$&apos; matches only at the end or </span><br><span class="line">before a newline at the end.</span><br><span class="line"></span><br><span class="line">s modifier (/s ): Treat string as a single long line. &apos;.&apos; matches any character, </span><br><span class="line">even &quot;\n&quot; . &apos;^&apos; matches only at the beginning of the string and &apos;$&apos; matches only at </span><br><span class="line">the end or before a newline at the end.</span><br><span class="line"></span><br><span class="line">m modifier (/m ): Treat string as a set of multiple lines. &apos;.&apos; matches any character </span><br><span class="line">except &quot;\n&quot; . &apos;^&apos; and &apos;$&apos; are able to match at the start or end of any line within the string.</span><br><span class="line"></span><br><span class="line">both s and m modifiers (/sm ): Treat string as a single long line, but detect multiple lines. </span><br><span class="line">&apos;.&apos; matches any character, even &quot;\n&quot; . &apos;^&apos; and &apos;$&apos; , however, are able to match at the </span><br><span class="line">start or end of any line within the string.</span><br></pre></td></tr></table></figure></p><p>/g和/c的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The modifier /g stands for global matching and allows the matching operator to match </span><br><span class="line">within a string as many times as possible. In scalar context, successive invocations </span><br><span class="line">against a string will have /g jump from match to match, keeping track of position in the </span><br><span class="line">string as it goes along. You can get or set the position with the pos() function.</span><br><span class="line"></span><br><span class="line">A failed match or changing the target string resets the position. If you don&apos;t want the </span><br><span class="line">position reset after failure to match, add the /c , as in /regexp/gc . The current position </span><br><span class="line">in the string is associated with the string, not the regexp. This means that different </span><br><span class="line">strings have different positions and their respective positions can be set or read independently.</span><br></pre></td></tr></table></figure></p><p>/c在匹配失败时不会重置位置(它和被匹配的文本是同步的), 适合与同一段文本用不同的正则表达式<br>进行匹配。</p><p>/G是和/g配合使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The \G anchor matches at the point where the previous /g match left off. </span><br><span class="line">\G allows us to easily do context-sensitive matching.</span><br><span class="line">The combination of /g and \G allows us to process the string a bit at a time and use </span><br><span class="line">arbitrary Perl logic to decide what to do next. Currently, the \G anchor is only fully </span><br><span class="line">supported when used to anchor to the start of the pattern.</span><br></pre></td></tr></table></figure></p><p>/x 提供了正则表达式的可读性，可以在表达式中添加注释。<br>/i 匹配时忽略大小写</p><p>/e 可以将新字符串变为perl代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A modifier available specifically to search and replace is the s///e evaluation modifier. </span><br><span class="line">s///e treats the replacement text as Perl code, rather than a double-quoted string. </span><br><span class="line">The value that the code returns is substituted for the matched substring. s///e is useful </span><br><span class="line">if you need to do a bit of computation in the process of replacing text.</span><br></pre></td></tr></table></figure></p><p>perl还提供了可以放在正则表达式内部的内嵌表达式。(总体来说，还是比较少使用到)<br>如(?# I am Comment) 可以替代/x来进行注释功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Most modifiers, such as /i , /m , /s and /x (or any combination thereof) can also be </span><br><span class="line">embedded in a regexp using (?i) , (?m) , (?s) , and (?x)</span><br><span class="line"></span><br><span class="line">Embedded modifiers can have two important advantages over the usual modifiers. </span><br><span class="line">1. Embedded modifiers allow a custom set of modifiers for each regexp pattern. </span><br><span class="line">This is great for matching an array of regexps that must have different modifiers.</span><br><span class="line"></span><br><span class="line">2. The second advantage is that embedded modifiers (except /p , which modifies the </span><br><span class="line">entire regexp) only affect the regexp inside the group the embedded modifier is </span><br><span class="line">contained in. So grouping can be used to localize the modifier&apos;s effects.</span><br><span class="line"></span><br><span class="line">besides: Embedded modifiers can also turn off any modifiers already present by using, </span><br><span class="line">e.g., (?-i)</span><br></pre></td></tr></table></figure></p><p>2019-10-11 12:47:42 添加:<br>vim 切换tab页用原生的gt,gT按的比较麻烦，可以映射成和terminator, gnome-terminal一样的切换<br>快捷键，以下为映射关系:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;Leader&gt;j gT</span><br><span class="line">noremap &lt;Leader&gt;k gt</span><br></pre></td></tr></table></figure></p><p>这样要比按g和t两个字母要方便，而且比按T要方便，而且j,k按键位置与tab的顺序保持了一致。<br>另外，vim本身提供了<code>&lt;c-^&gt;</code>或<code>&lt;c-6&gt;</code>支持在同一个window中来回切换最近修改的文件，非常适合<br>只需要同时编辑2个文件的情况。如编辑同一个文件夹下的jsp和js文件，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi a.jsp</span><br><span class="line">:e a.js</span><br><span class="line">ctrl + 6</span><br></pre></td></tr></table></figure></p><p>如果需要同时修改2个以上的文件，应当考虑使用ctrlP插件。ctrlP用来查找文件，再使用vim自带<br>的<code>:jumps</code>来实现跳转(ctrl + I/O组合键)，其中搜索，替换，标记(mark)都属于jump操作。<br><code>:jumps</code>列表中<code>&gt;</code>指示的是当前位置，按下第一列的数字后，如果要跳到<code>&gt;</code>下面的位置，<br>使用ctrl + I向前跳(forward); 如果要跳到<code>&gt;</code>上面的位置，使用ctrl + o向后跳(backward)。<br>使用<code>:clearjumps</code>清除jump列表，可以使用<code>:ju</code>和<code>:cle</code>来简化命令。<br>同理还有<code>:changes</code>显示修改列表，以前常用的跳到上一个修改位置的命令<code>g;</code>实际上就是在这个列表<br>上进行跳转。<code>g;</code>是backward, <code>g,</code>是forward. 类似与jumps, changes列表是首先输入第一列的数字，<br>再根据前后关系使用<code>g;</code>或<code>g,</code>即可。</p><p>注: 可以使用mark标签来确保某一行进入jump列表中。</p><p>other little useful notes:</p><ol><li><code>zf</code>可以将选中区域折叠起来(.vimrc中不能设置foldmethod=indent), 使用<code>za</code>来打开或关闭折叠。</li><li>vim可以将括号之间文本自动缩进，使用命令<code>=i{</code>, i 代表inner object. <code>&gt;i{</code>扩大缩进距离，<br><code>&lt;i{</code>减小缩进距离。</li><li>vim自带的<code>:Explore</code>或<code>:Ex</code>可以查看文件目录，在没有nerdTree插件时很方便使用，可以使用<br><code>:Texplore</code>在新tab页中打开目录列表。可以使用<code>:tabonly</code>只保留一个tab。</li><li><code>A</code>在行尾插入字符，<code>I</code>在行首插入字符。(大写键用的少，偶尔使用非常方便。还有<code>F</code>用来反向<br>查找)</li><li>vim macro.宏实际使用的很少，但非常适合模块化操作，如简单的块操作模式无法生效时，如带有<br>正则表达式的时候。下面记录下macro的具体使用命令。如将以下文本中每一行的数字替换为<code>##</code>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wtt23sdfsd</span><br><span class="line">wttlsdf57sd</span><br><span class="line">wt44tlsdfsd</span><br></pre></td></tr></table></figure></li></ol><p>命令如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. qa                  // 开始录制</span><br><span class="line">2. :.s/\d\&#123;2&#125;/##/     // 操作 这里是替换，可以叠加任意多的操作</span><br><span class="line">3. q                  // 结束录制</span><br><span class="line">4. :reg               // 查看寄存a中的内容，即为录制的宏操作，</span><br><span class="line">                     // 可以看到每一个按键(包括删除字符)都被记录在寄存器中</span><br><span class="line">5. @@                // 重复前一次宏操作</span><br><span class="line">5. &apos;&lt;,&apos;&gt;norm! @a     // 在选择块中执行宏a, normal命令: This makes it possible to execute </span><br><span class="line">                    // Normal mode commands typed on the command-line.  </span><br><span class="line">                   //  &#123;commands&#125; are executed like they are typed.</span><br><span class="line">                   // 5, 10norm! @a  在5到10行间执行norm命令</span><br></pre></td></tr></table></figure></p><p>通过以上可以看到，macro很适合较简单的文本处理任务，如果更复杂或其他不适用的情况，应使用<br>sed或perl来处理。</p><p>2019-10-12 07:16:15添加:<br>ctrlp 插件安装(vundle):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vundle: </span><br><span class="line"></span><br><span class="line">  Plugin &apos;ctrlpvim/ctrlp.vim&apos;</span><br><span class="line"></span><br><span class="line">config: </span><br><span class="line"></span><br><span class="line">let g:ctrlp_map = &apos;&lt;leader&gt;p&apos;</span><br><span class="line">let g:ctrlp_cmd = &apos;CtrlP&apos;</span><br><span class="line">map &lt;leader&gt;f :CtrlPMRU&lt;CR&gt;</span><br><span class="line">    &quot; ignore files within search</span><br><span class="line">let g:ctrlp_custom_ignore = &#123;</span><br><span class="line">    \ &apos;dir&apos;:  &apos;\v[\/]\.(git|hg|svn|rvm)$&apos;,</span><br><span class="line">    \ &apos;file&apos;: &apos;\v\.(exe|so|dll|zip|tar|tar.gz|pyc)$&apos;,</span><br><span class="line">    \ &#125;</span><br><span class="line">    &quot; disable working path mode feature</span><br><span class="line">let g:ctrlp_working_path_mode=0</span><br><span class="line">    &quot; most recently used files saved size</span><br><span class="line">let g:ctrlp_mruf_max=50</span><br><span class="line">    &quot; go to symlink-represented file</span><br><span class="line">let g:ctrlp_follow_symlinks=1</span><br></pre></td></tr></table></figure></p><p>使用:<br>,p  打开ctrlp<br>,f  打开most recently used file列表搜索<br>f5  刷新列表<br><code>&lt;c-d&gt;</code> change mode between path and file name only<br><code>&lt;c-r&gt;</code> turn on or off regex mode<br><code>&lt;c-j&gt;&lt;c-k&gt;</code> select file in the list<br><code>&lt;c-t&gt;&lt;c-v&gt;&lt;c-x&gt;</code> open selected file in a new tab or split file<br><code>&lt;c-z&gt;</code> mark or unmark multiple files and <code>&lt;c-o&gt;</code> to open them</p><p>因为ctrlp有当前工作目录的概念，如果想搜索其他目录的文件，需要使用命令<code>:CtrlP /dir</code>进行切换<br>搜索(关闭后会切换回原目录)，这样比较麻烦，所以如果有切换的需求时可以在更高级的父目录(如~)<br>中输入<code>vim</code>，再使用<code>,f</code>打开MRU, 或<code>,p</code>直接打开ctrlp编辑不在MRU中的文件(情况比较少)。<br>在搜索框中输入一个不存在的文件名时用<code>&lt;c-y&gt;</code>可以创建该文件，可以用来快速创建空白文件，如<br>不是空白文件(如需要cp时), 还是使用ctrl + z挂起任务后进行操作较好(fg返回)。</p><p> 2019-10-13 09:24:15 添加:<br>以前我一直使用:wq来保存修改内容，最近看到同事使用:x，上网查了一下才发现:wq是即使没有修改任何<br>内容也会更新修改时间，而:x如果无修改不会更新，所以应当使用:x而不是:wq.<br>另外:w是写入buffer, 而我的博客文章设置了在写入buffer时自动更新修改时间，上网搜索到:up命令<br>可以在buffer已修改的情况下才写入，所以这种情况应当使用:up, 我将以前的键映射,w(原来为:w!)<br>改为:up, 经测试达到了我要的效果！总之来说，应使用,w进行保存，:x退出文件。</p><p> 2019-10-28 21:12:47 添加:<br>vim最基本的操作之前一直没有太重视，如w,e,b之类的光标移动问题，大概够用就行，今天突然想仔细<br>查看一下到底怎么移动了，这里记录一下……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">w: jump to the beginning of next word</span><br><span class="line">e: jump to the end of next word</span><br><span class="line">b: jump to the beginning of previous word</span><br><span class="line">ge: jump to the end of previous word (同be)</span><br></pre></td></tr></table></figure></p><p>这里vim有一个word和WORD的区别，简单说就是word是由大小写字母，数字，下划线构成的单词，其他<br>的字符被视为word的分隔符(这点可以自定义修改)，而WORD就是指空白符分隔的单词，即空白符以外<br>的字符都可以视为WORD的一部分。所以说WORD可以包括其他通常意义上的连线符-点号.括号()等，<br>WORD的范围比word的范围要大很多。</p><p>最佳实践: 由于word的范围更小，控制的粒度更精细，一般使用小写命令跳转即可.如果要处理的单词<br>中包含连接符-点号.等其他字符，想要将其作为一个整体进行处理(如跳转，复制，剪切等)时，可以使用<br>大写字母W,E,B,yiW等。</p><p> 2019-10-29 15:24:07 添加:<br>之前装了一个lisp编辑神器paredit,这个vim插件对括号的支持非常到位！自动检查括号匹配情况，<br>如果删除某个左括号或右括号后出现不匹配的情况时，该插件不允许删除，这样就避免了最头疼的<br>括号匹配问题。它还有很多其他功能，而且它们都只对lisp文件类型生效(可以自定义扩展到别的文件<br>类型)。以下整理记录7个最有用的快捷键&lt; &gt; W S da( di( ya(。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在.vimrc中配置let g:paredit_shortmaps = 1</span><br><span class="line"></span><br><span class="line">  &lt;   左移括号 </span><br><span class="line">  &gt;   右移括号 </span><br><span class="line">  W   加括号 通常将参数用这个快捷键括起来后，直接按a输入方法名 同理有 ,w[   ,w&#123;   ,w&quot;</span><br><span class="line">             有多个参数时可以用可视模式选中后按W统一括起来</span><br><span class="line">  S   去除括号，将当前的list表达式放入上层表达式中</span><br><span class="line"></span><br><span class="line">vim自带快捷键,没有paredit同样支持:</span><br><span class="line">  d% (d,k)  删除到匹配的括号</span><br><span class="line">  da(  删除一个list表达式 </span><br><span class="line">       删除光标元素所在的括号(包括括号)，这比上面的命令更好用，不用将光标移动到括号上</span><br><span class="line">       即可根据所在括号进行判断删除。</span><br><span class="line">  di(  删除一个list表达式，保留括号, 应当尽量使用这个，删除括号只需要再按一下x即可</span><br><span class="line">       删除光标所在元素所在的括号内容(不包括括号本身).</span><br><span class="line">    同理有da[ da&#123;</span><br><span class="line">  ya(  复制一个list表达式,包括括号</span><br><span class="line">  yi(  复制一个list表达式,不包括括号</span><br></pre></td></tr></table></figure></p><p>总结起来，移动括号有2个&lt; &gt;, 增删括号有2个W S, 删除整个list表达式可以只记一个(光标在该括号<br>内部即可) di( . </p><p>实际编程过程中有个需要将内部list提取到外面来的需求，一开始自己写了个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;leader&gt;i :norm ya(da(da(h,v&lt;cr&gt;</span><br></pre></td></tr></table></figure></p><p>后来在网上发现<code>&lt;leader&gt;I</code>就可以实现，当光标放置在括号上时，help文档中symbol指的<br>就是这个内部的list表达式。实际使用时发现<code>&lt;leader&gt;I</code>使用后paredit插件会自动进行格式化，<br>这时候自定义指定的格式化脚本scmindent.rkt报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cdr: contract violation</span><br><span class="line">  expected: pair?</span><br><span class="line">  given: &apos;()</span><br></pre></td></tr></table></figure></p><p>测试发现，当被提取的子表达式所在的外层表达式的括号不在同一行时，格式化脚本scmindent.rkt<br>找不到外层表达式匹配的括号，所以报错。<br>这样来看，scmindent.rkt如果不修改和paredit的提取功能明显是兼容性不好的，所以暂时弃用该<br>脚本，使用vim默认的格式化功能。</p><h2 id="using-vim-plugin-without-plugin-manager"><a href="#using-vim-plugin-without-plugin-manager" class="headerlink" title="using vim plugin without plugin manager"></a>using vim plugin without plugin manager</h2><p>公司内部虚拟机无法链接外网, 安装vundle失败, 于是网上搜索到了可以不使用插件管理器直接使用<br>多个插件的方法, 经测试有效.</p><ol><li>首先要求vim版本8.0以上.</li><li>插件的git项目要求放置在~/.vim/pack/bundle/start/目录下. 其中的bundle目录名可以自定义.</li><li>~/.vimrc中直接写对应的插件配置即可.</li><li>Done!</li></ol><h2 id="vim大小写匹配问题"><a href="#vim大小写匹配问题" class="headerlink" title="vim大小写匹配问题"></a>vim大小写匹配问题</h2><p>vim默认匹配是区分大小写的(包括查找和替换), 因为我之前抄别人的.vimrc配置, 设置了smartcase<br>和ignorecase, 导致无法正确匹配的问题, 汗!<br>注释后就正常了, 需要不区分时使用如<code>:%s/ss/@/gi</code>中的/i修饰符即可.</p><h2 id="vim-command-mode-edit-shortcut"><a href="#vim-command-mode-edit-shortcut" class="headerlink" title="vim command mode edit shortcut"></a>vim command mode edit shortcut</h2><p>vim命令行模式默认的快捷键有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 以下这几个同emacs command line default shortcut</span><br><span class="line">ctrl + b   beginning 光标到开头</span><br><span class="line">ctrl + e   end 光标到结尾</span><br><span class="line">ctrl + w   delete a word</span><br><span class="line">ctrl + u   delete from cursor to beginning </span><br><span class="line">ctrl + k   delete from cursor to end </span><br><span class="line"></span><br><span class="line">ctrl + f   进入命令行模式后 使用它打开quickList of command history, 同q: </span><br><span class="line">          打开后可以正常使用j/k上下移动光标, q/和q?是历史搜索记录</span><br><span class="line">为保持一致, 使用cnoremap 将ctrl + h/j/k/l 映射为光标移动快捷键 </span><br><span class="line"></span><br><span class="line">cnoremap &lt;C-h&gt; &lt;left&gt;</span><br><span class="line">cnoremap &lt;C-l&gt; &lt;right&gt;</span><br><span class="line">cnoremap &lt;C-j&gt; &lt;down&gt;</span><br><span class="line">cnoremap &lt;C-k&gt; &lt;up&gt;</span><br><span class="line"></span><br><span class="line">注: up and down只有当命令行为空时, 即只有:时才生效</span><br><span class="line"></span><br><span class="line">注: 原来想使用alt键, 映射alt键因为alt + a-z不能被正常解析, 需要额外配置:</span><br><span class="line">let c=&apos;a&apos;</span><br><span class="line">while c &lt;= &apos;z&apos;</span><br><span class="line">  exec &quot;set &lt;A-&quot;.c.&quot;&gt;=\e&quot;.c</span><br><span class="line">  exec &quot;imap \e&quot;.c.&quot; &lt;A-&quot;.c.&quot;&gt;&quot;</span><br><span class="line">  let c = nr2char(1+char2nr(c))</span><br><span class="line">endw</span><br><span class="line">set timeout ttimeoutlen=50</span><br><span class="line">但没有与默认的ctrl键保持一致, 所以这个配置暂时不需要了.</span><br></pre></td></tr></table></figure></p><h2 id="使用vim生成递增数字列表"><a href="#使用vim生成递增数字列表" class="headerlink" title="使用vim生成递增数字列表"></a>使用vim生成递增数字列表</h2><p>编程测试时经常需要造数据，可以使用vim来自动生成递增的数字，同打印行号一样。<br>经过搜索，最简单的方法是在vim8中，ctrl + a默认是递增选中的数字，ctrl + x是递减，<br>想要递增一列数字时，ctrl+v块选择后，使用 g ctrl+a即可实现功能！<br>由于我之前一直使用ctrl + a映射为全选，所以这里改为leader a， 即逗号a实现全选。</p><h2 id="fish-shell-using-external-editor-on-mac"><a href="#fish-shell-using-external-editor-on-mac" class="headerlink" title="fish shell using external editor on mac"></a>fish shell using external editor on mac</h2><ol><li>set the $EDITOR variable<br>   <code>set -U EDITOR vim</code></li><li>按下esc(我改成了capslock)后, 快速按下e键即可。<br>fish shell 官方文档是alt + e/ alt + v, 但由于alt键是之前的meta键，这里神秘的变为esc键。<br>而且按下esc键后需要手速按e, 不能一起按，不能按慢了，否则vim都无法出现…….</li></ol><h2 id="vim寄存器操作总结"><a href="#vim寄存器操作总结" class="headerlink" title="vim寄存器操作总结"></a>vim寄存器操作总结</h2><p>主要就是实现粘贴时灵活根据按键自主选择不同的粘贴内容, 一般只需要从2个不同内容中进行选择<br>粘贴. 实验后整理按键映射如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &quot; copy is effective only in visual mode</span><br><span class="line">  &quot; 系统剪贴版 需要复制到vim外时使用, 不常用, 直接&quot;+y即可</span><br><span class="line">&quot;vnoremap &lt;leader&gt;y &quot;+y</span><br><span class="line">  &quot; 使用a寄存器 ,y easy to use</span><br><span class="line">vnoremap &lt;leader&gt;y &quot;ay</span><br><span class="line"></span><br><span class="line">  &quot; 从复制寄存器&quot;0 中粘贴内容, 由y而来</span><br><span class="line">noremap &lt;leader&gt;v &quot;0p</span><br><span class="line">  &quot; 从寄存器&quot;a 中粘贴内容, 由,y而来</span><br><span class="line">noremap &lt;leader&gt;V &quot;ap</span><br></pre></td></tr></table></figure></p><ol><li>复制到vim外比较少用, 直接”+y即可.</li><li>复制时先进入选择模式(可用ctrl + s), 再根据需要按y或leader+y(存到寄存器a中), 先用y,再用<br>leader + y.</li><li>粘贴时如果确定刚才没有删除或剪切操作可以直接p, 否则用leader+v获取复制寄存器中的内容,<br>(因为leader + p被ctrlp插件占用了), 用leader + V获取寄存器a中的内容.<br>例子如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">333   //viw y</span><br><span class="line">444   //viw x</span><br><span class="line">555   //viw ,y</span><br><span class="line"></span><br><span class="line">444  //p</span><br><span class="line">333  //,v</span><br><span class="line">555  //,V</span><br></pre></td></tr></table></figure></li></ol><h2 id="emacs"><a href="#emacs" class="headerlink" title="emacs"></a>emacs</h2><p>vim中输入中文仍然有中文输入法和英文输入法冲突的问题。看到有个emacs插件可以完美解决这个问题，<br>这里记录下实验过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 先在mac上安装emacs，这里安装的是针对mac修改过的emacs</span><br><span class="line">brew tap railwaycat/emacsmacport</span><br><span class="line">brew cask install emacs-mac</span><br><span class="line"></span><br><span class="line">// ubuntu install emacs with snap</span><br><span class="line">sudo snap set system proxy.http=&quot;socks5://127.0.0.1:1080&quot;</span><br><span class="line">sudo snap set system proxy.https=&quot;socks5://127.0.0.1:1080&quot;</span><br><span class="line"></span><br><span class="line">// need to execute this first, directly install will report refresh: EOF</span><br><span class="line">sudo snap refresh core</span><br><span class="line">sudo snap install emacs --classic</span><br></pre></td></tr></table></figure></p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20191029_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vim note&lt;br&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://www.taoblog.cn/categories/Vim/"/>
    
    
      <category term="Vim" scheme="http://www.taoblog.cn/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>HowToProgramNote</title>
    <link href="http://www.taoblog.cn/post/fff758e4/"/>
    <id>http://www.taoblog.cn/post/fff758e4/</id>
    <published>2019-10-13T14:14:01.000Z</published>
    <updated>2020-01-01T11:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>note of how to program<br><a id="more"></a></p><h2 id="程序设计步骤"><a href="#程序设计步骤" class="headerlink" title="程序设计步骤"></a>程序设计步骤</h2><h3 id="设计方法步骤"><a href="#设计方法步骤" class="headerlink" title="设计方法步骤"></a>设计方法步骤</h3><ol><li><p>data represents information. 数据代表了什么现实世界的信息<br>这一步实际是程序的数据结构设计，或是表设计的步骤。</p></li><li><p>a signature, a purpose statement, test cases, a function header</p><p>数据结构设计好后开始编写方法模板</p><p>注释signature: 方法签名，输入到输出 如; number -&gt; string<br>注释purpose:  方法的目的。 如 ; move x pixels down from the center of scene y<br>test  测试案例， 使用前面给出的例子测试<br>header:  方法模板，输出最简单的形式。 如 (define (change num) “string”)</p></li><li><p>code  实现方法， 按照给定的输入参数实现方法目的(purpose)。</p></li><li>run</li></ol><h3 id="设计世界程序步骤"><a href="#设计世界程序步骤" class="headerlink" title="设计世界程序步骤"></a>设计世界程序步骤</h3><ol><li><p>确定世界中不随时间变化的性质作为常量。一种是对象的物理性质常量，另一种是对象的图片常量.<br>后者通常使用前者进行复合计算得到。这些图片常量组合起来即可得到世界的某个完整状态。</p><p>常量的表达式可以在交互区测试得到。<br>同状态的最小集类似，在编写常量实现时应尽可能减小变量个数，这称为”单点控制”(single control)</p></li><li><p>确定世界中随时间变化的性质，将它们集合起来用一个数据对象来表示，它应该是能确定整个世界<br>图像的最小集。这个最小集就是该世界的状态。<br>应给出注释说明如何将现实世界的信息表示成该状态对象，同时将该状态对象解释成现实世界的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; A WorldState is a Number  (info -&gt; state)</span><br><span class="line">; the number is the time passed from the start to current time (state -&gt; info)</span><br></pre></td></tr></table></figure><p>注: 有时最小集有多个，任意选择一个作为状态对象即可。</p></li><li><p>确定好状态对象后，编写多个方法以完成一个bigbang表达式。如渲染方法(render)将状态显示为<br>一个图像，哪些事件处理对象影响了状态对象的哪些属性，如时间，键盘，鼠标事件等，最后根据<br>需求，确定当状态对象满足了哪些条件时需要停止程序，即end?方法。<br>将每个需要编写的方法放在wish list中，方法为模板方法，提供简单实现，符合方法签名即可。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; worldstate -&gt; image</span><br><span class="line">; place image of car x pixels from the left of margin of the background image</span><br><span class="line">(define (render x) (place-image CAR X Y BG))</span><br><span class="line"></span><br><span class="line">; worldstate -&gt; worldstate</span><br><span class="line">; add 3 to x to move the car right</span><br><span class="line">(define (tock x) (+ x 3))</span><br><span class="line"></span><br><span class="line">; worldstate -&gt; boolean</span><br><span class="line">; when to stop, 注意这里不能只用=号，toc + 3可能取不到该值，</span><br><span class="line">; 跳过后继续运行，end?一直为#f</span><br><span class="line">(define (end? ws) (&gt;= ws 100))</span><br></pre></td></tr></table></figure></li><li><p>write a main function. 它不需要设计和测试，作为就是方便在交互区启动世界项目。需要考虑的<br>仅为它的方法参数。如初始状态等。代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; worldstate -&gt; worldstate   (big-bang方法返回值也为状态)</span><br><span class="line">; launch program from some initial state</span><br><span class="line">(define (main ws) (big-bang ws [on-tick tock] [to-draw render]))</span><br></pre></td></tr></table></figure><p>on-tick默认计数频率为1/28, 即1秒28次tick.<br>mouse-event:  button-down, button-up, drag, move, enter, leave</p><p>下面为我的exercise 47的习题答案，主要是<br>place-image的用法花了较多时间，搞清楚图片的定位(anchor)和偏移距离的计算起始点。<br>代码如下, language: BSL, beginning student language</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">;; using up and down to charge battery</span><br><span class="line"></span><br><span class="line">(require 2htdp/image)</span><br><span class="line">(require 2htdp/universe)</span><br><span class="line"></span><br><span class="line">; constants</span><br><span class="line">(define BGW 100)</span><br><span class="line">(define BGH 200)</span><br><span class="line">(define MS 5)</span><br><span class="line">(define RW (- BGW (* 2 MS)))</span><br><span class="line">(define RH (- BGH  MS))</span><br><span class="line">; number -&gt; number</span><br><span class="line">; the height of red bar, hap is happiness, 0 to 100</span><br><span class="line">(define (RHF hap) (* RH hap 0.01))</span><br><span class="line">(define BG (rectangle BGW BGH &quot;solid&quot; &quot;black&quot;))</span><br><span class="line"></span><br><span class="line">; world state is a number [0,100]</span><br><span class="line">; number is height of red bar&apos;s height ratio to RH</span><br><span class="line"></span><br><span class="line">; ws -&gt; image</span><br><span class="line">; place-image would crop image to meet the need, place-image/align&apos;s function</span><br><span class="line">; is to anchor the image, here it stick the red bar at the x&apos;s center and y&apos;s bottom</span><br><span class="line">; x is distance from middle to the left, y is distance from the top to the bottom </span><br><span class="line">; so the distance is always counted from left and top</span><br><span class="line">(define (render ws)(place-image/align (rectangle RW (RHF ws) &quot;solid&quot; &quot;red&quot;)</span><br><span class="line">             (+ MS (* 0.5 RW)) RH &quot;center&quot; &quot;bottom&quot; BG)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">; ws-&gt;ws</span><br><span class="line">; each tick ws decrease by 0.5</span><br><span class="line">(define (tock ws) (- ws 0.5))</span><br><span class="line"></span><br><span class="line">; number,number -&gt; number</span><br><span class="line">; over 100 set to 100, or set to num * fac</span><br><span class="line">(define (feed num fac) (if (&gt;= (* num fac) 100) 100 (* num fac)))      </span><br><span class="line"></span><br><span class="line">; ws-&gt;ws</span><br><span class="line">; key event handler, down arrow key increase ws by 1/5, up arrow key increase ws by 1/3 </span><br><span class="line">; maximum can not be bigger than 100</span><br><span class="line">(define (kh ws key) </span><br><span class="line">  (cond </span><br><span class="line">    [(string=? key &quot;down&quot;) (feed ws 6/5)]</span><br><span class="line">    [(string=? key &quot;up&quot;)  (feed ws 4/3)]</span><br><span class="line">    [else ws]</span><br><span class="line">    ))</span><br><span class="line">(check-expect (kh 30 &quot;down&quot;) 36)</span><br><span class="line">(check-expect (kh 30 &quot;up&quot;) 40)</span><br><span class="line">(check-expect (kh 30 &quot;left&quot;) 30)</span><br><span class="line"></span><br><span class="line">; ws-&gt;ws</span><br><span class="line">; stop when ws = 0, because of multiplying, it can never equal to 0</span><br><span class="line">(define (end? ws) (&lt;= ws 0) )</span><br><span class="line">; ws -&gt; image</span><br><span class="line">; last image when world ended </span><br><span class="line">(define (last-pic ws) (text &quot;your\nbattery\nis\nout!&quot; 30 &quot;red&quot;))</span><br><span class="line"></span><br><span class="line">; main</span><br><span class="line">(define (main ws) </span><br><span class="line">  (big-bang ws </span><br><span class="line">    [to-draw render]</span><br><span class="line">    [on-tick tock]</span><br><span class="line">    [on-key kh]</span><br><span class="line">    [stop-when end? last-pic]))</span><br><span class="line"></span><br><span class="line">(main 100)</span><br></pre></td></tr></table></figure></li></ol><h3 id="枚举，区间和泛化"><a href="#枚举，区间和泛化" class="headerlink" title="枚举，区间和泛化"></a>枚举，区间和泛化</h3><p>除了用基本数据类型，如string, number, image, boolean作为状态对象，我们还可以使用枚举，<br>区间和条目作为数据类型，它们使用cond表达式在基本类型的基础上进行处理，按照各自概念进行定义。<br>如枚举使用=, string=?, false?(没有true?的定义)等判断每一个条件，区间使用&gt;, &lt;判断每一个条件。<br>泛化适用于不同判断条件类型的cond表达式，如NorF即为元素类型在num和#f中进行判断。</p><p>注: cond表达式可以嵌套在其他方法中，使用时应包含最小变量集合表达式。<br>新的数据类型为更复杂的控制提供了可能，下面是我写的用空格键触发火箭升空的小动画(在查看<br>教程代码之前)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">;; using space key to launch ufo, with counting down feature</span><br><span class="line"></span><br><span class="line">(require 2htdp/image)</span><br><span class="line">(require 2htdp/batch-io)</span><br><span class="line">(require 2htdp/universe)</span><br><span class="line"></span><br><span class="line">; constants</span><br><span class="line">(define BGW 400)</span><br><span class="line">(define BGH 600)</span><br><span class="line">(define BG (empty-scene BGW BGH))</span><br><span class="line">(define UFO (overlay/align &quot;middle&quot; &quot;bottom&quot; </span><br><span class="line">                           (ellipse 40 10 &quot;solid&quot; &quot;blue&quot;)</span><br><span class="line">                           (circle 10 &quot;solid&quot; &quot;red&quot;)))</span><br><span class="line">(define V 4)</span><br><span class="line">; 6 seconds</span><br><span class="line">(define C -3)</span><br><span class="line">(define CN (* C 28))</span><br><span class="line">;(place-image/align UFO (/ BGW 2) BGH &quot;middle&quot; &quot;bottom&quot; BG)</span><br><span class="line"></span><br><span class="line">; world state is LR(itemization)</span><br><span class="line">; LR is &quot;starting&quot; or the pixels to the bottom(it is getting bigger as ticks go)</span><br><span class="line">; or -N is countDown</span><br><span class="line"></span><br><span class="line">; ws -&gt; image</span><br><span class="line">(define (place ws) (place-image/align UFO (/ BGW 2) ws &quot;middle&quot; &quot;bottom&quot; BG))</span><br><span class="line"></span><br><span class="line">; ws -&gt; ws</span><br><span class="line">; render ws to image</span><br><span class="line">(define (render ws) </span><br><span class="line">  (cond</span><br><span class="line">    [(string? ws) (place BGH)]</span><br><span class="line">    [(&gt; ws 0) (place (- BGH ws))]</span><br><span class="line">    [else (place-image </span><br><span class="line">            (text (number-&gt;string ws)</span><br><span class="line">                  20 &quot;red&quot;) 100 100 (place BGH))]</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">(check-expect (render &quot;s&quot;) (place-image/align UFO (/ BGW 2) BGH  &quot;middle&quot; &quot;bottom&quot; BG))</span><br><span class="line">(check-expect (render 30) (place-image/align UFO (/ BGW 2) (- BGH 30) &quot;middle&quot; &quot;bottom&quot; BG))</span><br><span class="line">(check-expect (render CN) (place-image (text  (number-&gt;string CN) 20 &quot;red&quot;) 100 100 (place BG)))</span><br><span class="line"></span><br><span class="line">; ws -&gt; ws</span><br><span class="line">; tick handler &quot;stop&quot; is static, number means ufo is getting up</span><br><span class="line">(define (tock ws) </span><br><span class="line">          (cond </span><br><span class="line">           [(string? ws) ws] </span><br><span class="line">           [(&lt;= ws 0) (+ ws 1)]</span><br><span class="line">           [else (+ ws V)] </span><br><span class="line">          )</span><br><span class="line">)</span><br><span class="line">(check-expect (tock &quot;s&quot;) &quot;s&quot;)</span><br><span class="line">(check-expect (tock CN) (+ CN 1))</span><br><span class="line">(check-expect (tock 10) (+ 10 V))</span><br><span class="line"></span><br><span class="line">; ws-&gt;ws</span><br><span class="line">; only when ufo is not launching, press space key will launch ufo</span><br><span class="line">(define (kh ws key) </span><br><span class="line">  (if (and (string=? key &quot; &quot;) (string? ws)) CN ws))</span><br><span class="line"></span><br><span class="line">(check-expect (kh &quot;s&quot; &quot; &quot;) CN)</span><br><span class="line">(check-expect (kh &quot;s&quot; &quot;r&quot;) &quot;s&quot;)</span><br><span class="line">(check-expect (kh 1 &quot;r&quot;) 1)</span><br><span class="line">(check-expect (kh 6 &quot; &quot;) 6)</span><br><span class="line"></span><br><span class="line">; ws-&gt;boolean</span><br><span class="line">; when getting to the top, world ends</span><br><span class="line">; because of cond mechanism, it must judge string first, than it can use &lt;= 0 operation</span><br><span class="line">(define (end? ws) </span><br><span class="line">          (cond </span><br><span class="line">           [(string? ws) #f] </span><br><span class="line">           [(&gt;= ws BGH) #t] </span><br><span class="line">           [else #f] </span><br><span class="line">          ))</span><br><span class="line">(check-expect (end? &quot;s&quot;) #f)</span><br><span class="line">(check-expect (end? -6) #f)</span><br><span class="line">(check-expect (end? 23) #f)</span><br><span class="line">(check-expect (end? (+ 1 BGH)) #t)</span><br><span class="line"></span><br><span class="line">; ws-&gt;image</span><br><span class="line">(define (last ws) (text &quot;UFO\nfly\naway!&quot; 20 &quot;red&quot;))</span><br><span class="line"></span><br><span class="line">; ws -&gt; ws </span><br><span class="line">; if main function here has no parameter, it is just a constant, using (define main ...),</span><br><span class="line">; drrackt will evaluate it and execute big-bang,</span><br><span class="line">; using (main ws) will make it a function and do not execute big-bang</span><br><span class="line">(define (main ws)</span><br><span class="line">  (big-bang &quot;starting&quot;</span><br><span class="line">    [on-tick tock]</span><br><span class="line">    [to-draw render]</span><br><span class="line">    [stop-when end? last]</span><br><span class="line">    [on-key kh]</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">(main &quot;go&quot;)</span><br></pre></td></tr></table></figure></p><p>通过阅读后面教程的实现，发现了自己编程的一些问题:</p><ol><li><p>state状态对象是变量性质的最小集，它集成了按空格键，倒计时，升空这3种状态，<br>即需要在设计时就将变量通过泛化(itemization)的形式纳入到world state中来。这一点在实现倒计时<br>功能时没有考虑到，所以刚开始实现较困难。</p></li><li><p>实现方法时应根据不同的条件先写单元测试(check-expect)(在交互区测试语句),<br>再根据不同条件编写cond表达式，最后组合成方法的实现，这种方式最稳妥，其实也是最快的。</p></li><li><p>区间的边界情况我的程序中没有加以判断，如倒计时为-1时需要将ws变为height.但由于我考虑的是<br>ws从负数一直递增到BGH,中间没有转折。从下面书中的示例可以看出先递增后递减也是可以实现的<br>(end? 方法加以判断即可，本质还是因为ws的区间范围是明确划分的，所以先递增后递减也行)。<br>但书中也提出，使用负数作为倒计时的设计是比较脆弱的。如我将ufo的速度YDELTA调整为40，程序<br>结束后提示show中的cond表达式全部为false, 即升空后ws以YDELTA速度递减，到顶后变为负数<br>(小于-3)，调整V大小ws甚至可能落入-3至0的区间内，从而导致bug。所以这里使用负数表示倒计时<br>是不合适的。</p></li></ol><p>下面为书中程序代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">;; using space key to launch ufo, with counting down feature</span><br><span class="line"></span><br><span class="line">(require 2htdp/image)</span><br><span class="line">(require 2htdp/universe)</span><br><span class="line">(require 2htdp/batch-io)</span><br><span class="line"></span><br><span class="line">(define HEIGHT 300) ; distances in pixels </span><br><span class="line">(define WIDTH  100)</span><br><span class="line">(define YDELTA 40)</span><br><span class="line"> </span><br><span class="line">(define BACKG  (empty-scene WIDTH HEIGHT))</span><br><span class="line">(define ROCKET (rectangle 5 30 &quot;solid&quot; &quot;red&quot;))</span><br><span class="line"> </span><br><span class="line">(define CENTER (/ (image-height ROCKET) 2))</span><br><span class="line"></span><br><span class="line">; An LRCD (for launching rocket countdown) is one of:</span><br><span class="line">; – &quot;resting&quot;</span><br><span class="line">; – a Number between -3 and -1</span><br><span class="line">; – a NonnegativeNumber </span><br><span class="line">; interpretation a grounded rocket, in countdown mode,</span><br><span class="line">; a number denotes the number of pixels between the</span><br><span class="line">; top of the canvas and the rocket (its height)</span><br><span class="line"></span><br><span class="line">(check-expect</span><br><span class="line"> (show HEIGHT)</span><br><span class="line"> (place-image ROCKET 10 (- HEIGHT CENTER) BACKG))</span><br><span class="line"> </span><br><span class="line">(check-expect</span><br><span class="line"> (show 53)</span><br><span class="line"> (place-image ROCKET 10 (- 53 CENTER) BACKG))</span><br><span class="line"></span><br><span class="line">(define (place x)(place-image ROCKET 10 (- x CENTER) BACKG))</span><br><span class="line"></span><br><span class="line">(define (show x)</span><br><span class="line">  (cond</span><br><span class="line">    [(string? x) (place HEIGHT)]</span><br><span class="line">    [(&lt;= -3 x -1)</span><br><span class="line">     (place-image (text (number-&gt;string x) 20 &quot;red&quot;) 10 (* 3/4 WIDTH) (place HEIGHT))]</span><br><span class="line">    [(&gt;= x 0) (place x)]))</span><br><span class="line"></span><br><span class="line">(check-expect (launch &quot;resting&quot; &quot; &quot;) -3)</span><br><span class="line">(check-expect (launch &quot;resting&quot; &quot;a&quot;) &quot;resting&quot;)</span><br><span class="line">(check-expect (launch -3 &quot; &quot;) -3)</span><br><span class="line">(check-expect (launch -1 &quot; &quot;) -1)</span><br><span class="line">(check-expect (launch 33 &quot; &quot;) 33)</span><br><span class="line">(check-expect (launch 33 &quot;a&quot;) 33)</span><br><span class="line"></span><br><span class="line">(define (launch x ke)</span><br><span class="line">  (cond</span><br><span class="line">    [(string? x) (if (string=? &quot; &quot; ke) -3 x)]</span><br><span class="line">    [(&lt;= -3 x -1) x]</span><br><span class="line">    [(&gt;= x 0) x]))</span><br><span class="line"></span><br><span class="line">; LRCD -&gt; LRCD</span><br><span class="line">(define (main1 s)</span><br><span class="line">  (big-bang s</span><br><span class="line">    [to-draw show]</span><br><span class="line">    [on-key launch]))</span><br><span class="line"></span><br><span class="line">; LRCD -&gt; LRCD</span><br><span class="line">; raises the rocket by YDELTA if it is moving already </span><br><span class="line"> </span><br><span class="line">(check-expect (fly &quot;resting&quot;) &quot;resting&quot;)</span><br><span class="line">(check-expect (fly -3) -2)</span><br><span class="line">(check-expect (fly -2) -1)</span><br><span class="line">(check-expect (fly -1) HEIGHT)</span><br><span class="line">(check-expect (fly 10) (- 10 YDELTA))</span><br><span class="line">(check-expect (fly 22) (- 22 YDELTA))</span><br><span class="line"> </span><br><span class="line">(define (fly x)</span><br><span class="line">  (cond</span><br><span class="line">    [(string? x) x]</span><br><span class="line">    [(&lt;= -3 x -1) (if (= x -1) HEIGHT (+ x 1))]</span><br><span class="line">    [(&gt;= x 0) (- x YDELTA)]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; ws-&gt;image</span><br><span class="line">(define (end? ws) (cond </span><br><span class="line">                    [(string? ws) #f]</span><br><span class="line">                    [(&lt;= 0 ws CENTER) #t]</span><br><span class="line">                    [else false]))</span><br><span class="line"></span><br><span class="line">; LRCD -&gt; LRCD</span><br><span class="line">(define (main2 s)</span><br><span class="line">  (big-bang s</span><br><span class="line">    [to-draw show]</span><br><span class="line">    [on-key launch]</span><br><span class="line">    [on-tick fly 1]</span><br><span class="line">    [stop-when end?]</span><br><span class="line">    ))</span><br><span class="line">(main2 &quot;test&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="finite-states-worlds"><a href="#finite-states-worlds" class="headerlink" title="finite states worlds"></a>finite states worlds</h3><p>有穷状态图中状态可以使用符号常量来表示，如红绿灯中的红灯可以使用(define RED 0)或<br>(define RED “red”)来定义，因为Racket是动态语言，(eq? 0 0)和(eq? “s” “s”)同时为#t，<br>甚至(eq? “s” 0)也能正常运行，不报错，值为false. (其他比较方法还有eqv? equal?), 所以它为状态实际数据类型的变化提供了支持，这就是动态类型的好处。</p><h3 id="adding-structure"><a href="#adding-structure" class="headerlink" title="adding structure"></a>adding structure</h3><p>前面的火箭倒计时程序中，状态虽然使用不同类型的数据(“stop”字符串和代表高度的数字)来表示<br>火箭不同的状态，但整个程序中变量只有一个(“stop”时火箭是静止的，升空后变化的是高度)，如果<br>程序中有2个或2个以上的性质同时发生变化怎么办? 如支持往返飞行火箭的高度和方向。<br>这就是类似面向对象中对象的概念, structure.</p><p>(define-struct person [name age])类似于定义常量，方法，但它定义了一组方法(包括构造器<br>make-person, get方法person-name, person-age(可以看到racket中的-号类似于java中的.号)，<br>对象的equal方法person?), 与此同时还有对于structure的计算规则(类似cond语句的计算规则)，<br>如(person-name (make-person “wtt” 29)) == “wtt”.</p><p>注: 我还在想为什么racket的对象没有set方法，后来看到tock方法的返回对象时才意识到，函数式<br>编程中对象是不可变的！所以没有set方法，当需要进行修改时，使用make-XXX返回一个新对象<br>就可以了!</p><p>程序中使用structure作为数据定义时，由于racket的数据类型是动态的，所以对于同样的structure<br>定义可以使用不同的方式来使用它。如书中的ball例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(define-structure ball [location velocity])</span><br><span class="line">1. 在一维时，这样构造实例 (make-ball 10 -5) 可以代表如距离top 10px, -5px的速度向上运动</span><br><span class="line">   (通常left top most is original point)</span><br><span class="line">2. 在二维时，这样构造实例 (make-ball (make-posn 3 4) (make-velo -2 3)), 其中需要额外定义</span><br><span class="line">   (define velo [dx dy])。</span><br></pre></td></tr></table></figure></p><p>正是由于racket类型的动态性，使得ball的定义无法具体规定location, velocity的具体类型，所以<br>以上两种构造实例的方式都是正确的。这种自由度一方面让库函数真正变得抽象化，函数性或功能性<br>更强，另一方面程序员自己编程时应当坚持某一特定的定义方式，避免给自己挖坑。</p><p>当实例间进行嵌套时，即对象的属性是另一个对象，也称为复合对象时，这时与java的级联调用如<br>person.house.price不同的是，racket的获取方法是反过来的，可以理解为of结构，price of house<br>of person, 具体语法为(house-price (person-house p)).当层级较多时，可以利用定义方法进行<br>简化。</p><h3 id="design-with-structure"><a href="#design-with-structure" class="headerlink" title="design with structure"></a>design with structure</h3><p>由于racket的类型动态性，data definition给出了其中属性的具体类型。定义的structure扩展了已有<br>的数据世界集合，而data definition则是通过限定类型划出了其中一部分在程序中使用。<br>下面是使用structure进行方法设计的步骤。</p><ol><li><p>定义structure, 给出instance和example, 这里的data example主要用来给后面的function单元<br>测试作测试数据对象使用。<br>如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(define-struct r3 [x y z])</span><br><span class="line"> ; an R3 is a structure:</span><br><span class="line"> ; (make-r3 number number number)</span><br><span class="line"> </span><br><span class="line"> (define ex1 (make-r3 3 4 5))</span><br><span class="line"> (define ex2 (make-r3 -3 0 7))</span><br></pre></td></tr></table></figure></li><li><p>定义方法的签名，目的和模板, 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; r3-&gt;number</span><br><span class="line">; calculate the distance from r3 to the original point</span><br><span class="line">(define (dis r) (r3-x r))</span><br></pre></td></tr></table></figure></li><li><p>使用前面的对象例子定义方法例子，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(define (dis ex1) (r3-x ex1))</span><br><span class="line">(define (dis ex2) (r3-x ex2))</span><br></pre></td></tr></table></figure></li><li><p>将属性的get方法写入方法模板中。</p></li><li>编写代码实现方法。</li><li>进行测试。</li></ol><h3 id="使用vim和tmux搭建编写运行Racket环境"><a href="#使用vim和tmux搭建编写运行Racket环境" class="headerlink" title="使用vim和tmux搭建编写运行Racket环境"></a>使用vim和tmux搭建编写运行Racket环境</h3><p>学(玩)Racket有一段时间了，跟着教程写了不少习题程序，我通常是用vim写好后在drracket中运行，<br>这也没太大问题，就是Racket编写括号和括号跳转较麻烦(括号键现在按的很熟了shift+9, 不过<br>%号还是够呛…),就想到在网上搜索有没有用vim来写Racket的文章。果然找到了，而且意外找到了<br>SICP的LaTex精美排版电子书和H5网站，这书现在还没学习(看完HowToProgram可以看看)，看网页效果<br>非常精美，也算意外之福, 由此可见网上好的资源如果搜到了，还是有很多的。</p><p>vim环境安装，链接为<a href="https://crash.net.nz/posts/2014/08/configuring-vim-for-sicp/" target="_blank" rel="noopener">crash.net.nz</a></p><ol><li><p>在应用文章前，我先将%改为,a键，.vimrc中加入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;Leader&gt;a %</span><br><span class="line">vnoremap &lt;Leader&gt;a %</span><br><span class="line">   &quot; note that using split can swap 4 file totally, 2 files for each pane</span><br><span class="line">noremap &lt;Leader&gt;g &lt;C-^&gt;</span><br></pre></td></tr></table></figure></li><li><p>在命令中运行命令<code>racket -i -p neil/sicp -l xrepl</code>， neil/sicp是对SICP书进行支持的第三方<br>库，xrepl是Racket extended REPL模式。<br>2019-11-01 21:39:01 添加:<br>加载自己编写的模块程序后，可以同drracket一样在交互区执行命令查看相应结果的命令行为<br><code>racket -it self.rkt -l xrepl</code>, 进入后可以使用<code>,h</code>查看xrepl的相关命令，<code>,e</code>进入自己模块的<br>内部命令空间，这时就可以获取到对应的变量值了。<br>其中，通过,h可以看到使用命令,install!可以将xrepl设置为默认选项，其实就是将<br><code>(require xrepl)</code>写入~/.racketrc文件中。这样以上命令可以简化为<code>racket -it xxx.rkt</code>即可直接<br>使用xrepl.</p></li><li><p>安装tmux.<br><code>sudo apt install tmux</code>.<br>基本命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; create session</span><br><span class="line">tmux new -s sessionName</span><br><span class="line"></span><br><span class="line">; list all sessions</span><br><span class="line">tmux ls </span><br><span class="line"></span><br><span class="line">; detach from session</span><br><span class="line">prefix + d</span><br><span class="line"></span><br><span class="line">; attach to tmux  </span><br><span class="line">tmux attach -t sessionName</span><br><span class="line"></span><br><span class="line">; windows operation</span><br><span class="line">p+c p+&amp; p+p/n/l p+w p+, p+f </span><br><span class="line"></span><br><span class="line">; panes operation</span><br><span class="line">p+&quot;/% p+x p+o p+ctrl+up/down p+alt+up/down </span><br><span class="line"></span><br><span class="line">; tmux kill server</span><br><span class="line">tmux kill-server</span><br></pre></td></tr></table></figure></li></ol><p>修改默认前缀快捷键ctrl+b为ctrl+a, 修改~/.tmux.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># remap prefix to Control + a</span><br><span class="line">set -g prefix C-a</span><br><span class="line">unbind C-b</span><br><span class="line">bind C-a send-prefix</span><br></pre></td></tr></table></figure></p><p>保存后即可，对于已有的session使用命令<code>tmux source-file ~/.tmux.conf</code>使配置生效。<br>注: 不应当修改为ctrl+a, 与全选冲突，弃用！</p><ol start="6"><li>使用额外脚本对lisp文件进行格式化，下载scmindent.rkt.<br>.vimrc中配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocmd filetype lisp,scheme,art setlocal equalprg=scmindent.rkt</span><br></pre></td></tr></table></figure></li></ol><p>使用ggVG=即可。</p><ol start="7"><li>安装vim插件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Plugin &apos;tpope/vim-surround&apos;</span><br><span class="line">Plugin &apos;sjl/tslime.vim&apos;</span><br><span class="line">Plugin &apos;kien/rainbow_parentheses.vim&apos;</span><br><span class="line"></span><br><span class="line">&quot; tslime &#123;&#123;&#123;</span><br><span class="line">let g:tslime_ensure_trailing_newlines = 1</span><br><span class="line">let g:tslime_normal_mapping = &apos;&lt;leader&gt;m&apos;</span><br><span class="line">let g:tslime_visual_mapping = &apos;&lt;leader&gt;m&apos;</span><br><span class="line">let g:tslime_vars_mapping = &apos;&lt;leader&gt;M&apos;</span><br><span class="line">&quot; &#125;&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="在泛化-itemization-中使用对象-structure"><a href="#在泛化-itemization-中使用对象-structure" class="headerlink" title="在泛化(itemization)中使用对象(structure)"></a>在泛化(itemization)中使用对象(structure)</h3><p>当world中有多个独立的对象时，某些对象出现时机可能是动态的，如书中的坦克，UFO和导弹的例子，<br>这时的数据定义可以使用泛化来表示2个对象的世界和3个对象的世界状态。</p><p>泛化——这个东西很神奇，前面提到过，它就表示函数中的一个变量，其类型不受限制，使用时根据<br>具体的值具有不同的类型，如火箭倒计时发射程序中的number类型，string类型。这里将这些基本类型<br>替换为structure对象类型，实现了更高的控制，更明确的表示出itemization是一个万花筒，可以真正<br>变成任何自己需要的对象。</p><p>使用泛化结构设计方法的步骤:</p><ol><li>根据问题描述确定是否需要这种泛化的数据定义，即如果问题描述中有多个不同类型的对象信息(或者<br>不同类型信息间有局部不同)，这时候就需要使用泛化;</li></ol><p>如果需要将不同的信息组合起来就需要结构(即组合成对象)。需要记住的是，如果对象结构太复杂，<br>应当拆分成独立的小结构。</p><p>最后，列出几个数据的例子，一方面检查对象结构，另一方面为测试数据<br>作准备。</p><ol start="2"><li><p>同前面的基本方法设计，写方法签名，方法目的，方法模板。 </p></li><li><p>写出方法的测试案例，对泛化中的每种情况写一个测试案例。</p></li><li><p>实现方法模板。这里涉及到泛化本身的处理和内部结构的处理。泛化同前面一样，每种情况对应cond<br>语句的一种情况，如果泛化使用了结构，每种情况中就需要使用到对应属性的get方法。</p></li></ol><p>这里容易犯的错误是，直接根据问题描述开始写内部属性的get方法(如书中的spaceWar程序，这里就<br>开始写place-image,因为前面画静态图时已经有写好的表达式了)，这里其实应当写一个方法模板来<br>处理这条具体的cond语句情况，<strong>这个方法模板根据问题描述提取出合理的操作步骤</strong>，如spaceWar<br>程序中需要将UFO,TANK这2个物体常量添加背景图片中，就可以相应设计出ufo-render, tank-render<br>方法将处理步骤抽象出来。</p><p>这样做的好处比直接写place-image的好处很明显，直接写place-image完成后明显可以看到render方法<br>中ufo,tank的渲染在aim和fire中重复处理了，这时再优化代码还是需要将类似ufo-render, tank-render<br>的方法提取出来。从这里也看出，方法实现时做好api设计是非常重要的，节省了后期很多代码优化的<br>工作。</p><p>注: 在使用函数式编程时，有个最简单的是有时需要顺序执行2条不同的语句，因为lisp中没有语句的<br>概念，所有命令都是表达式，所以它更多是一种包含的关系，后者将前者的计算结果作为计算因子，如<br>这里的render, ufo-render, tank-render的关系，这一点在编写函数式编程时应当注意。这种机制也<br>确定了程序运行过程中每一步程序的状态都是确定的。</p><ol start="5"><li><p>确定好方法模板后，这一步才是真正实现具体的方法。实现过程中如果某些独立功能，可以使用<br>前面提到的wish-list功能。</p></li><li><p>测试</p></li></ol><p>书中给出了一个问题，以下2个表达式什么时候会得到相同的结果?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(ufo-render ufo (tank-render tank bg))</span><br><span class="line">(tank-render tank (ufo-render ufo bg))</span><br></pre></td></tr></table></figure></p><p>这个问题一看就是数学问题，f(g(x)) = g(f(x)), 那么符合这个条件的f(x),g(x)满足什么条件呢？<br>可以肯定是某种对称性，经过网上搜索，quora上找到答案:原来是f(x),g(x)互为反函数(初高中的数学<br>知识早忘了…), 也可以理解为它们是按y=x这条直线对称的。如y=x^2和x=sqrt(x)就满足这样的条件，<br>f(g(x)) == g(f(x)) = x.从这里也可以看出如何求反函数(inverse function), 将x,y位置互换，再<br>对y进行求值即可…汗！</p><p>spaceWar程序总结:</p><ol><li><p>单个属性的structure,如(define-struct ufo [p])是没有必要的，单个属性的structure可以用<br>该属性类型直接取代。这里ufo即等同于posn类型，没有必要额外定义structure.<br>如后面的(posn-x (ufo-p (aim-ufo aim1)))完全可以直接写为(posn-x (aim-ufo aim1))。</p></li><li><p>对于包含不同数据类型(包括基本类型和structure)的泛化的数据定义，通过注释来说明它的取值范围<br>明显是没有约束力，容易被忽略和违反约定。所以我们可以对于这样的数据定义自定义一个predicate<br>方法来进行约束。如missileOrNot的泛化可以定义如下方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(define (mis? m) (cond</span><br><span class="line">                   [(or (false? m) (posn? m)) #t]</span><br><span class="line">                   [else #f]</span><br><span class="line">                 ))</span><br></pre></td></tr></table></figure></li></ol><p>对mis进行处理时，可以加上该predicate判断，属于防御性编程的一部分，让程序更健壮, 同时在<br>开发中这样做利于在复杂的程序中定位到数据类型不匹配的问题。<br>在big-bang表达式中有一个check-with从句(类似on-tick)，它的参数即可以接受这样一个wordstate?<br>的predicate方法，使得程序在运行中类型出错能及时停止程序运行并给出提示的功能。这在某种程序<br>上其实弥补了world program无法分步调试的缺陷。</p><h2 id="任意多的数据"><a href="#任意多的数据" class="headerlink" title="任意多的数据"></a>任意多的数据</h2><p>第一章讲完了基本数据类型和结构(对象), 这一章开始讲集合。<br>因为对象的数量是对象的外部性质，不属于对象本身的属性，所以这就涉及到数据结构的问题。<br>Racket也正是通过上面的data definition(其实也可以翻译为数据结构)来实现的集合。<br>同java中的内置数组不同，Racket使用了递归定义(自引用)实现了list集合。</p><h3 id="自引用数据定义设计"><a href="#自引用数据定义设计" class="headerlink" title="自引用数据定义设计"></a>自引用数据定义设计</h3><ol><li><p>数据定义必须包含2个条件从句，一个是没有自引用的表达式，如list集合定义中的’().另一个则是<br>包含自引用的表达式。可以通过构造例子来验证数据定义是否定义正确。</p></li><li><p>设计方法步骤不变，方法签名，目的，模板。只需要关注方法的参数类型即可，无需关心具体实现<br>步骤。</p></li><li><p>造方法例子时需要多造几个应用了自引用条件从句的例子。</p></li><li><p>因为一个自引用的数据定义本质上还是泛型数据定义, 所以实现方法时仍然是根据泛型的实现步骤<br>来实现，如构造与泛型的条件对应的cond条件从句。其中，模板中的自引用位置应当与数据定义中的<br>自引用位置保持一致，图示中的箭头可以使用本方法的再次应用来体现。这样的方法自引用即为<br>递归，或自然递归。</p></li><li><p>实现方法时应从无递归的条件从句(或基础例子)开始，再实现递归从句。对于自然递归，使用时应当<br>假设本方法已经实现了相应的功能，这样就可以得到需要的递归处理。剩下的步骤就是如何将不同的<br>值连接起来，这里包括数据定义中属性的get方法和自然递归方法调用。如计算list列表中元素的个数<br>可以想到就是在(how-many (rest list))的基础上加1即可得到需要的当前list集合的元素个数。有时候<br>这样的关系比较复杂，可以利用书中建议的表格方法，将方法例子中单个值和需要的值进行比对猜测得到<br>之间的关系，随后验证该猜测适用于所有的list元素。必要时可以借助辅助方法或嵌套条件得到需要的<br>链接方法。</p></li><li><p>最后将所有方法的例子转变为测试案例(最好是一开始就写为测试案例)，并确保测试覆盖率。</p></li></ol><h3 id="以集合为单元进行操作"><a href="#以集合为单元进行操作" class="headerlink" title="以集合为单元进行操作"></a>以集合为单元进行操作</h3><p>以上模板只适用于list集合的直接操作，对于如需要求list集合所有元素平均值的非直接处理，可以<br>先以list集合为单位进行操作拆分后再使用以上模板处理，如平均值=元素和/元素个数，后两者都<br>可以直接使用自然递归处理。</p><h3 id="自然数"><a href="#自然数" class="headerlink" title="自然数"></a>自然数</h3><p>如果想要得到一个包含了n个重复元素e的list集合怎么处理？作为一个java程序员，第一反应就是写一个<br>循环，以n为计数器，每次向集合中添加元素e. racket作为函数式编程语言，目前没有看到提供循环<br>功能，更多是使用递归。书中通过解析自然数(这里的计数器)的本质——自然数自带递归属性。<br>这样精妙的利用递归代替循环实现了同样的功能。代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; a N is one of</span><br><span class="line">; 0</span><br><span class="line">; (add1 N)</span><br><span class="line"></span><br><span class="line">; 这里add1类似于cons的使用方式</span><br><span class="line">(define a (add1 (add1 (add1 0))))</span><br><span class="line">(define b (add1 (add1 0)))</span><br><span class="line">(define c 0)</span><br><span class="line"></span><br><span class="line">; N string -&gt; list</span><br><span class="line">;  get a N&apos;s string list</span><br><span class="line">(define (replist n str) (cond</span><br><span class="line">                          [(zero? n) &apos;()]</span><br><span class="line">                          [(positive? n) (cons str (replist (sub1 n) str))]))</span><br><span class="line"></span><br><span class="line">(check-expect (replist a &quot;wtt&quot;) (cons &quot;wtt&quot; (cons &quot;wtt&quot; (cons &quot;wtt&quot; &apos;()))))</span><br><span class="line">(check-expect (replist b &quot;cll&quot;) (cons &quot;cll&quot; (cons &quot;cll&quot; &apos;())))</span><br><span class="line">(check-expect (replist c &quot;ss&quot;) &apos;())</span><br></pre></td></tr></table></figure></p><p>从这里自然数的定义也可以看出，这种自引用的机制确实实现了书中的章节题目”无限大的数据”。<br>本质上还是利用了递归的无限性从而得到无限大的数据集合。</p><p>注：racket中没有方法重载的概念，重复定义相同的方法名会报错。</p><h3 id="russian-doll"><a href="#russian-doll" class="headerlink" title="russian doll"></a>russian doll</h3><p>俄罗斯套娃的本质还是有自引用的对象，转换为java对象即为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Rd &#123;</span><br><span class="line"> private String color;</span><br><span class="line"> private Rd doll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="常用的list集合方法"><a href="#常用的list集合方法" class="headerlink" title="常用的list集合方法"></a>常用的list集合方法</h3><p>这里列举出BSL中已经封装好有用的list集合方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(empty? null)  // null is &apos;()</span><br><span class="line">(list 2 4 6)   // simplify the list&apos;s initial step</span><br><span class="line">(length (cons 2 (cons 3 (cons 4 &apos;()))))   // list size</span><br><span class="line">(member? 2 (cons 2 &apos;()))   // list contains </span><br><span class="line">(make-list 4 &quot;wtt&quot;)       // quickly make a list with same elements </span><br><span class="line">(reverse (list 1 2 3))   // reverse a list</span><br><span class="line">(append (list 2 3) (list 4 5)) // merge lists as arguments order</span><br></pre></td></tr></table></figure></p><h3 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h3><p>工具函数准则:</p><ol><li>对每一个任务定义一个方法，对每一个存在依赖的数量关系定义一个工具函数。</li><li>针对每一个数据定义定义一个方法模板，当一个数据定义引用到另外一个数据定义时，就使用一个<br>工具函数进行处理。</li></ol><p>在实际实现方法模板的过程中，有以下几种情况需要使用工具函数:</p><ol><li>如果值的组合需要用到特定领域的知识，如合成图片，会计，音乐或科学知识等，这时应使用工具<br>函数。</li><li>如果值的组合依赖某个条件，当该条件的逻辑处理过于复杂时，此时也应当使用工具函数。</li><li>如果值的组合需要处理一个自引用数据定义中的元素时，如一个列表或自然数时，应考虑使用工具<br>函数。</li><li>如果一切都失败了，可以考虑实现一个更加一般化的函数，将需要的函数作为特例来解决。</li></ol><p>总体来说，程序设计的关键在于维护”方法愿望清单”。在向清单添加方法前，应先检查所使用的编程<br>语言提供的类库中是否已提供需要的功能。</p><h3 id="递归的工具函数"><a href="#递归的工具函数" class="headerlink" title="递归的工具函数"></a>递归的工具函数</h3><p>经测试，对数列进行排序，由于list本身的自引用特性(first, rest方法的使用)，很容易就实现了<br>插入排序算法。</p><p>注： 经编写prefixes list练习题发现, list和cons的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(cons (list &quot;a&quot;) (list &quot;b&quot;))  -&gt; &apos;((&quot;a&quot;) &quot;b&quot;)</span><br><span class="line">(list (list &quot;a&quot;) (list &quot;b&quot;))  -&gt; &apos;((&quot;a&quot;) (&quot;b&quot;))</span><br></pre></td></tr></table></figure></p><p>可以看到，使用cons时后面的”b”是以元素的形式直接链接到最终结果中，说明cons适合作为同级元素<br>连接; 而使用list时后面的”b”被括号包裹起来是作为一个list集合链接到结果中，它是一个整体单元。</p><p>而prefixes练习中，<code>(add-head (first ls) (prefixes (rest ls)))</code>递归部分明显其中的元素需要被<br>填充进来，它不能作为一个整体，所以它需要使用cons与前面的(list (first ls))进行链接。<br>即最终结果为<code>(cons  (list (first ls))  (add-head (first ls) (prefixes (rest ls))) )</code>.</p><p>### </p><p>### </p><p>##</p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20191013_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;note of how to program&lt;br&gt;
    
    </summary>
    
      <category term="Method" scheme="http://www.taoblog.cn/categories/Method/"/>
    
    
      <category term="Method" scheme="http://www.taoblog.cn/tags/Method/"/>
    
      <category term="Racket" scheme="http://www.taoblog.cn/tags/Racket/"/>
    
      <category term="Lisp" scheme="http://www.taoblog.cn/tags/Lisp/"/>
    
  </entry>
  
  <entry>
    <title>CrackDownInterviewNote</title>
    <link href="http://www.taoblog.cn/post/394717d4/"/>
    <id>http://www.taoblog.cn/post/394717d4/</id>
    <published>2019-09-25T14:02:43.000Z</published>
    <updated>2019-09-28T14:41:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>CrackdownInterview note<br><a id="more"></a></p><h2 id="big-O"><a href="#big-O" class="headerlink" title="big O"></a>big O</h2><h3 id="一个类比"><a href="#一个类比" class="headerlink" title="一个类比"></a>一个类比</h3><p>一个大文件进行远距离传输，用网络传输是O(size), 传输时间随文件大小线性增长;<br>直接使用飞机或其他物理方式传输是O(1), 即传输时间不受文件大小影响，是一个常量。<br>可以看到，无论这个常量多么巨大，线性增长速度多慢，线性增长总会在某个时间点超过常量时间。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>学术界:<br>O(n) big O 代表一个算法的上界，即最慢需要的时间，如O(n^2), O(2^n)等。<br>Ω(n) big Omega代表一个算法的下界，即最快需要的时间，如Ω(1), Ω(log N)等。<br>θ(n) big Theta 同时代表上下界，给出了运行时间的闭合区间。<br>工业界:<br>通常用O(n)来说明Θ(n)的范围，即工业界说O(n)指的是一个闭合区间。如说某个算法是O(n)，实际上<br>指的是其上下界都是O(n)级别。</p><p>上面的参数代表了运行时间随输入规模的增长速度，对于个别的输入数据，有最快测试案例，最慢测试<br>案例和中等测试案例。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>有时空间占有程度不随调用次数递增(如递归就是每调用一次就增加一个调用栈，为O(n)), 有的方法<br>调用完成后就释放了相应的空间，所以总的空间复杂度实际为O(1).</p><h3 id="去除常量"><a href="#去除常量" class="headerlink" title="去除常量"></a>去除常量</h3><p>O(2n)相当于O(n)，因为O(n)只是描述了时间或空间的增长速度。<br>需要记住的是O(n)级别的算法并不总是比O(n^2)级别算法快。</p><h3 id="去除不重要的项"><a href="#去除不重要的项" class="headerlink" title="去除不重要的项"></a>去除不重要的项</h3><p>如O(n^2 + n)等同于O(n^2), O(n + log n)等同于O(n).</p><h3 id="多步骤算法-数量级的加法和乘法"><a href="#多步骤算法-数量级的加法和乘法" class="headerlink" title="多步骤算法: 数量级的加法和乘法"></a>多步骤算法: 数量级的加法和乘法</h3><ol><li>先做A，做完后再做B,就是加法O(A + B).2个独立的循环</li><li>在做A的时候，每一步都要做B,就是乘法O(A * B). 循环嵌套。</li></ol><h3 id="平摊的时间"><a href="#平摊的时间" class="headerlink" title="平摊的时间"></a>平摊的时间</h3><p>ArrayList是一个动态数组实现的列表。那么插入一个新元素需要多大的数量级呢？<br>如果数组全满了，需要扩容一倍，将现有元素复制到新数组后再插入，需要O(n).如果没满，只需要O(1)<br>即可。如何得到平均值？这时我们就需要用到时间的分摊。</p><p>我们知道数组的大小是翻倍增长的，大小为1, 2, 4, 8…, 所以插入x个元素的总时间为<br>1+2+4+8+…+x, 这个求和算式可以反过来看即x+x/2+x/4+…+1, 可以看到大小约为2x.<br>所以平均插入一个元素的时间为2x/x = 1即O(1).<br>注： 求解1 + 2 + 2^2 + 2^3 + … + 2^n的和，还可以通过二进制来计算，即1 + 10 + 100 +<br>1000 + …  + 1…0(n个0) = 1…1(n个1), 即2^(n + 1) - 1. </p><p>再注: 高斯求和 1+2+3+…+n, 当n是奇数时，n和1配对，有n/2对和为(n+1)的数据对，和为n(n+1)/2;<br>当n是偶数时，n和0配对，有(n+1)/2对和为n的数据对，和也为n(n+1)/2.</p><h3 id="Log-N-级别的运行时间"><a href="#Log-N-级别的运行时间" class="headerlink" title="Log N 级别的运行时间"></a>Log N 级别的运行时间</h3><p>二分查找法为什么是log N级别？<br>二分查找法在已经排好序的数列中每次选择中间值进行比较，比较过后砍去一半值，这样需要查找的<br>范围就缩小了一半，X, X/2, X/4,…, 1, 如何得到需要比较的次数？<br>同上面求ArrayList插入元素的性能类似，可以反过来看，从1开始递增，1,2,4, …, X, 每次都乘2<br>最后得到X, 即2^n = X, 从而可以得到需要比较的次数为n = logX, 即log N级别。</p><p>注: 对数换底公式推导。loga P = V, 求logbP?<br>loga P = V;  (1) =&gt;  P = a^V;<br>使用底数b两边求对数:<br>logb P = logb a^V;<br>=&gt; logb P = V * logb a;<br>=&gt; logb P / logb a = V;<br>同时一开始有loga P = V;  (1)<br>所以得出 loga P = logb P / logb a;</p><p>从换底公式可以看出对于任意的底数都可以使用换底公式进行转换，这样不同数量级间就只相差一个<br>1/logb a的常量因子，不影响数量级。</p><h3 id="Recursive-Runtimes"><a href="#Recursive-Runtimes" class="headerlink" title="Recursive Runtimes"></a>Recursive Runtimes</h3><p>如下的递归函数的时间复杂度是多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int f(n) &#123;</span><br><span class="line"> if (n &lt;= 1) return 1; </span><br><span class="line"> return f(n - 1) + f(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次递归调用都调用了2次f函数，所以总的调用次数为1 + 2 + 2^2 + 2^3 + … 2^n = 2^(n+1) - 1.<br>所以这个函数的时间复杂度为O(2^n).<br>一般来说，递归的数量级是O(branches^depth), branches为每次递归调用的调用次数，depth为递归<br>调用栈的深度。<br>注: 和logN数量级不同，指数的底数不能被忽略，如2^n和8^n，因为8^n = 2 ^ 3n = 2^n * 2^2n,<br>这里的因子为2^2n，不是常量，无法被忽略。</p><p>这个函数的空间复杂度为O(n)。</p><p>注: 经测试f(n - 1) + f(n - 1)的耗时和2 * f(n - 1)是不一样的！！！后者明显快很多(在n = 30时)，<br>所以编写代码时应尽量优化算式，尽可能减少显式调用。</p><p>再注: 如果分支是1, 如f(n)只调用了f(n - 1)，此时如果套用公式是O(1)常量时间，显然是不对的。<br>同前面计算分支数为2时一样，这里每次递归调用都为1次，所以总次数为1 × n = n次，所以时间复杂度<br>为O(n). 从这里也可以看出，递归调用的时间随着分支数的增加是非常迅猛的增加的, O(N),<br>O(2^N), O(3^N)…</p><p>再注: 尾递归<br>普通的递归方法在递归调用结束后还需要执行其他语句，所以调用前需要保留当前栈(方法)的环境以供<br>调用方法返回后进一步处理，而尾递归调用中方法调用结束后无需进行其他处理，所以不需要保存当前栈<br>的环境，直接返回上一步即可(这种直接覆盖调用栈的机制称为尾调用优化TCO: Tail Call Optimization，<br>Java编译器不支持TCO, C编译器支持TCO, 所以Java中可以使用循环，C语言使用尾递归)。</p><p>普通递归容易产生栈溢出，而尾递归只存在一个调用记录，所以永远不会发生栈溢出的问题。<br>不过尾递归需要额外的变量来保存每一次调用的中间结果，它以这种方式来得到最终结果。<br>因为尾递归不需要保存当前的栈环境，所以它只占用恒定大小的内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(x) &#123;</span><br><span class="line">  let y = g(x);  </span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种情况也不算尾调用, 因为递归完成后还需要进行赋值操作，即使它和直接<code>return g(x);</code>语义相同。</p><p>尾递归例子，计算阶乘。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 普通递归</span><br><span class="line">function fac(n) &#123; </span><br><span class="line">  if (n &lt;= 0) return 1;   </span><br><span class="line">  return n * fac(n - 1);</span><br><span class="line">&#125;</span><br><span class="line">fac(5);</span><br><span class="line"></span><br><span class="line">// 尾递归</span><br><span class="line">function facTail(n, total) &#123; </span><br><span class="line">  if (n &lt;= 0) return 1;   </span><br><span class="line">  return facTail(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">facTail(5, 1);   // total初始值为1，保存每次调用时得到的中间结果</span><br></pre></td></tr></table></figure></p><p>将一般的递归方法改造成尾递归时，将所有的中间变量改写为函数参数，在方法最后直接调用自身即可。<br>另外对于外界调用者来说调用facTail(5, 1)得到5！的值有时很费解，可以用以下2种办法解决:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1. 外面再套一层函数</span><br><span class="line">function int fac(int n)&#123;</span><br><span class="line">  return facTail(n, 1); </span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">function seal(fn, n) &#123;</span><br><span class="line">  return function(m) &#123;</span><br><span class="line">    return fn.call(this, m, n); // 这里利用闭包特性保存了fn中的参数作为m  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">const ff = seal(facTail, 1); // total = 1</span><br><span class="line">ff(5);</span><br><span class="line">2. 使用函数式编程中的柯里化的概念，将多参数变为单参数，返回由剩下参数组成的函数</span><br><span class="line">// 柯里化函数</span><br><span class="line">function curry(fn) &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var innerArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">        var finalArgs = innerArgs.concat(args);</span><br><span class="line">        return fn.apply(null, finalArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var factorial = curry(facTail, 1); </span><br><span class="line">factorial(5);</span><br><span class="line"></span><br><span class="line">// jdk 8 λ表达式的柯里化</span><br><span class="line">Function&lt;Integer, Supplier&lt;Integer&gt;&gt; curry = x -&gt; () -&gt; facTail(x, 1);</span><br><span class="line">curry.apply(5).get();  // 按照箭头顺序从左到右执行</span><br></pre></td></tr></table></figure></p><h3 id="例子和练习"><a href="#例子和练习" class="headerlink" title="例子和练习"></a>例子和练习</h3><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">  for(int j = 0; j &lt; b.length; j++) &#123;</span><br><span class="line">    if (b[j] &lt; a[i]) &#123;</span><br><span class="line">      System.out.println(a[i] + &quot;, &quot; + b[j]); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>if语句本身是O(1), 所以整体的时间复杂度为O(ab)，不是O(N^2), 因为这不是1个输入，2个不同的<br>输入都有影响。<br>注: 如果if语句换成for(int k = 0; k &lt; 100000; k++){….}, 复杂度仍然是O(ab), 常量不影响，<br>无论它有多大…</p><ol start="2"><li><p>O(n + p) 当p &lt; n/2时，n占据主导地位，p可以舍去，所以O(n + p)与O(n)数量级相同。<br>同理O(n + logN), O(2n)都相同，而O(N + M)因为M与N关系不明，所以无法等同于O(N).</p></li><li><p>有一个字符串数组，如果需要先对其中每个字符串进行排序，然后对整个数组排序，它的时间复杂度<br>是多少?</p></li></ol><p>这里最大的错误就是简单的用O(n)之类的表达式来表示，因为它有2个输入集合(与题1一样)，数组的<br>长度a和最大字符串的长度s。</p><ol><li>字符串排序，快排实现复杂度为O(slog s), a个元素就是O(a * slog s);</li><li>数组排序，这里不是简单的O(alog a), 因为字符串比较与字符或数字比较不同，它不是常量时间，<br>而是线性的O(s), 所以数组排序为O(s * a log a);</li><li>总体排序时间是用加法，即O(as * (log a + log s));</li></ol><ol start="4"><li><p>二叉查找树所有结点值的和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(Node n)&#123;</span><br><span class="line">  if (n == null) return 0; </span><br><span class="line">  return sum(n.left) + n.value + sum(n.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从算法的含义看，由于要加上所有节点的和，所以每个节点都会被遍历一次，所以复杂度即O(N). </li><li>从递归模型看，前面说到O(branches^depth), branches = 2, 由于是二叉查找树，前面计算过<br>二叉查找树(从1累乘2到n)需要的次数为logN，即它的高度depth=logN, 所以为O(2^logN) = O(N).</li></ol></li><li><p>判断一个数是不是质数。<br>如33 = 11 * 3; 11 &gt; sqrt(33), 这意味着如果33可以整除一个比它的平方根大的数，那么它一定也可以<br>整除一个比平方根小的数，如这里的3.<br>所以可以这样判断是否是素数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean isPrime(int n) &#123;</span><br><span class="line">  for (int x = 2; x * x &lt;= n; x++) &#123;</span><br><span class="line">    if (n % x == 0) return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个方法的复杂度是O(sqrt(N)), N的二分之一次方。不能近似为O(N)!</p><ol start="6"><li>打印出一个字符串中所有字符的全排列all permutations of a string<br>下面这个算法巧妙利用了循环中的递归(类似深度优先排序)的方法实现了全排列:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void permutation(String str) &#123;</span><br><span class="line">  permutation(str, &quot;&quot;); </span><br><span class="line">  // 空前缀代表全排列，这里有值时最终结果是str所有排列前都有相同的前缀(由以下算法实现决定)</span><br><span class="line">&#125;</span><br><span class="line">void permutation(String str, String prefix) &#123;</span><br><span class="line">  </span><br><span class="line">  if (str.length() == 0) &#123;</span><br><span class="line">     System.out.println(prefix);  // 已无可排字符，打印出一种组合   </span><br><span class="line">  &#125;else&#123;</span><br><span class="line">     for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">       String remainder = str.subString(0, i) + subString(i+1); // 挖掉str.charAt(i)</span><br><span class="line">       permutation(remainder, prefix + str.charAt(i));   </span><br><span class="line">       // 每次排好(挖掉)一个后，继续排列剩余部分 </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如何计算它的时间复杂度?<br>循环中套用递归，它的函数栈可以理解为一颗巨大的树。我们可以从一些特性出发得到该算法的一个<br>近似上界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 计算permutation(String, prefix)调用的总次数。</span><br><span class="line"></span><br><span class="line">  1. 先计算base permutation的次数，即执行了打印语句的permutation()方法的调用次数，也可以</span><br><span class="line">理解为整棵树的叶子节点个数。</span><br><span class="line"></span><br><span class="line">考虑所有排列的种数，对于长度为n的字符串，</span><br><span class="line">第一个位置有n种选择，第一个位置排好后，对于第二个位置有n-1种选择(对应于前面第一个位置的</span><br><span class="line">每种情况)，依次类推，可以得到全部排列的总数为n*(n-1)*(n-2)*... = n!.</span><br><span class="line">因为每种排列都需要列出并打印，所以叶子节点个数为O(n!).</span><br><span class="line"></span><br><span class="line">  2. 计算base permutation调用前调用permutation()方法的次数，即那些不满足打印条件未打印的</span><br><span class="line">permutation方法调用次数，也可以理解为树中非叶子节点的个数。</span><br><span class="line"></span><br><span class="line">可以从树的角度出发，一共有n!个叶子节点，每个节点到根节点的距离都是n(每次循环都挖掉(排列)</span><br><span class="line">一个字符，得到最终的排列结果需要每个位置都排好，所以路径长度是n), 所以树的总节点个数不</span><br><span class="line">超过n! * n个。</span><br><span class="line"></span><br><span class="line">2. 计算每次permutation(string, prefix)方法调用消耗的时间。</span><br><span class="line"></span><br><span class="line">对于打印语句执行的次数: str即remainder, 当remainder为空时就打印一次(由于循环中每次挖掉一个</span><br><span class="line">字符), 即只剩一个字符时打印一次(当多于一个字符时str.length() &gt; 0不满足条件不打印).</span><br><span class="line">每个字符都要打印，所以打印语句的执行次数即为字符串的长度，为O(n).</span><br><span class="line">同理，由于循环内每次循环都是挖掉一个字符，循环内的拼接字符串和递归调用也是执行O(n)次。</span><br><span class="line">所以每次permutation方法执行的复杂度是O(n)。</span><br><span class="line"></span><br><span class="line">3. 计算总共花的时间 </span><br><span class="line">单此调用为O(n)次，总共需要调用O(n * n!)次，所以时间复杂度为O(n^2 * n!)。</span><br></pre></td></tr></table></figure><ol start="7"><li>斐波纳契数列的复杂度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fib(n) &#123;</span><br><span class="line">  if (n &lt;= 0) return 0;</span><br><span class="line">  if (n == 1) return 1;</span><br><span class="line">  return fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>由前面递归的公式得出时间复杂度为O(2^N), 高度为n(从n一直到1)<br>注: 更精确的上界为O(1.6^n).可由特征根方程得出。</p><ol start="8"><li>顺序打印斐波纳契数列中的数字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void allFib(int n) &#123;</span><br><span class="line">  for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    System.out.println(i + &quot;:&quot; + fib(i));  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>复杂度为1 + 2^1 + 2^2 + 2^3 +…+2^n = 2^(n+1);所以复杂度仍然为O(2^n);</p><ol start="9"><li><p>顺序打印1到n(闭区间)中2的指数值，如1, 2, 4, 8…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int powerOf2(int n) &#123;</span><br><span class="line">  if (n == 0) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;else if (n == 1) &#123;</span><br><span class="line">    System.out.println(1);  </span><br><span class="line">    return 1;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    int prev = powerOf2(n/2);</span><br><span class="line">    int cur = prev * 2;</span><br><span class="line">    Sytem.out.println(cur);</span><br><span class="line">    return cur;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>从它做了什么来计算，即算法轨迹。从n到n/2, n/4,…到1，到1或0时结束递归开始返回<br>(0不打印), 每次都打印当前值，所以同二分查找一样，1以2倍的速度递增到n，为O(logN). </p></li><li><p>从题目意思来计算，它需要打印2的指数为1到n的值，而每次powerOf2方法都打印1次，所以<br>powerOf2方法的调用次数需要与1到n间2的指数值个数相同，即O(logN).</p></li><li><p>从O(N)的含义出发，即输入规模增加时耗用时间的增加速率。可以从代码中看到，当n变为n+1时，<br>它并不会打印语句，因为除以2后调用的是同样的powerOf2(n/2).需要是2n才会多调用1次方法，<br>即输入翻倍后才会多调用一次，所以方法的调用次数等于从1到n的翻倍次数，为O(logN).</p></li></ol></li></ol><p>注: 该题虽然简单，但提供了3种计算的不同角度: 最常见的算法轨迹，题目要求和实现的结合(需要<br>保证算法的正确性)，从O(N)的定义出发。</p><p>O(b)<br>O(ab)<br>O(1)<br>O(a/b)<br>O()<br>O()<br>O()</p><p>## </p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190925_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CrackdownInterview note&lt;br&gt;
    
    </summary>
    
      <category term="Interview" scheme="http://www.taoblog.cn/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://www.taoblog.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Java3_Core10Note</title>
    <link href="http://www.taoblog.cn/post/65ea4e77/"/>
    <id>http://www.taoblog.cn/post/65ea4e77/</id>
    <published>2019-09-17T08:26:16.000Z</published>
    <updated>2021-03-25T07:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java, Char with UTF-16, C++, 数组，<br><a id="more"></a></p><h2 id="图形程序设计，事件处理，Swing用户界面组件-略"><a href="#图形程序设计，事件处理，Swing用户界面组件-略" class="headerlink" title="图形程序设计，事件处理，Swing用户界面组件(略)"></a>图形程序设计，事件处理，Swing用户界面组件(略)</h2><h2 id="部署java应用程序"><a href="#部署java应用程序" class="headerlink" title="部署java应用程序"></a>部署java应用程序</h2><h3 id="JAR文件"><a href="#JAR文件" class="headerlink" title="JAR文件"></a>JAR文件</h3><p>   1.1 创建jar文件<br>使用jdk自带的jar命令创建jar文件，如:<br><code>jar cvf jarFileName file1 file2 ...</code><br>jar命令类似于tar命令。jar包中除了包含类文件，还可以包含图像，声音等其他类型文件。<br>注: 前面的包密封性中有提到相关命令。</p><p>   1.2 清单文件<br>每个jar文件都包含一个用于描述归档特征的清单文件(manifest), 文件名为MANIFEST.MF, 位于<br>META-INF目录下。清单中可以包含多个条目，分为多个节，节之间用空行分开，第一节称为主节，<br>作用于整个jar包。<br><code>jar cvfm  XXX.jar .\manifest.txt .</code></p><p>   1.3 可执行jar文件<br>可以通过以下2种方式指定程序执行入口:</p><ol><li><code>jar cvfe MyProgram.jar com.xxx.MainAppClass files</code></li><li><p>清单文件中指定主类: <code>Main-Class: com.xxx.MainAppClass</code><br>清单文件最后一行必须以换行符结束。<br>指定后使用<code>java -jar XXX.jar</code>命令启动程序。</p><p>1.4 资源<br>类加载器可以记住类的位置，在同一位置下查找相关的资源文件，如声音，图像，文本等。代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream stream = ResourceTest.class.getResourceAsStream(&quot;about.txt&quot;);</span><br><span class="line">Scanner in = new Scanner(stream, &quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure></li></ol><p>如果没有找到该资源 ，返回null，不会抛出异常或发生I/O错误。<br>资源的路径使用”/“进行分隔，不用关注具体操作系统目录的分隔符。</p><p>   1.5 密封<br>可以在清单文件主节中增加<code>Sealed: true</code>来默认全局密封，也可以增加一节，指定想要密封的包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Name: com/XXX/XXX/</span><br><span class="line">Sealed: true</span><br></pre></td></tr></table></figure></p><p>再使用jar命令将改动后的清单文件打入到jar包中。</p><h3 id="应用首选项的存储"><a href="#应用首选项的存储" class="headerlink" title="应用首选项的存储"></a>应用首选项的存储</h3><ol><li>属性映射<br>即前面提到的Properties类。可以使用properties.store(outputStream, commentString)方法将属性<br>映射值存储到某一个具体的文件中。使用properties.load(inputStream)方法从文件中加载属性值。</li></ol><p>可以在查找某个属性值时提供默认值，还可以在初始化属性对象时即提供一个默认的属性对象集批量<br>提供默认值。</p><p>常用方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.System类</span><br><span class="line">   1. Properties getProperties()  获取所有系统属性</span><br><span class="line">   2. String getProperty(String key) 获取允许获取的指定属性值，否则抛出安全异常</span><br><span class="line">java.util.Properties类</span><br><span class="line">   1. Properties(Properties default)  用一组默认值创建一个空映射 </span><br><span class="line">   2. String getProperty(String key) 获取指定属性值</span><br><span class="line">   3. String getProperty(String key, String defaultValue) 指定默认值的获取属性值</span><br><span class="line">   4. Object setProperty(String key, String value)  设置一个属性值</span><br><span class="line">   5. void load(InputStream in)  从输入流中加载属性映射</span><br><span class="line">   6. void store(outputStream, String header)  将映射保存到一个输出流，header为标题</span><br></pre></td></tr></table></figure></p><ol start="2"><li>首选项API<br>使用Properties类存储配置信息存在2大问题:<ol><li>有些操作系统没有主目录的概念，所以无法确定统一的配置文件存储位置。</li><li>关于配置文件命名没有规范(程序员自己在程序中指定)，所以用户安装多个应用程序时会产生命名<br>冲突。<br>java.util.prefs.Preferences类解决了这个问题。在windows系统中它使用注册表存储配置信息，Linux<br>系统中使用文件系统存储配置信息。Preferences存储结构是树状结构，每个树节点的路径类似于包名，<br>节点中是一个单独的键值对表。不同的用户可以有不同的树，另外还有一颗系统树(从前面这些树特性<br>来看，Preferences与windows的注册中心拥有一样的特性, 实际上Preferences是个抽象类，它的具体<br>实现类即WindowsPreferences, 就是基于Windows系统的注册表实现的)。</li></ol></li></ol><p>可以从用户树或系统树的根节点开始访问树，再根据根节点和节点路径得到具体的节点对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Preferences root = Preferences.userRoot();</span><br><span class="line">// Preferences root = Preferences.systemRoot();</span><br><span class="line">Preferences node = root.node(&quot;/com/xxx/myapp&quot;);</span><br></pre></td></tr></table></figure></p><p>当节点路径为某个类的包名时，可以根据该类的对象获取该节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Preferences node = Preferences.userNodeForPackage(class);</span><br><span class="line">// Preferences node = Preferences.systemNodeForPackage(class);</span><br></pre></td></tr></table></figure></p><p>获取属性值必须指定一个默认值，因为可能该属性不存在，或程序与存储库断开链接等原因，具体方法<br>有get(String key, String defaultValue), getInt(key, int df), getDouble(key, double df),<br>getByteArray(key, byte[] df)等，相应的设置属性值的方法为put(String key, String value),<br>putDouble(key, val)等方法。node.keys()方法可以返回该节点的所有键。</p><p>另外当需要迁移属性配置时，可以使用Preferences类的导入导出功能，<br>方法为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void exportSubtree(outputStream);  // 导出一颗子树 xml格式</span><br><span class="line">void exportNode(OutputStream);  // 导出一个节点</span><br><span class="line">void importPreferences(inputStream); // 导入数据</span><br></pre></td></tr></table></figure></p><p>总之，Preferences类为修改Windows系统注册表配置项提供了一个便利的工具，是一个方便多应用协作<br>的系统级配置工具。</p><h3 id="服务加载器"><a href="#服务加载器" class="headerlink" title="服务加载器"></a>服务加载器</h3><p>看完书，ServiceLoader类的源码和网上查找相关资料才发现这是一个非常重要的设计思想。<br>调用服务分2方，服务调用者和服务提供者，由服务提供者(或服务实现者)制定调用的规则时，这是<br>我们熟知的API(Application Programming Interface: 应用编程接口)。但有些情况下需要服务调用<br>者指定调用的规则，如eclipse, IntelliJ的插件体系，这种情况叫SPI(Service Provider Interface:<br>服务提供接口), 即调用者给实现者指定了需要实现的接口规则。</p><p>jdk通过ServiceLoader类实现了SPI思想，ServiceLoader类本身是一个泛型类，可以指定具体的接口类型，<br>它定义了SPI的具体操作步骤: 即SPI本身实现的机制，具体的接口还是要程序员自己定义。</p><p>如ServiceLoader类指定了服务提供者的jar包的META-INF/services目录下需要一个UTF-8编码的文本<br>文件，文件名为接口的全限定名，文件内容是该接口的实现类。通过ServiceLoader.load(service.class)<br>方法初始化ServiceLoader类，然后就可以调用ServiceLoader类的迭代器遍历文本文件中的实现类了，<br>在遍历时进行处理得到需要的实现类。</p><p>SPI的具体应用有DriverManager的驱动实现，通过mysql-connector-java.jar包的META-INF/services<br>目录下既可以发现这样一个配置文件, 文件名为java.sql.Driver，即同一个驱动接口类，其中定义了<br>mysql的驱动实现类(oracle的驱动实现jar包没有使用spi，所以它还是需要使用Class.forName方法<br>加载相应的驱动)。</p><p>eclipse或idea的插件体系是SPI思想的很好体现，作为服务调用方它们指定插件需要的文件和配置信息，<br>插件开发者按要求开发完集成到开发平台时，开发平台不用知道插件的具体实现，按”接口”进行统一加载<br>处理即可。</p><p>其他的SPI应用有spring的自动扫描注解，自定义作用域scope, 自定义标签等。<br>可以说只要是服务调用者制定了实现接口时，都属于SPI的应用。</p><h3 id="applet"><a href="#applet" class="headerlink" title="applet"></a>applet</h3><p>java的applet都知道已经过时了，但可以作为技术发展历史了解一下:它是通过html页面上一个特殊<br>的applet标签来加载对应的jar包和class类, 同时需要指定applet的位置。applet标签可以给java类<br>传递参数，还可以处理图像和音频。</p><h3 id="Java-Web-Start"><a href="#Java-Web-Start" class="headerlink" title="Java Web Start"></a>Java Web Start</h3><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>线程和进程的区别:<br>不同进程有自己的一整套变量，而线程是共享数据。共享数据使得线程间通信比进程间通信更容易。<br>同时，创建、销毁一个线程开销比进程小。</p><ol><li>什么是线程</li></ol><p>书中弹球的例子说明了多线程一个最常用的使用场景: 用户对程序处理的中断请求操作。<br>即点击关闭按钮需要能够中断弹球的循环移动处理。<br>推荐建立线程的方法:</p><ol><li>使用λ表达式实现Runnable接口。</li><li>使用该Runnable接口初始化一个线程Thread thread = new Thread(runnable);</li><li>启动线程thread.start()(调用run()方法只是执行一个方法，没有启动线程);</li></ol><p>不推荐使用继承Thread类的方式启动线程，因为通过继承的方式比实现接口的方式耦合性更强。<br>弹球例子中每点击一次start按钮都会生成一个新球和新线程，而主线程就可以监听到关闭按钮的事件，<br>调用System.exit(0)方法从而实现中断操作。</p><ol start="2"><li>中断线程<br>当线程执行完run()方法并返回或者出现未捕获异常的时候，线程将终止。没有可以主动强制终止一个<br>线程的方法，只有一个interrupt()方法用来请求中断线程，它会设置一个中断标志位，我们可以通过<br>检查这个标志位来决定线程是否需要停止运行。</li></ol><p>在阻塞的线程(调用了wait(), join()或sleep()方法的线程)中调用interrupt()方法会抛出中断异常<br>从而结束阻塞状态，并且它会清空中断状态。从这里可以看出，我们可以使用interrupt()方法提前结束<br>阻塞的线程。线程本身决定如何响应中断请求，我们可以结束该线程，也可以忽略该中断请求<br>(如前面说的不可中断线程)。</p><p>发生上述的interrupted异常时不应当不做任何处理，可以调用Thread.currentThread.interrupt()<br>方法将被清空的中断状态重新定义出来， 或者可以直接将该异常抛给调用者处理。<br>同时，如果线程run()方法处理逻辑中如果使用了sleep()或其他阻塞方法，由于它们在调用时如果被<br>中断会抛出异常，所以此时就不需要再去检查中断标志位了，直接捕捉该异常即可。</p><p>Thread.interrupted()方法将返回线程的中断状态，同时它会清除该中断状态，停止中断！(即中断<br>线程连续2次调用interrupted()方法，第一次返回true,第二次将返回false.)而thread.isInterrupted()<br>是一个实例方法，仅返回中断状态，不会改变中断状态。</p><p>下面是一个简单的通过中断来终止线程的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class InterruptTest &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">          while(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  System.out.println(&quot;sss&quot;);</span><br><span class="line">                  Thread.sleep(10000);</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  // 抛出异常的同时清除了中断状态，所以这里需要手动设置中断状态, </span><br><span class="line">                  // 以退出循环，结束run方法和thread线程</span><br><span class="line">                  Thread.currentThread().interrupt();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread(r);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>线程状态<br>线程有6种状态，可以调用getState()方法确定线程的当前状态。</p><ol><li><p>New 新创建状态<br>使用new操作符新建一个线程时，此时线程还没有开始运行，在做一些线程的基础工作。</p></li><li><p>Runnable 可运行状态<br>一旦调用start方法，线程即处于可运行状态。一个可运行状态的线程可能在运行中，也可能不在运行中，<br>这取决于系统时间分配。即运行中的线程也是可运行状态。</p></li></ol></li></ol><p>桌面和服务器操作系统都使用抢占式调度系统，即系统给每一个可运行线程一个时间片执行任务，时间片<br>用完时系统停止运行该线程，再根据线程优先级确定下一个运行的线程。但在手机等小型设备上是使用<br>协作式调度系统，只有当一个线程调用yield()方法，或者被阻塞，等待时，线程才会停止运行。</p><ol start="3"><li>Blocked，Waiting, Timed waiting 被阻塞和等待, 计时等待状态<br>这三种状态统称为非活动状态。有以下几种情况线程会进入非活动状态:<ol><li>一个线程试图获取一个对象锁(不是Concurrent包中的锁)而该锁被其他线程持有时，该线程<br>进入阻塞状态，直到该锁被释放并且该线程得到该锁时才会变为非阻塞状态。</li><li>当一个线程等待另一个线程通知调度器某个条件时，该线程是等待状态。如Object.wait()，<br>Thread.join()方法，或是等待concurrent包中的Lock或Condition时。阻塞状态与等待状态是不同的。</li><li>某些方法有一个计时参数，如Thread.sleep(),Object.wait(), Thread.join()等方法，此时<br>线程进入计时等待状态。</li></ol></li></ol><p>当一个线程阻塞或等待时，另一个线程被调整为运行状态。而一个线程重新激活时(如获得锁或计时结束),<br>调度器检查线程优先级，如果该线程优先级更高，就将它替换当前运行中的某个线程。</p><ol start="4"><li>Terminated 终止状态<br>前面提到过，一个线程终止有2种情况:<ol><li>run()方法正常结束而终止线程。</li><li>run()方法运行过程中出现了未捕获的异常而终止线程。</li></ol></li></ol><p>注: thread.stop()方法已经过时，不应当使用它终止线程。<br>thread.join()方法注释为<code>wait for this thread to die</code>, 即当前线程进入等待状态，等待join()<br>方法的调用线程终止。以下为join方法测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class JoinTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                System.out.println(&quot;t end&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t = new Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;main end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出为</span><br><span class="line">t end</span><br><span class="line">main end</span><br><span class="line">注释掉join方法时输出为</span><br><span class="line">main end </span><br><span class="line">t end</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>线程属性</p><ol><li>线程优先级<br>一个线程的优先级默认是继承了其父线程的优先级，可以调用setPriority()方法设置，优先级从1到10,<br>最低为1,最高为10，普通优先级为5。</li></ol></li></ol><p>线程的优先级是高度依赖于具体的操作系统的，java的优先级转换到具体的操作系统时该优先级可能<br>会发生变化，所以不应当依赖于优先级来进行编程，它只是提供了参考，但没有确定性。</p><p>Thread.yield()方法指示当前线程愿意让出自己的时间片，调度器可以选择一个优先级相同或更高的<br>线程运行。文档注释说该方法是线程向调度器发起的通知，调度器可以忽略它。yield方法很少有适当<br>的场景需要使用，它可以用于测试bug，或一些并发控制的包(如java.util.concurrent.locks)中。</p><ol start="2"><li><p>守护线程<br>守护线程也叫后台线程，可以通过thread.setDaemon(true)将线程转换为守护线程。它的唯一用途就是<br>为其他线程提供服务，如进行计时操作等。当程序中只剩下守护线程时，程序就会结束。守护线程不<br>应当访问固有资源，如文件、数据库等，因为它们是不稳定的，访问失败时会导致守护线程中断，无法<br>提供应有的服务。</p></li><li><p>未捕获异常处理器<br>thread.run()方法不支持抛出受查异常，它只能因为未捕获异常终止。我们可以调用<br>setUncaughtExceptionHandler(UncaughtExceptionHandler eh)方法自定义一个未捕获异常处理器来<br>处理这个异常(只需要实现Thread.UncaughtExceptionHandler接口即可)，还可以使用<br>setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)来设置该线程的默认处理器。</p></li></ol><p>文档注释中说，一个线程的未捕获异常处理器是先查找用户指定的处理器，如果为空，就寻找线程<br>所属的线程组的处理器，如果线程组(包括更高层级的父类线程组)都没有指定处理器时，最后才会调用<br>线程默认的处理器。所以如果想要自定义处理器，直接使用setUncaughtExceptionHandler(eh)方法即可，<br>如可以在自定义处理器中将异常日志写入到特定的日志文件中。</p><p>当用户没有指定处理器时，默认的处理器就是线程组对象threadGroup, 它实现了UncaughtExceptionHandler<br>接口。我们常见到的程序异常错误信息即为调用了线程组中的uncaughtException(Thread, Throwable)<br>方法打印出来的，其中定义了上面说的处理器寻找顺序。(其中异常如果是一个ThreadDeath对象，栈轨迹<br>是被禁用的，ThreadDeath是由stop方法产生的，而stop方法已经过时)</p><ol start="5"><li>同步<ol><li>竞争条件<br>当多个线程同时对同一数据进行修改时，就会出现竞争条件(race condition).</li></ol></li></ol><p>书中转账的例子里，100个账户建立了100个线程，它们同时进行转账操作，转入对象是随机的，每次<br>转账后打印所有账户的总余额。经测试发现，该金额是在不断变化的，而不是固定不变的，这就是典型<br>的并发问题。</p><ol start="2"><li><p>竞争条件详解<br>出现这个问题的原因在于修改余额语句如<code>accounts[to] += amount;</code>编译后的字节码指令是由多个指令<br>构成的，如装载，计算，存储等。在并发的情况下，执行这一串指令的线程会在任意一个中间节点处<br>被中断，从而导致数据错误。</p></li><li><p>锁对象<br>我们需要保证线程失去控制前完成业务逻辑处理，可以通过加锁来达到这一目的。使用synchronized<br>关键字或者ReentranLock类(Lock接口实现类)来进行加锁操作。</p></li></ol><p>仔细分析上面的转账例子，100个线程并发的调用相同bank对象的transfer方法，同一时间对银行内的<br>账户进行操作导致该bank对象的数据出现了问题。我们给该银行对象加上一把锁ReentranLock,<br>不同线程对同一个bank实例进行操作时，首先进行reenLock.lock()获取锁操作，获取失败时该线程<br>进入阻塞状态，直到获取到锁为止。相当于当前操作线程失去控制时，其他线程无法操作相关数据，<br>这样就保证了同一个bank实例转账操作的线程安全性。</p><p>不同bank实例的锁不会相互影响。</p><p>此外，锁是可重入的，一个线程可以重复获得已经得到的锁，即对一个锁进行重复加锁操作。<br>锁内部会有一个被锁次数的计数值，lock()计数值加1, unlock()计数值减一，当该计数值大于0时，<br>说明该线程仍然持有该锁。对于同一个bank实例，它有自己的一个锁， 同时有多个需要线程安全的<br>操作方法，这时，使用该锁保护的代码可以调用另一个使用相同锁的方法。</p><p>一般是在try{}finally{}的finally语句块中进行释放锁操作，这样可以避免程序抛出异常时未释放锁<br>导致其他线程永远阻塞的情况。但是，如果真的抛出异常，代码中的对象状态是不完整的，实际使用中<br>应当注意这种情况，避免抛出异常。</p><ol start="4"><li>条件对象<br>被锁保护的代码区域称为临界区，即一次只能允许一个线程操作的区域。当线程进入临界区时，有时候<br>会发现不满足执行某些操作的条件，但它又持有了该锁，无法让其他线程进行操作。如银行转账时余额<br>不足的情况。此时就是条件对象(condition variable)发挥作用的时候。</li></ol><p>对于一个锁可以有一个或多个条件对象，Lock接口的newCondition()方法可以生成一个与对应锁关联的<br>条件对象(Condition与Lock一样是一个接口).如出现上述的余额不足情况时，调用condition.await()<br>方法，当前线程进入阻塞状态，并且释放锁，让其他线程对该账户进行转账操作。</p><p>与等待获得锁的线程不同，当调用条件对象await()方法的线程可以获取锁时不会解除阻塞状态，它需要<br>等待另一个线程调用同一个条件对象上的signalAll方法时才能被唤醒。当调用signalAll方法时，所有<br>因这一条件等待的线程将被重新激活，当它们获得锁时将会从被阻塞的地方地方继续执行，此时一般<br>需要再次检测测试条件，因为signalAll方法只是给出可能满足条件的可能性。所以await()方法一般<br>都是写在while循环中，循环进行条件测试。</p><p>如果所有的线程都调用了await()方法，没有线程调用signalAll()方法，那么就进入了死锁状态，程序<br>被挂起无法执行。在上面的转账例子中，应在转账操作完成后调用signalAll()方法，给所有余额不足的<br>线程检查最新余额是否满足条件的机会。</p><p>需要注意的是signalAll()方法并不会立即激活一个等待的线程，它只是解除了线程的阻塞状态，该线程<br>还需要通过竞争获得可运行权限。</p><p>signal()方法是随机解除等待集合中某一个线程的阻塞状态，它效率更高，但存在风险。因为如果<br>那个被唤醒的线程仍然不满足条件而再次阻塞，又没有其他线程调用signal或signalAll方法，程序就<br>进入了死锁状态。</p><p>总之，锁可以管理试图进入临界区的线程，锁的条件对象可以管理已经进入临界区但不满足条件无法<br>运行的线程。</p><ol start="5"><li>synchronized关键字<br>大多数情况下，并不需要某个具体的锁对象控制程序，可以使用synchronized关键字。</li></ol><p>这是因为每一个java对象都默认拥有一个内部锁。当某个对象的方法使用synchronized关键字修饰时，<br>相当于该方法使用了这个内部锁对方法的内容进行了加锁保护，一个线程想要执行该对象方法时，需要<br>首先得到这个对象的内部锁。</p><p>对象内部锁只有一个条件对象，即使用object.wait()方法在不满足条件时阻塞线程，使用notify()或<br>notifyAll()方法唤醒阻塞的线程可继续运行。它们等价于Condition的await(), signal(), signalAll()<br>方法。</p><p>类的静态方法也可以声明为synchronized同步方法, 此时一个线程调用该方法时获取到的是XXX.class<br>类对象的内部锁，这个时候其他线程既不能调用该方法，也不能调用该类其他同步的静态方法，因为整个<br>类对象都被锁住了。</p><p>使用对象内部锁的synchronized同步方法虽然非常简洁方便，但同时它也无法提供一些显式锁提供的功能,<br>如中断一个试图获取锁的线程，定义试图获取锁的超时时间，以及对象内部锁只有一个条件在某些情况<br>下不适用。</p><p>需要并发控制时的最佳实践为:</p><ol><li>首先在java.util.concurrent包中寻找需要的功能，使用已经实现了的类和机制来实现自己的需求。</li><li>其次如果synchronized关键字可以满足需求，优先使用synchronized关键字。</li><li><p>最后，如果需要用到Lock/Condition提供的特有功能时，才使用Lock/Condition.</p><ol start="6"><li>同步阻塞<br>同步阻塞即为synchronized语法块，它是除了同步方法以外线程获得锁的另一种方法。<br>具体语法为<code>synchronized(obj) {...}</code>,其中obj可以是一个普通的Object对象(new Object())，它<br>需要的仅仅是每一个Object对象都有的内部锁而已。</li></ol></li></ol><p>使用一个对象的内部锁封装自己的同步代码的行为称为”客户端锁定”, 但这种方法需要保证被封装的代码<br>中该对象调用的方法都使用内部锁进行同步处理，所以这种加锁操作风险很大，不推荐使用。</p><ol start="7"><li>监视器概念<br>java对象内部锁来源于监视器的概念。监视器要求每个监视器类只能包含私有域，每个监视器类<br>对象有一个锁，使用这个锁对所有方法进行加锁，这个锁可以有任意多个条件。java采用它的概念设计<br>了对象内部锁，但没有完全遵从它的要求。</li></ol><p>注: Object类的wait, notify, notifyAll方法在当前线程未拥有对象内部锁时调用这些方法就会抛出一个<br>名为IllegalMonitorStateException异常，从这里也可以看出这个概念。</p><ol start="8"><li>volatile域</li></ol><p>volatile关键字提供了对于不同线程间通信的机制(java内存模型的happen-before原则也有关于<br>volatile的行为的定义)。一个读取volatile域的线程可以”看”到所有其他线程在写入该域前的内存内容，<br>比如其他域的值等(可见性)。</p><p>volatile单词本意是反复无常的，不稳定的。当一个线程发现操作的变量是volatile变量，知道该变量是<br>“可变”的，操作完后将结果写入内存，其他线程会直接从内存中(而不是缓存)取得最新操作结果(意为<br>该变量会发生变化，无法使用缓存中的值)。相比加锁和同步处理的”重量级”工具，volatile更轻量，<br>适合少数实例域的并发控制。</p><p>java内存模型是jvm对计算机实际物理内存的虚拟化处理，所以需要先了解实际物理内存机制。<br>由于CPU速度太快，读取内存太慢，所以中间使用多级缓存和寄存器进行内容暂存提高速度，其中速度<br>依次为寄存器register, 缓存cash, 内存RAM递减, 容量大小则是递增。(因为CPU在短时间内会再次访问<br>已经访问过的内容，所以使用缓存的机制可以提高存取速度)</p><ol><li><p>操作原子性<br>原子性就是要么不做，要么就全部做完。<br>如计算机执行a = a + 1时它会分成四个原子性操作:</p><ol><li>从内存中读取a的值放入缓存</li><li>CPU从缓存中取出a的值加1</li><li>将计算结果写回到缓存中</li><li>将计算结果写回到内存中</li></ol></li></ol><p>在具体执行这四个操作时，CPU可能会在执行完某一步骤以后被中断去执行别的操作，这就是并发操作<br>原子性问题的根本来源: 计算机内存的缓存机制。</p><ol start="2"><li>操作有序性<br>由于CPU与缓存通信速度快，所以当前后语句不存在依赖关系时，指令重排序不影响程序的语义时，<br>计算机就会进行指令重排序以提高程序运行效率。 </li></ol><p>并发情况下指令重排序可能会造成程序错误，而由于指令重排引发的错误在实际中是很难被发现的。</p><ol start="3"><li>操作可见性<br>如a线程的操作如果是基于另外b线程的操作结果时，a线程不一定能看到b线程的操作结果，这就是操作<br>的可见性问题。归根到底还是线程之间的通信问题，a线程的操作结果需要及时通知到b线程。</li></ol><p>所有并发的问题都是由这三个原因引起的，原子性，有序性，可见性，java并发也不例外。</p><p>volatile关键字保证了线程的可见性和一定的有序性，但并不能保证原子性。如DCL(double check lock)<br>单例模式的双重检查锁就使用了volatile关键字来屏蔽指令重排。</p><p>DCL代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"></span><br><span class="line">  private Singleton()&#123;&#125;  </span><br><span class="line"></span><br><span class="line">  private static Singleton instance;</span><br><span class="line"></span><br><span class="line">  public static Singleton getInstance() &#123;</span><br><span class="line"></span><br><span class="line">     if (instance == null) &#123;</span><br><span class="line">       synchronized(Singleton.class) &#123;</span><br><span class="line">          if(instance == null) &#123;</span><br><span class="line">             instance = new Singleton();  </span><br><span class="line">          &#125; </span><br><span class="line">       &#125; </span><br><span class="line">     &#125;</span><br><span class="line">     return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一个判空条件避免了对象已经初始化后不必要的加锁性能消耗，第2个判空条件保证第一个获取到锁<br>的线程初始化完成对象并释放锁后，那些通过了第一个判空条件被阻塞的线程进入临界区后再次进行<br>判断时会发现instance已经有值了，所以不会再次初始化对象。</p><p>但是由于<code>instance = new Singleton();</code>语句本身并不是原子性操作。它分为3步:</p><ol><li>分配内存区域</li><li>在内存中构造对象</li><li>将对象引用指向该内存区域<br>其中，指令重排会打乱2,3的顺序，即先给引用赋值，再进行对象构造。这样当线程a返回这样一个<br>未构造好的对象时，线程b在判断第一个条件时发现<code>instance != null</code>,从而b线程就拿到这个”半成品”<br>的单例对象，进而在后续使用中报错。</li></ol><p>解决方法:</p><ol><li>禁止指令重排, 即通过使用volatile关键字实现。不过volatile也有性能消耗。</li><li>利用类加载时自带的初始化锁。</li></ol><p>每一个java类或接口都有一个初始化锁与之对应，在初始化类的时候线程会获取到这个初始化锁进行<br>初始化操作，并且其他线程会至少获取一次该锁来确保该类完成了初始化操作。也就是说，类初始化<br>过程只能由一个线程完成，其他线程都被阻塞。将上面的初始化对象过程加入到类初始化的过程中，<br>即使发生指令重排，其他线程也无法拿到该对象(或者说其他线程看不见这个初始化的过程)，<br>从而避免了问题产生。具体代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line"></span><br><span class="line">  private Singleton()&#123;&#125;  </span><br><span class="line"></span><br><span class="line">  public static Singleton getInstance() &#123;</span><br><span class="line">      return SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static class SingletonHolder&#123;</span><br><span class="line">     public static Singleton instance = new Singleton();  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类只有被调用的时候才会初始化，所以这个方案也是懒加载的。<br>注: 枚举本身是线程安全的，所以可以直接使用枚举获得一个单例。</p><p>JMM的happen-before原则提供了程序运行的有序性，它规定了如果2个操作不能从happen-before原则中<br>推导得出运行顺序，那么就无法保证它们的操作顺序，可以被随意指令重排(包括编译器重排和处理器重排)。<br>在JMM中，一个操作的执行结果如果对另一个操作可见，那么它们之间一定存在happen-before关系。</p><ol><li><p>单线程中，前面的操作happen-before后面的操作。<br>这一规则只适用于后面的操作对前面的操作有依赖的情况，如果重排不影响结果，那么就可以指令重排。<br>在多线程中，指令重排会产生错误，所以它无法适用于多线程环境。</p></li><li><p>同一个锁的解锁操作happen-before加锁的操作。<br>这一规则保证了锁可以被正确的释放和获取，保证了锁功能的正常使用。相当于定义了必须先解锁，<br>才能再加锁。</p></li><li><p>对volatile变量的写操作happen-before对该变量的读操作。<br>该规则保证了volatile变量的可见性，通过这样的规定才能取到其他线程的操作结果。</p></li><li><p>传递性：如果a happen-before b, b happen-before c, 则a happen-before c.</p></li><li><p>线程相关的原则: 线程启动先于其他方法，线程interrupt方法调用先于线程收到该中断请求，<br>线程所有操作先于线程的终止检测(如a线程调用b.join(),b线程在join()方法返回前的操作<br>会在线程结束前操作完成，a线程可以观测到相关操作结果)，对象的初始化先于它的finalize()方法。</p></li></ol><p>总之，如果操作a happen-before b, 那么操作a在内存上的操作对b是可见的，或者说a的操作会影响<br>到b操作.</p><ol start="9"><li><p>final变量<br>除了使用锁和volatile关键字，使用final修饰的域也是可以被安全并发访问的。final域的值不可变，<br>所有线程需要等到赋值结束后才能看到它的值。</p></li><li><p>原子性<br>volatile只能保证对实例域的赋值操作的原子性，稍微复杂一点的操作可以使用<br>java.util.concurrent.atomic包中的类，更进一步的原子性只能使用锁或同步来完成。<br>需要注意的是atomic包中的类内部使用了volatile关键字修饰其具体代表的值，可以这些原子类是同时<br>满足了原子性(cas)和可见性的(volatile)的。</p></li></ol><p>atom包中如AtomicInteger类有incrementAndGet方法，它包含的3个操作获取值，增加1,得到结果是一个<br>原子性操作，不会被中断。AtomicInteger还提供了compareAndSet(expectedValue, newValue)方法可以<br>将当前原子类的值与期望值进行比较，相等的时候才会更新为新值。</p><p>如以下代码寻找不同线程观察得到的最大值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">  oldValue = largest.get();  </span><br><span class="line">  newValue = Math.max(oldValue,  observed);</span><br><span class="line">&#125;while(!largest.compareAndSet(oldValue, newValue));</span><br></pre></td></tr></table></figure></p><p>当a线程执行该段代码时，largest值与oldValue相等，compareAndSet方法更新成功，返回true,跳出<br>循环，程序结束。当b线程并发的执行时，由于compareAndSet方法的原子性，等a线程操作结束时，<br>b线程调用compareAndSet方法发现largest最新值(已被a改变)与oldValue值不等，所以largest值不会<br>更新，并且循环条件为true,继续执行循环体，再次进行比较，此时将b线程的观察值与a线程得到的最<br>大值进行比较，从而达到获取多个线程中最大观察值的目的。</p><p>compareAndSet方法提供了比较后赋值操作的原子性，而上面的代码提供了按需更新值操作的原子性，<br>它通过获取原子变量的值实现了线程间的通信。jdk8更进一步，将以上代码封装为一个新的方法<br>updateAndGet(IntUnaryOperator)，只需要传入如何更新值的λ表达式就可以得到这样一个原子性的<br>更新方法。其中IntUnaryOperator只接收一个参数，可以将上面例子使用表达式<br><code>x -&gt; Math.max(x, observed);</code>实现。</p><p>AtomicInteger还提供了一个类似的方法<br>accumulateAndGet(int x, IntBinaryOperator), 其中IntBinaryOperator可以接收2个参数，第一个参数<br>为当前原子整数的值，第二个参数为方法参数x。这时上面的例子可以直接调用方法<br><code>largest.accumulateAndGet(observed, Math::max);</code>。</p><p>此外，getAndUpdate和getAndAccumulate方法可以返回原子类的原值。<br>类似的，其他原子类如AtomicIntegerArray, AtomicLong, AtomicLongArray, AtomicReference,<br>AtomicReferenceArray等也都提供了这些原子性的更新方法。 </p><p>但是如果有大量线程更新同一个原子值，调用以上更新方法时大部分线程需要进行大量的循环，性能<br>非常低。如果我们不需要中间的处理结果，只需要多个线程最后的总结果，可以使用atomic包中的<br>LongAdder或DoubleAdder类，其中add(long)方法对每一个线程会添加一个加数，可以通过sum()方法<br>得到截至到目前的多线程的累加和。increment()方法即为自增1.<br>如果存在大量竞争的情况，就应当考虑使用LongAdder或DoubleAdder, 而不是AtomicLong与AtomicDouble.</p><p>LongAccumulator类可以对任意形式的累加进行操作，初始化该对象时传入具体累加的函数表达式。<br>需要注意的是，该累加操作应当满足交换律和结合律，因为线程被累加的顺序是无法确定的。</p><p>注: 可以发现AtomicInteger.compareAndSet(oldValue, newValue)的实现是调用了一个Unsafe类的<br>本地方法compareAndSwapInt(object, offset, expectedValue, newValue).这样通过本地方法<br>(JNI: java native interface)使用C语言就可以利用操作系统硬件本身支持的并发特性。</p><p>而上面的循环样板代码即为Java中的CAS(compare and swap)原理，使得读取-修改-写入整个操作变为<br>原子操作。而整个JUC(java util concurrent)包都是建立在CAS原理上的。</p><p>synchronized关键字通过阻塞其他线程的方式属于悲观锁，而CAS则属于乐观锁，先执行操作，当发生<br>冲突的时候再终止操作，即非阻塞的方式，这样的方式要比同步锁性能更高。</p><p>单核CPU实现CAS很方便，多核CPU较复杂: 需要使用总线锁或者缓存锁来实现。<br>CAS有3个缺点: </p><ol><li>只能有一个共享变量。<br>这是由其实现方式决定的。可以将多个共享变量整合到一个变量中解决这个问题。</li><li>循环时间长<br>可以通过限制CAS自旋次数解决这个问题。</li><li>ABA问题<br>如果在获取值和进行比较过程中，该值经历了<code>A-&gt;B-&gt;A</code>的变化过程，由于开始和结束值是一样的，<br>所以比较时会认为值没有变化并更新，这样就造成了错误更新。可以通过给对象值打上版本号，记录<br>变化的过程来解决这个问题，AtomicStampedReference类的compareAndSet()方法即是使用这种机制。</li></ol><p>注: </p><ol><li>CAS自旋锁<br>以上线程使用循环来试图获得锁而不是阻塞线程的方式称为乐观锁或自旋锁。又称为CAS自旋锁。在<br>递归调用中如果程序试图获取相同的锁，这时线程会一直在等待自己释放该锁，从而造成死锁的情况。<br>所以递归程序不应当在持有自旋锁时调用自己，也不能在递归调用时试图获取相同的锁。</li></ol><p>可以使用以下代码自定义一个简单的CAS自旋锁:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package cn.taoBlog;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * SpinLock</span><br><span class="line"> *</span><br><span class="line"> * @author wutaotao</span><br><span class="line"> * @version 2019/8/20 14:57</span><br><span class="line"> */</span><br><span class="line">public class SpinLock&#123;</span><br><span class="line">    private AtomicReference&lt;Thread&gt; threadOwner = new AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        while (!threadOwner.compareAndSet(null, current)) &#123;</span><br><span class="line">            System.out.println(current + &quot; is selfSpinning!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + &quot; release lock!&quot;);</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        threadOwner.compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;main thread start&quot;);</span><br><span class="line">        SpinLock casLock = new SpinLock();</span><br><span class="line">        Runnable a = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; start&quot;);</span><br><span class="line">            casLock.lock();</span><br><span class="line">            // got lock and go on</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; got lock!&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                casLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; over&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread aThread = new Thread(a);</span><br><span class="line">        Thread bThread = new Thread(a);</span><br><span class="line">        aThread.start();</span><br><span class="line">        bThread.start();</span><br><span class="line">        aThread.join();</span><br><span class="line">        bThread.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;main thread over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出为:</span><br><span class="line">main thread start</span><br><span class="line">Thread[Thread-0,5,main] start</span><br><span class="line">Thread[Thread-0,5,main] got lock!</span><br><span class="line">Thread[Thread-1,5,main] start</span><br><span class="line">Thread[Thread-1,5,main] is selfSpinning!</span><br><span class="line">...</span><br><span class="line">Thread[Thread-1,5,main] is selfSpinning!</span><br><span class="line">Thread[Thread-0,5,main] release lock!</span><br><span class="line">Thread[Thread-0,5,main] over</span><br><span class="line">Thread[Thread-1,5,main] got lock!</span><br><span class="line">Thread[Thread-1,5,main] release lock!</span><br><span class="line">Thread[Thread-1,5,main] over</span><br><span class="line">main thread over</span><br></pre></td></tr></table></figure></p><p>可以看到Thread-1一直在自旋等待线程Thread-0释放锁。</p><p>但是这个cas自旋锁存在2个问题:</p><ol><li><p>这个是锁是不可重入的，即已经获得锁的线程无法再次获得该锁(重入锁属于锁的应用层面，<br>一个对象实例中不同的方法使用同一个锁进行同步处理时即会面对该问题)。这个问题可以使用前面提到过<br>的计数器实现。加锁时计数值加1, 释放锁时计数值减一，当计数值为0时即真正释放该锁。</p></li><li><p>这个锁是不公平锁，等待时间最长的线程并不能优先获得锁。这个问题类似于cas的ABA问题解决<br>方案一样，给每一个线程一个递增的排队号码，每当一个线程试图获取锁时，就给它一个排队号。锁<br>有一个服务号，每当该锁被释放时，服务号加一。这样，当线程的排队号与服务号相等时，该线程就<br>获得该锁，因为排队号递增，所以保证了公平性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * TicketLock</span><br><span class="line"> *</span><br><span class="line"> * @author wutaotao</span><br><span class="line"> * @version 2019/8/21 22:17</span><br><span class="line"> */</span><br><span class="line">public class TicketLock &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger serviceNum = new AtomicInteger();</span><br><span class="line">    private AtomicInteger ticketNum = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public int lock() &#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        int currentTicketNum = ticketNum.getAndIncrement();</span><br><span class="line">        while (!(currentTicketNum == serviceNum.get())) &#123;</span><br><span class="line">            System.out.println(current + &quot; is selfSpinning!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return currentTicketNum;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock(int ticketnum) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + &quot; release lock!&quot;);</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        serviceNum.compareAndSet(ticketnum, ticketnum + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;main thread start&quot;);</span><br><span class="line">        TicketLock ticketLock = new TicketLock();</span><br><span class="line">        Runnable a = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; start&quot;);</span><br><span class="line">            int tickNum = ticketLock.lock();</span><br><span class="line">            // got lock and go on</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; got lock!&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                ticketLock.unlock(tickNum);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; over&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread aThread = new Thread(a);</span><br><span class="line">        Thread bThread = new Thread(a);</span><br><span class="line">        aThread.start();</span><br><span class="line">        bThread.start();</span><br><span class="line">        aThread.join();</span><br><span class="line">        bThread.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;main thread over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>以上代码中lock()方法返回获得锁的线程分配到的排队号，而解锁时需要校验服务号与排队号是否相等，<br>所以解锁就需要前面获得锁的线程的排队号进行解锁——正如main方法中所作的一样。但是这样明显<br>将锁的一部分”职责”内容交由应用处理，而且该排队号如果在中间发生变化，就无法正确解锁，造成<br>其他线程永远阻塞的状态。(tickNum变量在其他线程调用lock()方法时是不断累加的，无法解锁用)</p><p>所以我们需要一个变量来保存每个线程获得的排队号，解锁时直接取该变量即可，这就是ThreadLocal<br>类的用途！它内部使用一个内部类ThreadLocalMap集合来保存每个线程保存的变量值，键是弱引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package cn.taoBlog;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * TicketLock</span><br><span class="line"> *</span><br><span class="line"> * @author wutaotao</span><br><span class="line"> * @version 2019/8/22 14:27</span><br><span class="line"> */</span><br><span class="line">public class TicketLock &#123;</span><br><span class="line"></span><br><span class="line">    private AtomicInteger serviceNum = new AtomicInteger();</span><br><span class="line">    private AtomicInteger ticketNum = new AtomicInteger();</span><br><span class="line">    private ThreadLocal&lt;Integer&gt; ticketHolder = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        int ticknum = ticketNum.getAndIncrement();</span><br><span class="line">        ticketHolder.set(ticknum);</span><br><span class="line">        while(ticknum != serviceNum.get()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; is spining&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + &quot;release lock&quot;);</span><br><span class="line">        Integer ticket = ticketHolder.get();</span><br><span class="line">        serviceNum.compareAndSet(ticket, ticket + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;main thread start&quot;);</span><br><span class="line">        TicketLock lock = new TicketLock();</span><br><span class="line">        Runnable a = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; start&quot;);</span><br><span class="line">            lock.lock();</span><br><span class="line">            // got lock and go on</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; got lock!&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot; over&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread aThread = new Thread(a);</span><br><span class="line">        Thread bThread = new Thread(a);</span><br><span class="line">        aThread.start();</span><br><span class="line">        bThread.start();</span><br><span class="line">        aThread.join();</span><br><span class="line">        bThread.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;main thread over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注: Atom包中的FieldUpdater类:<br>针对某个类中的字段，如它是int, long或普通的引用类型，如果也想对它实现类似于AtomicInteger,<br>AtomicLong, AtomicReference一样的原子性操作，就可以使用AtomicIntegerFieldUpdater,<br>AtomicLongFieldUpdater, AtomicReferenceFieldUpdater类来实现相同的功能。它的原理是利用<br>反射得到指定字段的内存地址，即offset值，再调用Unsafe包中的相应方法(如compareAndSet)直接对<br>相应的内存操作来达到原子性操作的目的，从这几个类的实现也可以看出Unsafe包的强大之处。<br>实际使用:</p><ol><li>初始化得到更新器，如<br><code>AtomicReferenceFieldUpdater&lt;ClassType&gt; updater = AtomicReferenceFieldUpdater.newUpdater(ClassType.class, FieldType.class, String fieldName);</code></li><li>使用更新器调用相应的原子性方法，如<br><code>updater.compareAndSet(obj, expectedValue, newValue);</code></li></ol><p>实际使用中，比如有一个大的链表，其中的节点需要原子性的get-set, 如果节点类型都定义为<br>原子类型，会消耗很多内存，这时候可以定义一个静态更新器来实现原子操作，而节点仍未普通类型。</p><p>不同层次的自旋锁代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">package cn.taoBlog;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * TAS</span><br><span class="line"> *</span><br><span class="line"> * @author wutaotao</span><br><span class="line"> * @version 2019/8/26 10:05</span><br><span class="line"> */</span><br><span class="line">public class TAS &#123;</span><br><span class="line">    AtomicBoolean state = new AtomicBoolean(false);</span><br><span class="line">    void lock() &#123;</span><br><span class="line">        while(state.getAndSet(true)) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void unlock() &#123;</span><br><span class="line">        // this step invalidate other memories&apos; cache</span><br><span class="line">        state.set(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TTAS &#123;</span><br><span class="line">    AtomicBoolean state = new AtomicBoolean(false);</span><br><span class="line">    void lock() &#123;</span><br><span class="line">        long delay = 1000;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">           while (state.get()) &#123;&#125;</span><br><span class="line">           // lock is free now, many threads contend to get it</span><br><span class="line">           if (!state.getAndSet(true)) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           // if get lock failed, delayed to try getting it again, reduce contention</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep( (long)(Math.random() * 10 + 1) * delay);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if (delay &lt; 10000) &#123;</span><br><span class="line">                delay = delay * 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// similar to ticket lock, but it use array instead of lock&apos;s serviceNum</span><br><span class="line">class AndersonQueueLock&#123;</span><br><span class="line">   // one thread one bit cause cache invalidation unnecessary, we can use [false, null, null, false...]</span><br><span class="line">    // to make each thread use only one cache line.</span><br><span class="line">   private volatile  boolean[] flags = &#123;false, false, false, false&#125;;</span><br><span class="line">   AtomicInteger next = new AtomicInteger(0);</span><br><span class="line">   ThreadLocal&lt;Integer&gt; threadTicket;</span><br><span class="line"></span><br><span class="line">   public void lock() &#123;</span><br><span class="line">       int curTicket = next.getAndIncrement();</span><br><span class="line">       threadTicket.set(curTicket);</span><br><span class="line">       while(!flags[curTicket % flags.length]) &#123;&#125;</span><br><span class="line">       // after got lock, make current slot false to reuse it, because of the % upward,</span><br><span class="line">       flags[curTicket % flags.length] = false;</span><br><span class="line">   &#125;</span><br><span class="line">   public void unlock() &#123;</span><br><span class="line">       // next thread free to go</span><br><span class="line">       flags[threadTicket.get() + 1 % flags.length] = true;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// CLH Queue Lock</span><br><span class="line">class ClHLock &#123;</span><br><span class="line"></span><br><span class="line">    private static class QNode&#123;</span><br><span class="line">        // 默认是未获得锁状态</span><br><span class="line">        private volatile boolean locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 节点链表中的尾节点始终指向最后一个试图获得锁的节点</span><br><span class="line">    AtomicReference&lt;QNode&gt; tail = new AtomicReference&lt;&gt;(new QNode());</span><br><span class="line">    // 每个线程生成自己的节点，作为获得锁的标志</span><br><span class="line">    ThreadLocal&lt;QNode&gt; myNode = ThreadLocal.withInitial(() -&gt; new QNode());</span><br><span class="line">    // 每个线程保存自己的前序节点，在线程本地变量上自旋</span><br><span class="line">    ThreadLocal&lt;QNode&gt; myPred = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        QNode qNode = myNode.get();</span><br><span class="line">        // 试图获得锁时即设置为加锁状态</span><br><span class="line">        qNode.locked = true;</span><br><span class="line">        // 获取tail的前序节点(旧值)</span><br><span class="line">        QNode pre = tail.getAndSet(qNode);</span><br><span class="line">        // 拷贝前序节点到本地</span><br><span class="line">        myPred.set(pre);</span><br><span class="line">        // 前一个线程未释放锁时，本线程自旋</span><br><span class="line">        while (pre.locked)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">       QNode qNode = myNode.get();</span><br><span class="line">       // 释放锁</span><br><span class="line">       qNode.locked = false;</span><br><span class="line">       // recycle predecessor&apos;s node</span><br><span class="line">       // 得到锁的前序节点实际上是整个链表的头节点(first node) </span><br><span class="line">       // 通过将当前节点设置为前序节点，相当于删除了旧的前序节点</span><br><span class="line">       myNode.set(myPred.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CLH在常用的SMP(symmetric multi-processor)处理器架构上运行良好，多个处理器共享一个内存, 每个<br>CPU访问的内存是相同的的(但访问相同的内存地址会造成CPU资源的浪费)。而NUMA<br>(non-uniform memory architecture)处理器架构则是每个CPU都有自己的内存，对自己的内存访问速度远高于<br>其他CPU的内存，所以对不同内存地址的访问速度是不一致的。</p><p>CLH在本地内存上自旋非常快，在远程内存上自旋就很慢。所以CLH锁不适用于NUMA系统架构。<br>这时可以使用MCSLock.</p><ol start="2"><li>缓存一致性</li></ol><p>缓存本身的一致性指的是其基本定律(任意时刻，任意级别缓存中的缓存段的内容，等同于它对应<br>内存中的内容)和回写定律(当所有的脏段被回写后，任意级别缓存中的缓存段的内容，等同于它对应<br>内存中的内容)。但是在多核处理器计算机中，每个处理器都有自己的缓存组，不同处理器对相同内存<br>的操作就需要通知到其他处理器的缓存组，实现不同缓存组之间的一致性。</p><p>一般是通过”窥探”(snooping)协议定义缓存组之间通信, 即所有内存传输都发生在一条共享的总线上。<br>具体一般使用MESI(Modified, Exclusive, Shared, Invalid)协议来保证不同缓存组之间的一致性，遵守<br>该协议的处理器系统可以说是完全一致的。上面四个单词代表缓存段的不同状态:</p><ol><li>Modified代表已修改，属于脏段。</li><li>Exclusive代表独占状态。</li><li>Shared代表内存的拷贝，只读不可写的状态。</li><li>Invalid代表缓存段失效状态，</li></ol><p>当缓存需要写入内存时，需要发送获得独占权的请求到总线上，通知其他缓存，让它们对应的缓存变为<br>失效状态。当有其他处理器需要写入该内存时，当前处理器需要从已修改或独占状态变为共享状态，<br>同时将修改内容写入到内存中。</p><p>多核处理器实现写入数据操作的原子性时，可以使用总线加锁或缓存加锁两种方法，总线加锁使得其他<br>处理器无法访问内存，开销较大所以不推荐。缓存加锁就是利用了缓存的一致性原理，处理器修改自己<br>对应于该内存地址的缓存组内容，其他处理器无法同时修改来达到原子性操作的目的。</p><ol start="3"><li>“What every programmer should know about memory” note</li></ol><p>注: ROM(read-only memory)是只读内存，只能读取，不能修改或删除储存的资料，资料不会因电源<br>关闭而消失。而RAM(random-access memory)可以用任何顺序访问资料，停电后资料即消失，如内存就是<br>RAM.</p><ol><li>略</li><li>Commodity Hardware Today<br>一般商用计算机的主板上分2部分，北桥和南桥。CPU通过FSB(front side bus)总线进行相互通信。<br>北桥中包含着内存控制器，而控制器类型决定了RAM的类型。而南桥管理着如网卡，USB等外围设备的<br>接口，所以北桥需要访问南桥以访问这些设备。</li></ol><p>这个架构中，CPU之间的通信请求，所有访问RAM的请求，CPU访问外围设备的请求都需要经过北桥的处理。<br>该架构设计的性能瓶颈:</p><p>访问RAM: 早期的时候，南北桥上所有的通信都需要经过CPU,这降低了系统性能，所以出现了<br>DMA(direct memory access)设备来解决它，它们可以在北桥上直接访问RAM, 不过这样也与<br>CPU的处理信号形成了竞争关系。<br>北桥到RAM的总线: 早期的系统北桥只有一条总线链接到所有的RAM芯片上，现在则扩展了更多的总线<br>(或称为channel)提高带宽来解决它。在有限的带宽下，合理分配内存的访问权限对于性能的提高非常<br>重要。除了并发访问内存会影响性能外，访问内存的模式本身对于性能影响也很大。</p><p>还可以让北桥部分自己不包含内存控制器，北桥链接多个外部的内存控制器，每个控制器有自己的RAM,<br>这样内存总线就有多条，而不是只有一条，从而也提高了总带宽。通过访问不同的内存库减少了并发<br>访问的耗时。</p><p>还可以将内存控制器整合进CPU当中，将每个内存RAM直接与各个CPU相连，这就是NUMA系统架构， 每个<br>处理器通过整合内存控制器都有本地内存可以使用。NUMA系统架构中所有的处理器除了本地内存外<br>仍然需要访问其他的内存，所以有了访问速度不一致的问题，即NUMA的non-uniform。处理器访问远程内存<br>的时间消耗称为NUMA因子。有的机器将CPU分成多个节点，节点内部的NUMA因子很小，节点间因子值很大。</p><p>2.1 RAM类型<br>静态RAM速度块，但价格高，动态RAM速度慢，但是便宜。DRAM只由一个晶体管和电容组成，结构简单，<br>但存在很多问题，如每次读取数据后需要时间充电(这也称为刷新，因为读操作会导致电容器”漏电”)，需要放大器<br>放大信号并判断状态(0或1)等。</p><p>2.2 DRAM的访问<br>地址线的数量对DRAM的处理性能影响很大，一般是复用地址来提高性能。<br>一般主要的DRAM是SDRAM(synchronous DRAM)，它的后代是DDR(Double Data Rate SDRAM).<br>DDR模块的时间耗时主要由以下几部分组成: CL(CAS latency), <code>t_RCD</code>(RAS TO CAS Latency),<br><code>t_RP</code>(RAS precharge), <code>t_RAS</code>(active to precharge delay), command rate.<br>刷新的时间间隔是由内存控制器控制，DRAM模块用队列存储每个请求的计数值以延迟执行。</p><p>SDR(Single Data Rate SDRAM)能以内存总线的传输速度相同的速度输出内存中的内容。<br>DDR1相比SDR而言,DDR1可以在同一个周期内传输双倍的数据，它并没有改变时钟频率, 在信号的上升和<br>下降沿都可以传输数据。DDR1让2个DRAM cell取相同的列值，读取时并发的访问它们。</p><p>DDR2则在DDR1的基础上将频率翻了一倍。它是通过让IO buffer以更快的速度运行，可以在每个时钟周期<br>中传输4位而不是DDR1的2位(SDR是1位)。DDR3中外部总线运行的更快，它传输的是8位的I/O buffer。</p><p>DDR模块越来越高的总线频率导致创建并发的数据总线越来越难以实现(前面通过并发访问实现了传输<br>加倍的数据)，而且菊花链式链接的DDR模块之间传递信号会发生扭曲，所以DDR2规定每个总线只能有<br>2个DDR模块，DDR3则规定每个总线只能有一个模块。这样一条总线(一个DDR模块)有240个针脚，一个<br>北桥最多容纳2条总线(针脚限制)。这也意味着一个主板只能容纳4个DDR2或DDR3模块。</p><p>FB-DRAM(Fully Buffered)采用串行buffer总线来解决这个问题，FB-DRAM只有69个针脚。一条总线可以<br>容纳8个FB-DRAM模块，北桥可以容纳6条总线。</p><p>总之，CPU速度比RAM快很多，DRAM模块支持很高的数据传输速度。访问不连续的内存区域需要重新充电<br>和新的RAS信号，硬件和软件可以通过提前读取数据来利用这段延迟时间，这样也减少了后面的读写操作<br>竞争。</p><p>2.3 其他主内存使用者<br>除了CPU，还有其他如网卡，或大容量存储控制器也需要访问主内存(即DMA).这样它们与CPU在总线上<br>产生了竞争。可以通过技术手段和程序接口减少竞争，提高性能。</p><ol start="3"><li>CPU caches<br>由于程序代码的空间和时间的局部性，所以使得CPU使用SRAM作为高速缓存的设计是具有实际意义的。<br>空间的局部性体现为代码中出现循环时相同的代码被不断的重复执行，时间的局部性体现为循环中<br>内存位置很远的方法调用在时间上被快速多次调用。</li></ol><p>3.1 CPU caches in the big picture<br>经验证明将数据缓存和指令缓存分开存储具有很多好处。<br>内核和多线程的区别:<br>内核是独立的，每个内核都拥有几乎相同的单独的硬件资源, 它们在没有竞争时是完全独立工作的；<br>而多线程是共享资源进行操作。</p><p>距离CPU的远近关系分为1级缓存，2级缓存，3级缓存等。在多处理器，多核，多线程的计算机中，<br>每个处理器之间不共享任何缓存，单个处理器内部的多核之间共享高级别缓存，每个内核都有自己<br>单独的1级缓存。</p><p>3.2 cache operation at high level<br>缓存不可能存储主内存中的所有内容，所以它存储的内容有一个标签tag来标记内容在内存中的位置，<br>由于缓存基于空间局部性原理，并且标签本身也占有一定空间，所以逐个存储单个单词是没有效率<br>(需要新的CAS或RAS信号)并且违背原理的，所以缓存内容是按行读写的，即缓存段(cash line)。<br>根据访问缓存的级别不同，读写数据的性能也有非常大的差距(只用到L1,L2级别缓存和需要访问主内存的<br>程序差别)，所以提高程序对于缓存的利用率对于性能的提升有时是非常巨大的。</p><p>3.3 CPU cache implementation details<br>  3.3.1 Associativity<br>如果每个缓存行可以存储任意内存地址的内容，这样设计的缓存称为fully associative cache, 但是<br>寻址时CPU要搜索的条目(entry)就太多了，每个缓存行都需要一个比较器比较请求地址和每个缓存段的<br>地址，无论是提高比较器的速度或者复用比较器都无法有效提高性能。所以我们可以设计减少比较器，<br>即让一个缓存段只能存储一个对应的内存地址中的值，但由于空间和时间的局部性，某些缓存会被经常<br>用到，而某些缓存则一直是空置状态。这样即浪费了资源，也使得热点资源造成竞争。</p><p>所以合理的方案是使用Set-associative cache.将需要请求的内存地址分散到每一个tag和data中，每次<br>请求读写时地址经过转换后，每个tag或data都有机会作为存储目标内容的小单元。这种设计使得缓存<br>总容量增加时，只需要增加tag和data的列数，而不需要增加行数(对应着缓存本身的associativity,<br>同时每一行对应一个比较器), 从而使得缓存的增加不再受限于比较器的数量。</p><p>在缓存行大小，缓存总容量固定的情况下，缓存associativity值越高，缓存未命中(cash miss)的次数<br>就越少。从数据图标中可以看出，从直连(no associativity)到associativity=2的性能提升是最大的，<br>有时甚至和缓存总容量翻倍的效果是一样的！不过当associativity再增加时，性能提升效果就一般了。<br>  3.3.2 Measurements of cache effects<br>略<br>  3.3.3 write behavior<br>如前面说过的直写和回写模式。<br>  3.3.4 multi-processor support<br>MESI协议，保证多核处理器间的缓存一致性。<br>多线程访问<br>  3.3.5 other details<br>virtual memory address and physical memory address</p><p>3.4 Instruction Cache<br>不只是执行指令时用到的数据被缓存，指令本身也会被缓存(这里指的是编译器编译后生成的代码指令)。<br>  3.4.1 self modifying code<br>should avoid this.</p><p>3.5 Cache Miss Factors<br>  3.5.1 Cache and memory bandwidth<br>  3.5.2 Critical Word Load<br>缓存行一般有64或128字节，从主内存传输到缓存的效率是一次传输64位，这意味着加载一行缓存段需要<br>8或16次传输，为了程序继续执行，内存控制器可以将”关键字”优先上传，这样程序可以在缓存还未处于<br>连续状态前就开始执行, i.e., Critical word first &amp; early restart.<br>  3.5.3 Cache Placement<br>  3.5.4 FSB Influence</p><ol start="4"><li>Virtual Memory<br>4.1 Simplest Address Translation </li></ol><h2 id="springboot-scheduled-cron-expression"><a href="#springboot-scheduled-cron-expression" class="headerlink" title="springboot scheduled cron expression"></a>springboot scheduled cron expression</h2><p>秒 分 时 日 月 周 (年)<br>0-59 0-59 0-23 1-31 1-12 1-7 1970-2099<br>每天凌晨执行一次:<br><code>0 0 0 */1 * ?</code><br>或<br><code>0 0 0 * * ?</code></p><p>每周日凌晨执行一次:<br><code>0 0 0 ? * SUN</code></p><p>每月1号凌晨执行一次:<br><code>0 0 0 1 */1 ?</code><br>或<br><code>0 0 0 1 * ?</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;0 0 12 * * ?&quot; 每天中午12点触发 </span><br><span class="line">&quot;0 15 10 ? * *&quot; 每天上午10:15触发 </span><br><span class="line">&quot;0 15 10 * * ?&quot; 每天上午10:15触发 </span><br><span class="line">&quot;0 15 10 * * ? *&quot; 每天上午10:15触发 </span><br><span class="line">&quot;0 15 10 * * ? 2005&quot; 2005年的每天上午10:15触发 </span><br><span class="line">&quot;0 * 14 * * ?&quot; 在每天下午2点到下午2:59期间的每1分钟触发 </span><br><span class="line">&quot;0 0/5 14 * * ?&quot; 在每天下午2点到下午2:55期间的每5分钟触发 </span><br><span class="line">&quot;0 0/5 14,18 * * ?&quot; 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </span><br><span class="line">&quot;0 0-5 14 * * ?&quot; 在每天下午2点到下午2:05期间的每1分钟触发 </span><br><span class="line">&quot;0 10,44 14 ? 3 WED&quot; 每年三月的星期三的下午2:10和2:44触发 </span><br><span class="line">&quot;0 15 10 ? * MON-FRI&quot; 周一至周五的上午10:15触发 </span><br><span class="line">&quot;0 15 10 15 * ?&quot; 每月15日上午10:15触发 </span><br><span class="line">&quot;0 15 10 L * ?&quot; 每月最后一日的上午10:15触发 </span><br><span class="line">&quot;0 15 10 ? * 6L&quot; 每月的最后一个星期五上午10:15触发 </span><br><span class="line">&quot;0 15 10 ? * 6L 2002-2005&quot; 2002年至2005年的每月的最后一个星期五上午10:15触发</span><br><span class="line">&quot;0 15 10 ? * 6#3&quot; 每月的第三个星期五上午10:15触发 </span><br><span class="line">每隔5秒执行一次：*/5 * * * * ?</span><br><span class="line">每隔1分钟执行一次：0 */1 * * * ?</span><br><span class="line">每天23点执行一次：0 0 23 * * ?</span><br><span class="line">每天凌晨1点执行一次：0 0 1 * * ?</span><br><span class="line">每月1号凌晨1点执行一次：0 0 1 1 * ?</span><br><span class="line">每月最后一天23点执行一次：0 0 23 L * ?</span><br><span class="line">每周星期天凌晨1点实行一次：0 0 1 ? * L</span><br></pre></td></tr></table></figure><p>注: application.yml文件中可以使用${propertyName}相互引用,如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: http://xxx.xx.xx.xx:8000</span><br><span class="line">jsp: $&#123;url&#125;/test/index.html</span><br></pre></td></tr></table></figure></p><h2 id="move-forward-to-jdk-11"><a href="#move-forward-to-jdk-11" class="headerlink" title="move forward to jdk 11"></a>move forward to jdk 11</h2><p>jdk9  modules    minimize runtime size<br> var<br>jdk 10<br>   List,Set,Map.copyOf<br>   Collectors.toUnmodifiableList/Map/Set  for stream<br>jdk 11<br>   Http Client   同步异步都有<br>      HttpClient<br>      HttpRequest<br>      HttpResponse<br>      WebSocket</p><p>lambda expression support var   used for adding annotation in lambda expression</p><p>launch single java source code file<br>  no need to compile to class file first, it will execute the main function</p><p>using code above the class Name with Shebang  #!</p><p>   #!$JAVA_HOME/bin/java –source 11<br>make the source file executable and ./Factorial 4 will get the result! just like python and js…<br>   to be tested with importing other classes.</p><p>nullInputStream<br>nullOutputStream<br>nullReader()<br>nullWriter()<br>  equals to linux /dev/null  throw away the output of a stream</p><p>Optional isEmpty()</p><p>String methods:<br>isBlank()<br>Stream lines()    return the lines of multi-line streams<br>String repeat(int)<br>String strip()<br>String stripLeading()<br>String stripTrailing()<br>    similar function with trim(), strip difines whitespaces differently with trim() methods</p><p>Predicate not(Predicate)<br>    lines.stream().filter(s -&gt; !s.isBlank())<br>       change to<br>    lines.stream().filter(Predicate.not(String::isBlank))</p><p>lambda leftovers   _ for unused parameters</p><p>raw string literals   jdk12<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`` i a /sd/sd`isdfds`df ``</span><br></pre></td></tr></table></figure></p><p>switch support type test<br>    String s;<br>    switch(obj) {<br>       case Integer i: s = String.format(“%d”, i); break;<br>       case Double d: s = String.format(“%f”, d); break;<br>       case String s: s = String.format(“%s”, i); break;<br>       default:  d = obj.toString();<br>    }<br>switch expression   switch语句有返回值<br>   int num = switch(day) {<br>      case mon, fri,sun -&gt; 6;<br>      case tue -&gt; 7;<br>      case thu, sat -&gt; 8;<br>      case wed -&gt; 9;<br>      default -&gt; throw new IllegalStateException(“wrong date value with “ + day);<br>   }</p><p>@Deprecated<br>  since: the beginning time of deprecating,<br>  forRemoval=true:  the next version it will probably gone</p><p>java9<br> fast initializtion:   unmodifiable<br>   Map&lt;String, String&gt; map = Map.of(“key”, “value”);<br> modifiable  in constructor<br>   Map&lt;String, String&gt; map = new HashMap&lt;&gt;();<br>   {<br>     map.put(“key”, “value”);<br>   }</p><p>jdk 5<br>  type witness<br>  EasyMock class<br>    T anyObj();<br>  Test class<br>   void foo(List<string> list)<br>   void foo(Set<string> set)<br>foo(EasyMock.anyObj()) compilation error</string></string></p><p>foo((List<string>)EasyMock.anyObj())     gets compilation warning about unsafe cast<br>type witness<br>foo(EasyMock.&lt;List<string>&gt;anyObj())   tell the compiler the T type</string></string></p><p>jdk 6  faster<br>jdk 7<br> syntax suger<br> invokeDynamic,  forkJoin,<br>   switch on string    suger, using hash to compare, low level implementation is complicated<br>  diamond operator<br>    List<string> list = new Arraylist&lt;&gt;();<br>  number underscores<br>     int i = 1_000_000</string></p><p>  multiple catches<br>     try{…}catch(IOException | SQLException e) {<br>       log.error(“my error”, e)<br>     }</p><p>  auto closeable   try with resource<br>    try(InputStream in = new FileInputStream(“aa.txt”)) {…}<br>    autoClose will execute the close method in the right places and suppress the<br>      close method function, output the business exception</p><p>   java.nio.file<br>       List<string> lines = Files.readAllLines(Paths.get(“path”, “to”, “a.txt”));<br>      file watcher, symbolic links, file locks, copy…</string></p><p>jdk 8  2014</p><pre><code>lambda....java.util.Base64  String text = &quot;Base64 in java8&quot;;  Strng encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));  String decoded = Base64.getDecoder().decode(encoded, StandardCharsets.UTF_8);time api          immutable   A time is time , date is date, not mixed like java.util.Date  LocalDate, LocalTime, LocalDateTime   -&gt; local, no time zone OffsetDateTime, OffsetTime   -&gt; Time with an offset from greenwich  ZonedDateTime  -&gt;  LocalDateTime with a time zone  Duration, Period  -&gt; Time span  Instant  -&gt; Timestamp  Formatting -&gt; Easy and thread-safe formatting  example:    LocalDateTime now = LocalDateTime.now();    String otherDay = now.withDayOfMonth(1).atZone(ZoneId.of(&quot;Europe/Paris&quot;)).plus(Duration.ofDays(5))    .format(DateTimeFormatter.ISO_ZONEID_DATE_TIME);</code></pre><p>   lambda<br>      function with no name<br>      classic:     list.forEach(e -&gt; System.out.println(e));<br>      typed:     list.forEach((String e) -&gt; System.out.println(e));   // specify the parameter type<br>      closure:<br>         String greeting = “hello”;  // no need to write final, implicitly referred<br>         list.forEach(e -&gt; System.out.println(greeting + e));   // greeting is final in lambda</p><p>   interface default methods<br>       default implementation for most implementors<br>   interface static methods<br>       replace the need for factory helper</p><p>   // the magic here is new Object(){…} anonymous class create a new type(not Object)<br>   // for the next stream forEach tuple.<br>    Map&lt;Long, Person&gt; map = Map.of(<br>       1L, new Person(12, “wtt”),<br>       2L, new Person(13, “cll”)<br>    );<br>    map.entrySet().stream().map(entry -&gt; new Object() {<br>         long id = entry.getKey();<br>         String name= entry.getValue().getName();<br>      }).forEach(tuple -&gt; {<br>          System.out.println(tuple.id + “:” + tuple.name);<br>        });<br>    // here we get the long type indexId and  String type name</p><pre><code>var list = map.entrySet().stream().map(entry -&gt; new Object() {     long id = entry.getKey();     String name= entry.getValue().getName();  }).collect(Collectors.toList());  System.out.println(list.get(0).name)  // we can use var type to write the unknown type of new Object </code></pre><p>   method reference<br>     it is the simplification of lambda expression,<br>    my own example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface OI&lt;T&gt;&#123;        // 使用泛型处理不同类型参数</span><br><span class="line">  T oper(T x, T y);</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   printInteger(Math::max, 3, 5);     // 5</span><br><span class="line">   printDouble(Math::max, 33.2l, 5.3);  // 33.21</span><br><span class="line">   printInteger(Test::ss, 3, 10);      // 19</span><br><span class="line"> &#125;  </span><br><span class="line"> // 这里函数式接口需要指明泛型类型，否则默认Object,编译报错找不到Math.max(Object,Object)</span><br><span class="line"> private static void printInteger(OI&lt;Integer&gt; oi, int x, int y) &#123;   // 操作逻辑，操作数</span><br><span class="line">   System.out.println(oi.oper(x,y));  </span><br><span class="line"> &#125;</span><br><span class="line"> private static void printDouble(OI&lt;Double&gt; oi, double x, double y) &#123;   // 操作逻辑，操作数</span><br><span class="line">   System.out.println(oi.oper(x,y));  </span><br><span class="line"> &#125;</span><br><span class="line"> private static int ss(int x, int y) &#123;</span><br><span class="line">   return (x * x) + y;   //这是一个简单的运算，只有复杂的操作提取才有意义  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   difference between lambda and method reference<br>String s = null;<br>IntSupplier r = () -&gt; s.length();   // run good,  lambda will not execute when created<br>IntSupplier r = s::length;   // error! method reference need the instance existed and not null</p><p>jdk 9<br> httpClient<br> immutable collections<br>  xml and nio debugging  with unified JVM logging</p><p>   try with resource no need to put the declaration in try block any more, like<br>      ByteArrayOutputStream in = new ByteArrayOutputStream();<br>      try(in) {…}</p><pre><code>jdk7   old reflection need to check and set the accessible, very slow   MethodHandle class, powerful tool for reflection   Field field = Test.class.getDeclaredField(&quot;title&quot;);   MethodHandle setter = MethodHandles.lookup().unreflectSetter(field);   setter.invokeExact(this, &quot;Sir&quot;);</code></pre><p>  jdk9  add findVarHanle()<br>     MethodHandles.lookup().findVarHandle()</p><p>  modules<br>        module path can be directories and main function can be class name not main function name<br>    java  –module-path  app/target/classes:lib/target/classes -m pros.app/pro.App<br>     maven-jar-plugin   auto module name change module name<br>     module-info.java    exports  and requires, opens for reflection</p><p>  java 10  2018.3<br>     var<br>      var var = 1;<br>      var var = foo();  // this is bad, because it’s ambiguous<br>      ConcurrentHashMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();<br>       simplifies to<br>      var map = new ConcurrentHashMap&lt;String, String&gt;();<br>      // map now is a ConcurrentHashMap type, not a Map type-interface<br>     //  using  var with lambda parameters can make it be able to be annotated</p><p>  java 11 2018.9<br>     a single file program<br>     java.sh  #!$Java_home/bin/java –source 11</p><pre><code>http://www.lamgdafaq.orghttp://files.zeroturnaround.com/pdf/RebelLabs-Java-9-modules-cheat-sheet.pdfhttp://openjdk.java.net/projects/amber/LVTIstyle.htmlhttps://javaspecialists.teachable.com/coursesModern Java in Action</code></pre><p>   Mastering Lambdas/Generics<br>   Java 9 Modularity</p><p>   <a href="http://blog.tremblay.pro" target="_blank" rel="noopener">http://blog.tremblay.pro</a></p><p>EasyMock for Java<br>  write junit tests easily </p><p>good luck2</p><h2 id="hibernate4-Could-not-obtain-transaction-synchronized-Session-for-current-thread"><a href="#hibernate4-Could-not-obtain-transaction-synchronized-Session-for-current-thread" class="headerlink" title="hibernate4 Could not obtain transaction-synchronized Session for current thread"></a>hibernate4 Could not obtain transaction-synchronized Session for current thread</h2><p>this bug appears when I try to config dual datasource to spring+hibernate project,<br>now is 21:36, all the web page search result said I need to add @transactional<br>annotation, but there is another project which I did not add it but it also works good, too.<br>After all, I add spring @Transactional annotation to commonDaoImpl, and add<br><code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManagerComm&quot; /&gt;</code> to make the<br>transactional annotation work, so it works ok now. The error is clear, but the spring<br>and hibernate config terrifies me, after all these years, it almost becomes a ghost,<br>that means, all the technical debt will remain to be paid back if you are still using it,<br>hahahaha.</p><p> 2021-03-25 15:13:44 added:<br> today I found the above error’s real problem, and it shows the cause why the same<br> configuration works in one project and not working in another one, as I found out later,<br> I copy the aop pointCut execution expression is wrong, and add transactional annotation<br> bypass the wrongness, so finally just use default transaction is fine, no need to use<br> transactional in purpose.</p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190917_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java, Char with UTF-16, C++, 数组，&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.taoblog.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.taoblog.cn/tags/Java/"/>
    
      <category term="C++" scheme="http://www.taoblog.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java2_Core10Note</title>
    <link href="http://www.taoblog.cn/post/fe4f0218/"/>
    <id>http://www.taoblog.cn/post/fe4f0218/</id>
    <published>2019-09-17T06:45:48.000Z</published>
    <updated>2019-09-25T03:28:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java, Char with UTF-16, C++, 数组，<br><a id="more"></a></p><h2 id="异常，断言和日志"><a href="#异常，断言和日志" class="headerlink" title="异常，断言和日志"></a>异常，断言和日志</h2><p>来自Throwable类注解：<br>所有errors和exceptions都继承自Throwable类，只有Throwable或其子类的实例才可以被java虚拟机<br>处理，才能被throw，catch关键字抛出或捕获。</p><p>在Throwable子类中，RunTimeException和Error下属异常属于非检查异常，不属于它们的子类异常<br>则是检查异常，检查异常(checked exceptions)是用于编译期进行检查的异常。</p><p>异常的抛出是一个传递链，Throwable有以自身为参数的构造器，即一个Throwable中包含了另一个<br>Throwable作为引发该异常的异常原因。<br>这样设计有以下原因：</p><ol><li><p>可以让用户自定义异常包装底层实现的异常，通过抛出包装异常，而不直接抛出原生异常，<br>可以在更换方法的实现方式时，用户层面不用更改抛出的异常类型，从而避免了修改代码，保持了灵活性。<br>下面的ExceptionTest类代码以更强的方式实现了解耦合。</p></li><li><p>如某些接口或父类的方法本身并没有抛出异常，如果实现类需要抛出一个检查异常时，如果直接抛出<br>编译器会报错，提示父类或接口方法未抛出该异常。这时我们可以将这个检查异常用一个自定义的<br>未检查异常包装起来(通过Throwable cause参数)，从而绕开编译器检查。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ExceptionTest implements IF&#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     new ExceptionTest().add();</span><br><span class="line">  &#125;</span><br><span class="line">  // 不用声明运行时异常</span><br><span class="line">  @Override</span><br><span class="line">  public void add()&#123;</span><br><span class="line">    System.out.println(&quot;test&quot;);</span><br><span class="line">    // 使用自定义的运行时异常包装被检查异常</span><br><span class="line">    throw new WttException(&quot;null&quot;, new ParseException(&quot;parse&quot;, 0));</span><br><span class="line">  &#125;</span><br><span class="line">  // 定义为运行时异常</span><br><span class="line">  private class WttException extends RuntimeException&#123;</span><br><span class="line">    // 将检查异常包装起来</span><br><span class="line">    public WttException(String msg, Throwable clause)&#123;</span><br><span class="line">      super(msg, clause);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface IF&#123;</span><br><span class="line">  void add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>运行以上程序，结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; com.demo.ExceptionTest$WttException: null   // 先抛出上层异常</span><br><span class="line">  at XXX</span><br><span class="line">  at XXX</span><br><span class="line">caused by: java.text.ParseException: parse    // 再是clause Throwable底层异常</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>将cause Throwable链接到当前异常类，除了可以使用构造器，还可以使用initCause方法，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ExceptionTest implements IF&#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     new ExceptionTest().add();</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public void add()&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;test&quot;);</span><br><span class="line">    // 使用自定义的运行时异常包装被检查异常</span><br><span class="line">    WttException wttException = new WttException(&quot;wttException&quot;);   </span><br><span class="line">    wttException.initCause(new ParseException(&quot;wttParse&quot;, 0));</span><br><span class="line">    throw wttException;  </span><br><span class="line">// 注意initCause返回的是Throwable对象，如果返回它也会引起编译报错，</span><br><span class="line">// 这里直接返回外层包装的异常对象即可</span><br><span class="line">  &#125;</span><br><span class="line">  // 定义为运行时异常</span><br><span class="line">  private class WttException extends RuntimeException&#123;</span><br><span class="line">    public WttException()&#123;&#125;</span><br><span class="line">    public WttException(String msg)&#123;</span><br><span class="line">      super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface IF&#123;</span><br><span class="line">  void add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Throwable一般有4个构造器：</p><ol><li>default: no param</li><li>one param: String message</li><li>one param: Throwable cause</li><li>two params: String message, Throwable cause</li></ol><p>注： C++中2个基本的异常类，一个是<code>logic_error</code>,它相当于java的RunTimeException;另一个是<br><code>runtime_error</code>,它是由于不可预测原因引发的异常，相当于java的非RunTimeException.</p><p>注2： 绕过编译器抛出受查异常除了上述这样用一个运行时异常包装起来以外，还有其他方法可以直接<br>抛出受查异常并且通过编译，网上搜索到有以下2种方法：</p><ol><li>使用sun.misc.Unsafe类，由于它是私有构造器，所以需要使用反射。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CheckedExceptionTest &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">       Class unsafeClass = Class.forName(&quot;sun.misc.Unsafe&quot;);</span><br><span class="line">      // 反射使用私有无参构造器构造对象</span><br><span class="line">       Constructor&lt;Unsafe&gt; defaultConstructor = unsafeClass.getDeclaredConstructor(null);</span><br><span class="line">       defaultConstructor.setAccessible(true);</span><br><span class="line">       Unsafe unsafe = defaultConstructor.newInstance(null);</span><br><span class="line">       // 本地方法</span><br><span class="line">       unsafe.throwException(new Exception(&quot;wwwttt&quot;));</span><br><span class="line"></span><br><span class="line">    &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">       // 这里统一抛出上层异常</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里可以看到，使用反射也需要抛出多个ReflectiveOperationException的子类异常，它本身也是一个<br>受查异常，如果需要抛出的是它，那么这样做就没有意义了。</p><ol start="2"><li>利用泛型擦除机制绕过编译器检查。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CheckedExceptionTest &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    throwExp(new Exception(&quot;tt&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">  private static &lt;T extends Throwable&gt; void throwExp(Throwable th) throws T &#123;</span><br><span class="line">    throw (T) th;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>猜想：泛型擦除将<code>throws T</code>这一句去除了。如果直接<code>throws Throwable</code>编译器会报错。</p><p>经过测试，子类重写方法抛出的受查异常类型同方法返回值一样，子类方法只能抛出更具体的受查异常<br>或不抛受查异常，否则编译报错。使用throws关键字抛出运行时异常没有意义，因为所有方法都有可能<br>抛出运行时异常。</p><p>注: java throws与C++ throw说明符基本相同，不过C++ throw没有编译检查，如果抛出的异常未在<br>throw列表中，会调用unexpected函数中止程序执行。同理，java由于编译检查，它如果需要明确<br>抛出受查异常(不使用以上技术方案情况下),需要使用throws进行声明，而C++没有检查，没有限制。</p><p>抛出异常<br>java中需要抛出一个异常时，使用throw关键字抛出该异常类的一个对象即可。<br>注： Java中只能抛出Throwable子类的对象，C++可以抛出任何类型的值。</p><p>捕获异常<br>捕获还是抛出异常？<br>对于知道如何进行处理的异常可以进行捕获并处理，不知道如何处理的异常可以抛给调用者。<br>实际捕获的异常可能是catch中声明异常的子类，可以通过e.getClass().getName()来获取其实际类型。</p><p>捕获多个异常<br>可以使用多个catch语句对不同的异常进行处理。<br>jdk7以后可以在一个catch语句中对不同的异常进行相同的操作,<br>如<code>catch(AException | BException e)</code>,其中A和B异常是相互独立的，不能有继承关系;并且该异常<br>对象变量e默认为final变量，不能在处理中改变其值。</p><p>捕获到异常后又再次抛出它， 原因可能有：</p><ol><li>改变异常类型，可以创建自定义异常对象，将实际异常对象作为自定义异常的cause，通过这种包装<br>方式，调用者使用e.getCause()方法即可以拿到真正的异常原因，同时由于包装获得了异常对象的<br>系统一致性。</li><li>记录日志，用于在抛出异常前记录日志。这种情况下受查异常的声明(throws)与捕获的异常<br>类型(catch)应尽量保持一致。</li></ol><p>finally子句<br>finally语句是任何情况下都会执行的代码块，无论是否有异常发生。如果使用固定格式<br><code>try{}catch(){}finally{}</code>进行处理，由于finally语句块中代码也可能发生异常，这时候还需要<br>在finally中进行异常捕获，显得很繁琐。可以使用嵌套来进行解耦：finally专职于资源处理，catch<br>专职于捕获异常，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    ... </span><br><span class="line">    ...  // normal code</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">    XX.close(); // do with resources </span><br><span class="line">  &#125;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  ... // do with exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过嵌套使用try-finally和try-catch，finally块中可能抛出的异常也被catch语句捕获到了。<br>但还有另一个问题，由于finally语句块始终会被执行，所以当正常代码和finally同时抛出异常时，<br>finally异常会覆盖掉正常代码的异常，这个问题在jdk7的try-with-resource语法得到了解决,前面<br>有提到过它，它会自动抑制finally的异常。</p><p>注：finally语句块的return语句会覆盖正常代码的return语句，所以应避免在finally中使用return.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int doubleX(int x) &#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    return x * 2; </span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">    if (x == 2) return 0;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用doubleX(2)，得到结果0,可以理解为finally语句在<code>return x * 2</code>后执行。</p><p>try-with-resource<br>jdk7针对实现了AutoCloseable接口的资源类提供了一个语法糖，语法格式为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try(Resource res1 = ...;</span><br><span class="line">    Resource res2 = ...)&#123;</span><br><span class="line">  ...  // do sth with res1, res2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它会自动调用res1,res2的close方法，用javap查看反编译结果，可以看见它自动添加了finally语句，<br>并且抑制close方法中抛出的异常，可以使用getSuppressed()得到这个被抑制的异常。</p><p>堆栈轨迹<br>Throwable有一个getStackTrace()方法，返回的是一个StackTraceElement数组，这个数组的第一个元素<br>是最后执行或抛出异常的位置信息，后面的每个元素都代表了一个方法的调用。StackTraceElement<br>对象记录了所在类，方法名，文件名，当前代码所在行号的信息。StackTraceElement的toString方法<br>输出的即是我们经常见到的异常位置信息：方法名(文件名:行号).</p><p>注：Thread.getAllStackTraces()方法可以得到所有线程的堆栈轨迹map：它的key为线程对象，value为<br>StackTraceElement数组，在遍历map集合时调用map.get(thread)和使用thread.getStackTrace()方法<br>得到的结果相同，都是每个线程各自的方法调用轨迹数组。</p><p>注2: 如果想查看代码中某个位置的堆栈轨迹，可以使用<code>Thread.dumpStack()</code>方法，它会通过抛出一个<br>异常来打印轨迹，这适用于调试时查看某个方法从入口到被执行时经过的方法调用。</p><p>使用异常机制技巧</p><ol><li>异常处理不能代替简单测试。<br>如判断某个对象是否为null，捕获空指针异常要比使用if语句进行判断速度慢很多(显然捕获一个异常<br>后台需要做大量工作)。这说明了异常不应当被用于正常业务逻辑处理中，具体就是说不应当<br>在catch语句中进行业务逻辑处理。</li><li>不要过分的细化异常<br>即不要使用多个try-catch语句将正常业务逻辑处理分隔开，可以使用一个try语句块，多个catch语句<br>块将正常处理和异常处理分隔开，使代码清晰化。</li><li>利用异常层次结构<br>可以自定义异常来代替简单的RuntimeException或Throwable。<br>不要将业务逻辑异常定义为受查异常，这样做会提高耦合度，业务发生变化时无法灵活修改。<br>可以在catch语句中将捕获到的异常转换为另一种更合适的异常类型后再抛出，这样方便管理。</li><li>压制异常<br>如果调用的方法有受查异常，而该异常对于方法调用者来说可以忽略，这时可以使用try-catch语句捕获<br>后不做任何处理，直接忽视它。</li><li>严格检测错误(早抛出)<br>在方法处理完成后，有时要面对特殊情况下是抛出异常还是返回一个特殊值(如-1,null等)的选择，<br>一般建议抛出异常要比返回特殊值好，因为特殊值在以后的逻辑处理中如果没有判断处理，可能<br>会导致空指针等其他异常。但如果是工具类或其他类库工具，可以返回特殊值并给出注释告知调用者。<br>可以大概总结为：合理的边界情况可以使用特殊值，如果是明显不合理或错误的情况，应当抛出异常。</li><li>不要羞于抛出异常(晚捕获)<br>有时抛出异常让方法调用者处理是更为明智的选择。</li></ol><p>断言<br>格式为<code>assert x == 1;</code>或<code>assert x == 1: &quot;x == 1&quot;</code>,后一种语法格式可以在抛出AssertionError<br>时打印出自定义的表达式信息。</p><p>使用java命令运行程序时使用-ea开启断言，-da关闭断言，默认是关闭状态。<br>启用或关闭是类加载器的行为，即开启断言不需要重新编译，断言关闭时类加载器会自动跳过断言代码，<br>因此使用断言不会影响运行速度。</p><ol><li>断言失败是致命的，不可恢复</li><li>断言只适用于开发和测试阶段。<br>注： -ea无法应用到没有类加载器的”系统类”(jdk中的类)中，对于它们可以使用-esa<br>(-enableSystemAssertions).</li></ol><p>记录日志<br>java自带的日志记录器为java.util.logging.Logger类。</p><p>默认情况下，日志记录器把日志记录发送到consoleHandler处理器中，再由它输出到System.err流打印<br>出来。日志API提供了2个处理器，SocketHandler和FileHandler.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileHandler fileHandler = new FileHandler();</span><br><span class="line">logger.addHandler(fileHandler);</span><br><span class="line">logger.info(&quot;test log&quot;);</span><br></pre></td></tr></table></figure></p><p>运行以上代码，程序默认会在windows的用户目录下生成一个javaX.log文件，其中使用xml格式记录了<br>输出的日志信息。jdk logger提供了过滤器和格式化器进行日志过滤和格式化操作。<br>如上面程序中使用以下语句可以将xml格式转化为String:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileHandler.setFormatter(new SimpleFormatter());</span><br></pre></td></tr></table></figure></p><p>这样文件内容就与console管理台输出的内容一致了，这样倒是省去了在idea中配置日志输出重定向。</p><p>调试技巧</p><ol><li>使用java命令运行程序时使用-verbose参数可以查看虚拟机加载类的过程，对于诊断类路径问题很<br>方便。</li><li>jdk/bin目录下有一些可以查看程序性能的工具</li></ol><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><p>类型参数(type parameter)规定了元素类型，并省去了类型转换，使程序有更好的可读性和安全性。<br>jdk7以后在构造函数中可以省略泛型类型，因为它们可以从变量类型中推导出，如返回值可以直接返回<br><code>return new ArrayList&lt;&gt;();</code>.</p><p>泛型类<br>类名后使用如<code>&lt;T&gt;</code>或<code>&lt;T,U&gt;</code>声明一个类型变量，经测试<code>&lt;T,T&gt;</code>报错:重复类型参数。</p><p>泛型方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">   // 在方法名前指定类型参数</span><br><span class="line">   System.out.println(Test.&lt;Object&gt;middle(null, 0, &quot;sd&quot;));</span><br><span class="line">   //编译报错， 0是int，要求为String</span><br><span class="line">   System.out.println(Test.&lt;String&gt;middle(null, 0, &quot;sd&quot;));  </span><br><span class="line"> &#125;  </span><br><span class="line"> private static &lt;T&gt; T middle(T... ts) &#123;</span><br><span class="line">   return ts[ts.length / 2];  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大部分情况下，调用泛型方法时可以省略指定泛型类型，因为编译器可以从参数类型推导出泛型类型。<br>如使用以下语句<code>double x = cal(3.3, 23, 0);</code>，编译报错，错误信息提示’incompatible type:<br>Number &amp; Comparable…’,说明编译器根据参数推导得出T为Number类型或Comparable类型，可以改为<br><code>Number x = cal(3.3, 23, 0);</code>或<code>Comparable x = cal(3.3, 23, 0);</code>.<br>同理<code>double x = cal(3.3, 2, &quot;34&quot;);</code>可以看到推导出T类型为Serializable或Comparable.<br>由此可知，当不同类型的参数对应于一个类型参数时，最好将参数转化为统一类型，或使用明确类型<br>的变量接受返回值。</p><p>注：java泛型类似于C++中的template模板，但它们有本质区别。</p><p>类型变量的限定<br>如果想要对类型参数对应的类型增加某些参数，如指定实际类型必须实现Comparable接口，可以使用<br>extends关键字，如以上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&gt; T middle(T... ts)&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>当传入如<code>Pair&lt;Integer&gt;(2,3)</code>对象时，编译报错:<br><code>no instances of type variables exists so that Pair&lt;Integer&gt; conforms to Comparable</code>.</p><p>可以使用<code>&amp;</code>来区分多个限定，使用逗号区分不同的类型参数，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Number &amp; Comparable &amp; Serializable, U extends Cloneable&gt; </span><br><span class="line">  T middle(U u,T... ts)&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>类型变量的限定与类的继承机制保持一致，类型参数的限定也只能继承自一个类，实现多个接口，<br>并且类必须是限定列表的第一个。</p><p>泛型代码和虚拟机<br>虚拟机没有泛型类型对象：即虚拟机中只有普通类。泛型仅仅是编译时的语法糖，同枚举，内部类，<br>try-with-resource等语法一样。</p><p>每个泛型类型都有自己的原始类型(raw type),程序执行时会擦除泛型，将变量类型替换为泛型<br>的第一个限定类型,无限定类型的转为Object.<br>如<code>T extends Comparable &amp; Serializable</code>会转化为限定类型Comparable,而<br><code>T extends Serializable &amp; Comparable</code>会转化为Serializable,当代码里执行compareTo方法时，<br>程序会强制转型为Comparable，所以为了提高效率，应当将无方法的记号接口放在限定列表的最后。</p><p>泛型擦除后编译器会增加必要的强制类型转换，如代码<br><code>List&lt;Integer&gt; list = ...; int a = list.get(0)</code>执行时，编译器会自动转化为<br><code>int a = (Integer)list.get(0);</code>.</p><p>泛型擦除机制导致的问题及解决方法</p><p>泛型方法擦除泛型后，类型转化为限定类型(如Object)，如果其子类使用具体类型(如String)进行<br>方法重写时将会出现问题：如果是set方法将与多态调用产生冲突(产生2个不同类型参数的方法)，<br>如果是get方法则产生了方法签名相同而返回值不同的方法。</p><p>对于get方法，方法签名是由方法名和参数列表决定的，如果方法重载时方法签名相同，返回值不同，<br>编译器会报错(因为调用者可以忽略返回值).但是虚拟机是根据方法签名和返回值来确定方法调用的，<br>所以即使泛型擦除导致出现了相同签名的方法出现，虚拟机也可以解决。相当于用户自己编写这样的<br>代码经过编译检查会报错无法执行，而编译器自动产生的绕过了检查机制可以被虚拟机执行。</p><p>针对set方法编译器会修改继承的限定类型(如Object)方法，在其中调用重写的新方法，这也称为<br>桥方法(bridge method).实际上桥方法也应用在重写方法时子类方法返回协变类型上，它也是合成了<br>桥方法调用重写的方法。桥方法的作用就是保持多态。</p><p>将泛型类型参数赋值给无泛型参数变量时，会得到编译器警告信息，一般情况下可以使用<br>@SuppressWarnings(“unchecked”)注解来压制警告。</p><p>泛型的约束和影响</p><ol><li>泛型类型参数不能是基本数据类型<br>因为泛型擦除后泛型类型需要转化为Object类型，基本类型无法转化为Object,所以需要对应的包装类。</li><li><p>运行时类型检查不支持泛型参数<br>即无法使用instanceof关键字判断泛型类型，<code>if(pair instanceof Pair&lt;LocalDate&gt;){...}</code>会<br>得到编译报错：illegal generic type for instanceof. 关键字instanceof只能用来判断原始类型:<br><code>if(pair instanceof Pair){...}</code>。<br>同样的，使用getClass()得到的结果始终是原始类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; pair1 = new Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Integer&gt; pair2 = new Pair&lt;&gt;();</span><br><span class="line">System.out.println(pair1.getClass() == pair2.getClass());  // 都是Pair.class</span><br></pre></td></tr></table></figure></li><li><p>无法创建泛型数组<br>代码<code>List&lt;String&gt;[] listArray = new List&lt;String&gt;[10];</code>报错：generic array creation.<br>其中泛型数组可以声明，但无法进行初始化。原因在于泛型数组破坏了泛型的类型安全。<br>因为数组是可协变的，子类数组可以转化为父类数组，用户可以通过父类数组引用破坏泛型类型安全，<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用强制类型转换得到泛型数组，后面也可以写为new List&lt;?&gt;[10]</span><br><span class="line">List&lt;String&gt;[] listArray = (List&lt;String&gt;[])new List[10];</span><br><span class="line">Object[] objects = listArray;  // 向上转型为Object[]</span><br><span class="line">objects[0] = Arrays.asList(1);   // 通过objects存入一个List&lt;Integer&gt;</span><br><span class="line">String s = listArray[0].get(0);  // 运行报错，类型转换异常</span><br></pre></td></tr></table></figure></li><li><p>可以在@SafeVarargs注解的注释上看到上面的这个例子。</p></li><li>不能实例化类型变量，如T.class, new T[…],new T(…)都会产生编译错误。在jdk8以前，只能<br>使用Class.newInstance方法来构造需要的类型对象，而jdk8以后可以使用构造器引用。<br>如创建一个pair对象的泛型方法，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    Pair&lt;String&gt; stringPair = makePair(String.class, &quot;s&quot;, &quot;w&quot;);</span><br><span class="line">    System.out.println(stringPair.getF());</span><br><span class="line">    System.out.println(stringPair.getS());</span><br><span class="line"></span><br><span class="line">    Pair&lt;String&gt; stringPair2 = makePair2(String::new, &quot;d&quot;, &quot;f&quot;);</span><br><span class="line">    System.out.println(stringPair2.getF());</span><br><span class="line">    System.out.println(stringPair2.getS());</span><br><span class="line">  &#125;</span><br><span class="line">  private static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; tClass, T f, T s) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return new Pair&lt;&gt;(tClass.getDeclaredConstructor(tClass).newInstance(f),</span><br><span class="line">                        tClass.getDeclaredConstructor(tClass).newInstance(s));</span><br><span class="line">    &#125; catch (ReflectiveOperationException e) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private static &lt;T&gt; Pair&lt;T&gt; makePair2(Function&lt;T,T&gt; function, T f, T s) &#123;</span><br><span class="line">      return new Pair&lt;&gt;(function.apply(f), function.apply(s));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注： String.class实际为<code>Class&lt;String&gt;</code>的唯一实例，所以makePair方法可以得到T类型(值得注意<br>的是T类型无法从参数f,s获得，代码<code>Class&lt;T&gt; tClass = f.getClass()</code>报错：<br><code>Found Class&lt;T&gt;, Required Class&lt;capture&lt;? extends java.lang.Object&gt;&gt;</code>,可以看到由于泛型擦除，<br>f变为Object类型，无法强转为具体的T类型)。<br>构造器引用使用的构造器为new String(String),对应的函数接口为<code>Function&lt;T,T&gt;</code>,</p><ol start="6"><li><p>不能实例化泛型数组。像上面说的那样，不能直接初始化泛型数组，实际使用时有<br><code>E[] = (E[])new Object[10];</code>这是因为初始元素null可以转化为任意的Object子类型，<br>但针对已经存在数组元素的数组就无法使用这种方式强转了，如数组拷贝等需求。在前面的数组反射和<br>数组构造器引用已经分别写过解决方案，下面统一一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayGenericTest &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    // 可变参数可以直接传递数组</span><br><span class="line">    Integer[] integers = makeGenericArray(new Integer[]&#123;23, 23, 45&#125;);</span><br><span class="line">    System.out.println(Arrays.toString(integers));</span><br><span class="line"></span><br><span class="line">    // 构造器引用</span><br><span class="line">    String[] strings = makeGenericArray2(String[]::new, &quot;d&quot;, &quot;s&quot;, &quot;f&quot;);</span><br><span class="line">    System.out.println(Arrays.toString(strings));</span><br><span class="line">  &#125;</span><br><span class="line">  private static &lt;T&gt; T[] makeGenericArray(T... ts) &#123;</span><br><span class="line">    T[] newT = (T[])Array.newInstance(ts.getClass().getComponentType(), ts.length);</span><br><span class="line">    // do something else with T[]</span><br><span class="line">    // 对于引用类型数组必须需要使用clone方法才能得到新的对象引用, 不能单纯使用下面的方法</span><br><span class="line">    System.arraycopy(ts, 0, newT, 0, ts.length);</span><br><span class="line">    return newT;</span><br><span class="line">  &#125;</span><br><span class="line">  private static &lt;T&gt; T[] makeGenericArray2(Function&lt;Integer, T[]&gt; function, T... ts) &#123;</span><br><span class="line">    T[] newT = function.apply(ts.length);</span><br><span class="line">    // do something else with T[]</span><br><span class="line">    System.arraycopy(ts, 0, newT, 0, ts.length);</span><br><span class="line">    return newT;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不能在静态域或静态方法中使用泛型变量。如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;T&gt; &#123;</span><br><span class="line">  private static T tt;    // 编译报错，pair.this cannot be referenced from a static context</span><br><span class="line">  private static T getTt()&#123;</span><br><span class="line">    return tt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以从报错信息知，类型变量默认是与实例进行绑定的，可以理解为类在实例化前尚未确定T类型，所以<br>无法确定静态域tt的类型，静态方法也是一样道理。<br>注： 同样的，如下代码同基本的static域无任何不同:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person&lt;T&gt;&#123;</span><br><span class="line"> public static int id;</span><br><span class="line">&#125;</span><br><span class="line">Person&lt;Integer&gt; p1 = new Person&lt;&gt;();</span><br><span class="line">p1.id = 3;</span><br><span class="line">Person&lt;String&gt; p2 = new Person&lt;&gt;();</span><br><span class="line">p2.id = 4;</span><br><span class="line">System.out.println(p1.id);</span><br></pre></td></tr></table></figure></p><p>这个例子其实和泛型变量没有太大关系，id只是一个普通的静态域罢了。</p><ol start="8"><li>无法捕获泛型异常，也不能使用泛型类继承Throwable类(正因为无法继承，所以也不存在带有泛型<br>变量的异常类型，也就无法抛出带有泛型类型的异常对象)，但可以声明Throwable类限定的泛型<br>类型并抛出它。因为泛型是编译时生效，而异常是运行时处理，所以异常无法支持泛型。如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person&lt;T&gt; extends Throwable&#123;&#125;  // error: generic class may not extend Throwable</span><br><span class="line"></span><br><span class="line">class Person&lt;T extends Throwable&gt; &#123;</span><br><span class="line">  public void say() &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      System.out.println(&quot;go&quot;);  </span><br><span class="line">    &#125;catch(T e) &#123;  // error: cannot catch type parameters</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 因MyException&lt;T&gt;无法继承Throwable,所以throw new MyException&lt;String&gt;()也不可能存在</span><br><span class="line">// 泛型参数不能被抛出，但可以将整个异常类作为泛型参数抛出，如前面利用泛型绕过受查异常</span><br><span class="line">// 编译检查的例子:</span><br><span class="line">public static &lt;T extends Throwable&gt; void f(Throwable th) throws T &#123;</span><br><span class="line">  throw (T)th;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>9.消除受查异常检查。<br>代码即如上所示，调用时如”f(new ParseException(“sd”, 0));”编译通过，运行时抛出受查异常<br>ParseException.但这种简略写法其实默认等同于<br><code>OuterTest.&lt;RuntimeException&gt;f(new ParseException(&quot;sd&quot;, 0));</code>,即指定T类型为RuntimeException<br>(或者Error类型);如果改为<code>OuterTest.&lt;Exception&gt;f(new ParseException(&quot;sd&quot;, 0));</code>，<br>编译器同样报错unhandled exception.</p><ol start="10"><li><p>泛型冲突<br>如类Child继承Parent类，而Parent实现了<code>Comparable&lt;Parent&gt;</code>接口，此时Child类再次实现接口<br><code>Comparable&lt;Child&gt;</code>编译报错，因为Child会同时实现<code>Comparable&lt;Parent&gt;和Comparable&lt;Child&gt;</code>,<br>由于前面说过的泛型擦除和重写泛型方法问题，编译器会自动合成对应的桥方法，在桥方法中调用重写<br>的方法，此时子类同时拥有不同的参数类型，桥方法即无法确定调用哪一个，所以这种情况是不被允许的。</p></li><li><p>泛型与继承<br>泛型参数本身的继承关系对其实际类型无关，即<code>ArrayList&lt;Number&gt;和ArrayList&lt;Integer&gt;</code>类型没有<br>任何关系:这一点其实也是由泛型擦除决定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Number&gt; numbers = integers;   // Error: incompatible types</span><br><span class="line">numbers.set(0, 3.444);                 // cannot be allowed to happen</span><br></pre></td></tr></table></figure></li></ol><p>(如果这2者可以转换，理由类似于无法创建泛型数组一样:<br>经过向上转型传递引用，破坏了类型安全。数组本身的可协变性则是由其自身的保护机制决定的，如果<br>元素类型没有严格相符，它会抛出ArrayStoreException.)</p><p>另一方面，当泛型参数相同的情况下，类或接口本身的继承关系仍然有效，如<code>ArrayList&lt;Integer&gt;是List&lt;Integer&gt;的子类</code>(如果泛型参数Integer不同，转换类型时会产生编译错误，不符合泛型要求)。</p><p>如果<code>ArrayList&lt;Integer&gt;</code>转换为原生类型ArrayList,则相当于里面的元素都转换为Object类型，原有<br>泛型类型限制就全部失效了。</p><ol start="12"><li><p>通配符<br>由于上面说的<code>ArrayList&lt;Number&gt;和ArrayList&lt;Integer&gt;</code>毫无关系，但有时候一个方法的参数类型需要<br>能同时处理这2种类型，这时候可以使用通配符<code>?</code>，它又分子类型限定通配符和超类限定通配符2种，<br>总体来说，<strong>子类限定可以读，超类限定可以写</strong>(或者理解为指定了父类可以读，指定了子类可以写)</p><ol><li><p>需要访问值时，使用子类通配符(? extends XX)对子类型统一访问，但不能更改子类型的值。<br>对于子类限定的set方法来说,? extends Number指Number类的<strong>某一个</strong>子类类型，可以认为它<br>不能接收任何具体的类型(包括Number本身和其下的任何子类型)，以这种类型的区别来禁止使用。<br>而对于get方法它就可以成功转化，统一转型为Number类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</span><br><span class="line">integers.add(2);</span><br><span class="line">// 引用传递可以为Number本身或其子类型</span><br><span class="line">ArrayList&lt;? extends Number&gt; numbers = integers;     // OK  </span><br><span class="line"></span><br><span class="line">// 对子类型限定通配符的泛型对象无法设置值</span><br><span class="line">// compilation Error: wrong type,Found Integer, required ? extends Number </span><br><span class="line">numbers.set(0, (Integer)3);     </span><br><span class="line"></span><br><span class="line">// compilation Error: wrong type,Found Number, required ? extends Number </span><br><span class="line">numbers.set(0, (Number)3);     </span><br><span class="line"></span><br><span class="line">// OK, 整型元素可以向上转型为Number类型被统一访问到 </span><br><span class="line">Number first = numbers.get(0);</span><br></pre></td></tr></table></figure></li><li><p>需要更改参数值时，使用超类通配符(? super XXX)传入各个父类型泛型的对象，当使用符合<br>泛型要求的子类型XXX的值传入set方法时，可以向上转型从而成功赋值。而get方法因无法确定<br>父类型，所以只能转换为Object类型。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Number&gt; nums = new ArrayList&lt;&gt;();</span><br><span class="line">nums.add(2);</span><br><span class="line">// 引用传递可以为Double本身或其父类型</span><br><span class="line">ArrayList&lt;? super Double&gt; doubleSupers = nums;     // OK  </span><br><span class="line"></span><br><span class="line">// OK，double可以像上转型为Number类型，没有违反nums的泛型安全</span><br><span class="line">doubleSupers.set(0, 6.32);</span><br><span class="line"></span><br><span class="line">//compilation error: wrong type:found Integer, required ? super Double</span><br><span class="line">doubleSupers.set(0, 33); </span><br><span class="line"></span><br><span class="line">// OK，get方法得到Object类型，需要强制转型。</span><br><span class="line">// 实际使用时在库方法中无法得知参数的具体类型为Number</span><br><span class="line">Number one = (Number)doubleSupers.get(0);</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>注： 如以上提到的泛型冲突问题：时间类LocalDate实现了接口ChronoLocalDate,而ChronoLocalDate<br>接口继承了Compare(ChronoLocalDate)接口，所以LocalDate就无法实现Compare(LocalDate)接口。<br>这对于方法<code>public &lt;T extends Comparable&lt;T&gt;&gt; T getMax(T... ts){...}</code>来说就无法使用LocalDate<br>作为参数类型，我们可以使用超类限定通配符将其中的泛型声明部分改为<br><code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code>，使得compare方法参数类型可以是被比较元素T的父类，从而<br>解决这个问题。</p><ol start="3"><li>无限定通配符<br>如<code>ArrayList&lt;?&gt;</code>,它和原生类型的区别即在于无限定通配符无法使用set方法修改对象，原生对象可以。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(23);  // 编译报错：add(capture&lt;?&gt;)in ArrayList cannot be applied to (int)</span><br><span class="line">ArrayList list2 = new ArrayList&lt;&gt;();</span><br><span class="line">list2.add(23);  // OK</span><br></pre></td></tr></table></figure></li></ol><p>使用无限定通配符有时可以对一些简单操作方法省去泛型类型T.如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; boolean isNull(Pair&lt;T&gt; p)&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>可写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void boolean isNull(Pair&lt;?&gt; p)&#123;...&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>通配符捕获<br>以上例子中方法<code>public void boolean isNull(Pair&lt;?&gt; p){...}</code>并不是一个泛型方法，它有着一个<br>固定类型为<code>Pair&lt;?&gt;</code>的参数,有时在方法内需要捕获该类型进行对象处理，如<code>? f = p.getF()</code>,但<br>?并不是一个实际类型，这样写会报错，这时可以另写一个泛型方法捕获这个通配符类型。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ArrayList&lt;Number&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(3.67);</span><br><span class="line">    f(list);</span><br><span class="line">  &#125;  </span><br><span class="line">  // 这个例子仅为演示通配符捕获的作用，实际上可以直接使用ArrayList&lt;T&gt;</span><br><span class="line">  private static void f(ArrayList&lt;? extends Number&gt; list)&#123;</span><br><span class="line">    getType(list);</span><br><span class="line">  &#125;</span><br><span class="line">  // 使用通配符捕获在库方法中得到具体的类型</span><br><span class="line">  private static &lt;T&gt; void getType(ArrayList&lt;T&gt; list)&#123;</span><br><span class="line">    T t = list.get(0); </span><br><span class="line">    System.out.println(t.getClass());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>值得注意的是，只有通配符匹配的类型可以唯一确定的情况下才能捕获，否则无法捕获。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 使用上面的Pair&lt;T&gt;类</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   ArrayList&lt;Pair&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">   list.add(new Pair&lt;String&gt;(&quot;sd&quot;, &quot;f&quot;));  // OK</span><br><span class="line">// list.add(new Pair&lt;Integer&gt;(32, 34));   // OK</span><br><span class="line">   //编译报错: reason: incompatible equality constraint: T and ?</span><br><span class="line">   cap(list);</span><br><span class="line"> &#125;  </span><br><span class="line"> private static &lt;T&gt; void cap(ArrayList&lt;Pair&lt;T&gt;&gt; list) &#123;</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注: 通配符泛型对象如Pair&lt;?&gt;, Pair&lt;? extends XXX&gt;是无法修改值的(? super XXX除外),<br>所以它们一般都是作为引用的接收对象，在引用传递过程中通配符类型可以被唯一确定。<br>而在上面的例子<code>ArrayList&lt;Pair&lt;?&gt;&gt;</code>中,<code>Pair&lt;?&gt;</code>整体作为泛型参数实际上等同于Pair原生类型，<br>无法确定<code>Pair&lt;T&gt;</code>中T的具体类型。</p><ol start="13"><li>反射和泛型<ol><li>泛型Class类<br>反射关键类Class本身是一个泛型类<code>Class&lt;T&gt;</code>,String.class其实是<code>Class&lt;String&gt;</code>的唯一实例。</li><li>使用<code>Class&lt;T&gt; c</code>作为方法参数接受XXX.class类型，在方法中可以使用T作方便的处理。</li><li>虽然泛型参数在虚拟机中被擦除，但可以通过java.lang.reflect.Type接口下的几个子接口<br>获得泛型参数的相关信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Type:  只有一个接口默认方法getTypeName</span><br><span class="line"></span><br><span class="line">对于Type类型的变量type可以使用type instanceof XXX(XXX为以下类型)来判断具体类型</span><br><span class="line">Class:   普通类型，如类，接口，数组等</span><br><span class="line"></span><br><span class="line">   TypeVariable[] getTypeParameters()  该类型如果带有泛型，则返回其泛型类型变量列表;否则</span><br><span class="line">   返回长度为0的数组。(经测试类，接口都可以成功取得泛型变量，由于无法创建泛型数组，所以</span><br><span class="line">   数组类型如Comparable[].class调用该方法都是返回0长度数组)</span><br><span class="line"></span><br><span class="line">   Type[] getGenericInterfaces()  返回当前类型(类或者接口)实现的泛型接口列表。</span><br><span class="line"></span><br><span class="line">   Type getGenericSuperclass()  返回当前类型的父类泛型信息(父类无泛型返回父类类型即可)，</span><br><span class="line">   该方法限定为类类型使用，其他如Object本身或接口类型会返回null,数组类型统一返回</span><br><span class="line">   java.lang.Object。</span><br><span class="line"></span><br><span class="line">   Method类中关于泛型的方法:</span><br><span class="line">     TypeVariable[] getTypeParameters()  返回方法声明的泛型变量列表，同Class类中方法</span><br><span class="line">     Type getGenericReturnType()       获得泛型返回值 </span><br><span class="line">     Type[] getGenericParameterTypes()  获得方法泛型参数</span><br><span class="line"></span><br><span class="line">TypeVariable: 描述了泛型变量，如T extends Number</span><br><span class="line">    String getName()  获取类型变量名称，如T,E,K等</span><br><span class="line">    Type[] getBounds()  获取类型变量的子类限定列表，超类，接口等，</span><br><span class="line">       如T extends Object &amp; Comparable,若无限定，返回长度为0的数组。</span><br><span class="line">       不存在T super XXX语法，因为T为确定类型，super无法确定类型，只有通配符才有super.</span><br><span class="line"></span><br><span class="line">WildcardType: 描述通配符类型，如? super T</span><br><span class="line">   Type[] getUpperBounds()  获取通配符子类限定(extends)列表，无则返回长度为0数组</span><br><span class="line">   Type[] getLowerBounds()  获取通配符超类限定(super)列表，无则返回长度为0数组</span><br><span class="line"></span><br><span class="line">ParameterizedType: 描述泛型类或泛型接口，如Comparable&lt;T&gt;</span><br><span class="line">   Type getRawType()  获取泛型类原始类型 </span><br><span class="line">   Type[] getActualTypeArguments()  获取实际的类型参数 如Map&lt;K,V&gt;中的K,V列表</span><br><span class="line">   Type getOwnerType()  获取所在类，如内部类O&lt;T&gt;.I&lt;S&gt;类型调用该方法返回外部类O&lt;T&gt;，</span><br><span class="line">      否则返回null</span><br><span class="line"></span><br><span class="line">GenericArrayType: 描述泛型数组，如T[]或Comparable&lt;T&gt;[]</span><br><span class="line">   Type getGenericComponentType(); 获取数组元素泛型类型,泛型数组不可创建，但可以作为引用</span><br><span class="line">     接收，如Comparable&lt;String&gt;[] carr = (Comparable&lt;String&gt;[])new Comparable&lt;?&gt;[10];</span><br><span class="line">      但这种做法存在类型转换隐患。</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>书中的代码示例GenericReflectionTest非常经典，总结如下：</p><ol><li>一个泛型类继承另一个泛型类时，当前类的泛型是定义(相当于程序中的isDefinition = true),<br>如<code>class C&lt;K,S&gt; extends P&lt;K,S&gt;</code>,父类的泛型参数只能为<code>&lt;K,S&gt;或&lt;S,K&gt;</code>，即只能在当前类的泛型<br>中定义泛型变量，后面父类的泛型只能使用定义好的泛型变量; 类似的，泛型方法返回值前也是泛型<br>变量的定义区。</li><li>只有在定义泛型变量(除去通配符的情况)时，允许出现限定符extends,在使用变量时不能进行限定。<br>这一点可以从isDefinition变量只有在printType方法的TypeVariable类别中进行判断添加Bound限定<br>看出。</li><li>通配符符号?在WildcardType接口中没有方法获得，所以需要手动打印。</li></ol><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="java集合框架"><a href="#java集合框架" class="headerlink" title="java集合框架"></a>java集合框架</h3><ol><li>接口和实现分离<br>如List接口和它的具体实现ArrayList,LinkedList.使用List接口作为引用操作集合时，如果需要<br>更换实现，只需要改变初始化集合对象一处即可以，这样就实现了解耦。</li><li>Collection接口<br>boolean add(E e) 和Iterator<e> iterator()</e></li><li>迭代器<br>for each循环是语法糖，会转化为带迭代器的循环。Collection接口定义为<br><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;{...}</code>,<br>Iterable接口只有一个抽象方法<code>Iterator&lt;T&gt; iterator();</code>,因此，对于任何一个Collection集合<br>都可以使用for each循环。<br>Iterator接口在jdk8后新增了一个默认方法forEachRemaining,可以使用它配合λ表达式不使用for<br>循环即可遍历处理元素。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(3);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(4);</span><br><span class="line">list.add(2);</span><br><span class="line">list.iterator().forEachRemaining(System.out::println);</span><br></pre></td></tr></table></figure></li></ol><p>java迭代器并不存储元素的位置信息，查找元素和指针位置变动是结合在next()方法中一起执行的，<br>它无法像数组索引一样在迭代器中查找位于中间或后面随机位置的元素(即随机访问)，只能依次读取。<br>可以认为java迭代器指针指向的是2个元素之间的位置，调用next方法时”越过”下一个元素并返回它。</p><p>注: C++的迭代器是根据数组索引创建的，指针指向每个元素，同数组索引一样，不需要查找元素就可以<br>移动指针。</p><p>Iterator的remove()方法必须在next()方法后调用，每个next()方法后只能调用一次remove()方法删除<br>刚刚”越过”的这个元素，否则将抛出异常IllegalStateException.<br>因此，需要连续删除2个元素时只能这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterator.next();</span><br><span class="line">iterator.remove();</span><br><span class="line">iterator.next();</span><br><span class="line">iterator.remove();</span><br></pre></td></tr></table></figure></p><p>注：ArrayList遍历同时删除元素的问题是一个老问题了：<br>这个问题其实主要是在于ArrayList的2处源码：ArrayList.Itr的remove方法和ArrayList.remove方法。</p><ol><li>ConcurrentModificationException: 经测试，使用foreach循环遍历ArrayList集合时<br>调用list.remove()方法时可能会报这个异常，但并不是一定会报: ArrayList继承了List接口，<br>iterator()方法返回的是其内部定义的一个迭代器Itr,Itr有一个实例域expectedModCount，<br>意思是expected modified count,预计修改过List集合结构的次数，如新增或删除元素会改变列表大小<br>的操作次数。AbstractList中有一个可继承的域modCount即用来统计该次数，迭代器初始化时<br>expectedModCount = modCount, Itr的next方法中第一步即为CheckForComodification()检查计数值<br>modCount和expectedModCount值是否相等，不等时即抛出该异常。</li></ol><p>使用迭代器对ArrayList遍历时调用iterator.remove()方法可以正确删除，这是因为<br>iterator.remove()方法中有对modCount的重新赋值操作，能够保证检查的2个值相等。</p><p>经测试发现，当使用foreach循环list.remove删除倒数第二个元素时，程序不会抛出该异常，可以<br>理解为foreach语法糖转化后的迭代器执行完list.remove方法后没有下一个元素了，<br>即iterator.hasNext() == false,从而跳出了循环，没有进入到循环中继续执行将抛出异常的next方法。</p><ol start="2"><li>ArrayList的迭代器有检查机制会抛出异常。如果不用迭代器而使用普通索引for循环会怎么样？<br>由于ArrayList本身是数组实现的，查看remove(obj)方法源码可知，该方法是通过将删除元素<br>后的元素使用System.arrayCopy方法统一前进一位，删除最后一个元素来实现的。</li></ol><p>这样的话如果对列表”2,3,3,4”删除其中的元素3,会发现结果为”2,3,4”,即删除了第一个3后，后面一个<br>3元素由于移位避开了遍历从而跳过了删除判断。对于这个问题，可以使用倒序遍历的方式来解决：<br>由于是倒序遍历，删除某个元素后，后面的元素统一前移一位，这时使用list.get(i)时i由于是减法<br>所有刚好能取到后面前移的那个元素，从而实现正确遍历。</p><p>总结以上2点，使用迭代器的hasNext()，next(),remove()方法对集合进行遍历同时修改的操作才是<br>最佳实践，另外也可以使用普通for循环倒序遍历集合调用list.remove()方法。</p><ol start="4"><li>泛型实用方法<br>Collection接口声明了很多有用的方法，如int size(), boolean isEmpty(),boolean contains(obj),<br>boolean remove(obj),Object[] toArray()等，对于部分方法由AbstractCollection抽象类提供了具体<br>实现，自定义的接口实现类继承它只需要实现部分抽象方法即可。</li></ol><p>对于jdk8以后的类，在Collection接口中添加了很多默认方法，更加方便，如<br>boolean removeIf(Predicate&lt;? super E&gt; filter)按条件删除(使用超类限定符可以使用Object类的方法)。<br>还有其他一些与流相关的操作方法。</p><ol start="5"><li>集合框架中的接口<br>集合有2个基本接口，Collection和Map,Collection下主要有List,Set,Queue子接口。</li></ol><p>List是有序列表，支持随机访问，方法如E get(index),void add(index, element),<br>boolean remove(index)(注意remove是删除第一次出现的该元素，即索引最小的元素，而不是所有相同的<br>重复元素)等支持按索引进行操作。但实际上List可以由数组或链表来实现，链表虽然也<br>实现了相应随机访问方法，但是效率非常低。为了解决这个问题，jdk1.4引入了一个记号接口<br>RandomAccess,它本身同Cloneable一样，没有任何方法，仅是一个接口。可以通过<br><code>XXX instanceof RandomAccess</code>判断XXX类是否支持高效随机访问，如ArrayList就实现了RandomAccess<br>接口，LinkedList没有实现它。这时可以使用迭代器来顺序遍历链表。</p><p>迭代器Iterator针对List上的遍历有一个ListIterator子接口，它新增了hasPrevious(), previous(),<br>add(),set()等额外的方法以更方便的在list上使用迭代器。</p><p>List接口的主要实现类有AbstractList(ArrayList, Vector,LinkedList)</p><h3 id="具体的集合"><a href="#具体的集合" class="headerlink" title="具体的集合"></a>具体的集合</h3><p>具体实际使用的集合有以下这些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. ArrayList           可以动态改变大小的索引序列(动态数组)</span><br><span class="line">2. LinkedList          可以在任意位置高效插入和删除元素的有序序列(双向链表)</span><br><span class="line">3. ArrayDeque          用循环数组实现的双端队列 </span><br><span class="line">4. HashSet             无序集(无重复元素)</span><br><span class="line">5. TreeSet             有序集(无重复元素)</span><br><span class="line">6. EnumSet             枚举集(无重复元素)</span><br><span class="line">7. LinkedHashSet       可以记住元素插入次序的集 </span><br><span class="line">8. PriorityQueue       允许高效删除最小元素的集合(优先队列)</span><br><span class="line">9. HashMap             键值对</span><br><span class="line">10. TreeMap            键值有序排列的映射表</span><br><span class="line">11. EnumMap            键是枚举类型的映射表</span><br><span class="line">12. LinkedHashMap      可以记住键值对添加顺序的映射表</span><br><span class="line">13. WeakHashMap        值无用后可以被GC回收的映射表</span><br><span class="line">14. IdentityHashMap    用==而不是equals比较键值的映射表</span><br></pre></td></tr></table></figure></p><p>AbstractCollection:<br>   为方便实现Collection接口，jdk提供了AbstractCollection抽象类。其中对很多方法都提供了默认实现,<br>如contains(object)，toArray(),remove(object),addAll(collection)等。</p><p>类注释中说明，如果需要实现的是一个不可变的类，则只需要实现iterator()和size()方法，<br>其中iterator()返回的迭代器需要实现hasNext和next方法(add方法默认实现是抛出UnsupportedException).</p><p>如果需要实现一个可变集合，就需要额外实现add方法，并且迭代器还需要实现remove()方法。<br><em>可以看到ArrayDeque是直接继承了AbstractCollection类</em>。</p><p>AbstractCollection主要有以下子类，AbstractList,AbstractSet,AbstractQueue,ArrayDeque,<br>ConcurrentLinkedDeque.</p><h4 id="AbstractList"><a href="#AbstractList" class="headerlink" title="AbstractList:"></a>AbstractList:</h4><p>AbstractList继承自AbstractCollection类，实现了List接口。前面已提到，List接口对于Collection<br>接口扩展了一些随机访问方法，AbstractList类同样继承了这些方法，并针对其中部分方法如<br>indexOf(object),lastIndexOf(object)方法提供了实现。</p><p>对于上面说的AbstractCollection实现要求，可以看到AbstractList简单实现了add方法，相当于增加了<br>一个索引作为参数，具体处理还是抽象的。迭代器实现有内部类Itr,同时还有一个ListIterator接口<br>实现的内部类ListItr，它们实现了hasNext(), next(), remove()方法。size方法没有给出默认实现。<br>同时，还给出了获取子列表subList(from,to)方法。</p><p>同AbstractCollection一样，AbstractList类注释中也给出了实现类的要求：<br>如果是实现一个不可变list集合，实现类只需要提供get(index)和size()方法的实现。<br>如果是实现一个可修改的list集合，实现类需要额外实现set(index, object),set(index, E)方法。如果<br>该集合大小可变，实现类需要额外实现add(index, object),add(index, E)和remove(index)方法。</p><p>AbstractList的主要子类有ArrayList, Vector,  主要子接口有AbstractSequentialList.</p><ol><li><p>ArrayList</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAcess, Cloneable, </span><br><span class="line">   java.io.Serializable</span><br></pre></td></tr></table></figure><p>   可变大小数组实现的list集合。在add方法中添加元素前会检查数组容量，如果数组容量不够，具体<br>为grow方法中的<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>,即每次扩容都扩大<br>现有容量的一半，直到符合要求为止。所以在初始化ArrayList时指定大小可以提高程序性能，<br>减少自动扩容的次数，由于默认容量是10, 所以初始化大小如果指定容量小于10没有意义，程序中有<br>取值比较<code>minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity)</code>，扩容从10开始。<br>同样的，如果显式的调用ensureCapacity(int)方法，它也是调用grow方法，一半一半的扩容直到<br>符合容量要求，效率较低，所以如果初始化时可以确定大概大小最好指明容量，然后调用完毕后使用<br>trimToSize()方法将容量变为与数组大小一致，去除list中多余的null元素。</p></li></ol><p>ArrayList的类注释概述了上面的扩容机制，并提到ArrayList本身并不是线程安全的，可以使用<br><code>Collections.synchronizedList(new ArrayList());</code>来获得线程安全的list集合。同时，也提到<br>ArrayList中的迭代器在创建迭代器后对list做结构修改会引发快速失败(即抛出并发修改异常)的机制<br>并不是非常确定的(如上面说的删除倒数第二个元素的例子)，不能依靠这个来写程序，只应作为检测bug的<br>手段。实际上前面异常章节中有提到不应当依靠任何异常进行逻辑处理，不在catch语句中做业务逻辑。</p><ol start="2"><li>Vector<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAcess, Cloneable, </span><br><span class="line">   java.io.Serializable</span><br></pre></td></tr></table></figure></li></ol><p>Vector是线程安全的，而ArrayList是线程不安全的。Vector的elements()返回的是一个类似于迭代器<br>的Enumeration接口，属于遗留代码。</p><ol start="3"><li>AbstractSequentialList<br>AbstractSequentialList是继承自AbstractList的抽象类。正如名字所示，是为了方便顺序访问list<br>集合而创建的抽象类，如LinkedList,对于支持如数组一样随机访问的实现类，应直接继承AbstractList.</li></ol><p>对于继承自AbstractList而来的随机访问方法如get(index),set(index), add(index), remove(index)<br>方法，AbstractSequentialList全部使用迭代器进行了重写，其中具体的迭代器实现是抽象的。<br>同AbstractCollection和AbstractList一样，实现者需要根据不可变或可变list集合实现不同的方法。</p><p>AbstractSequentialList主要子类为LinkedList.</p><p> LinkedList:<br>   Queue: Queue比Collection提供了额外的插入，提取和检查方法。</p><pre><code>队列一般是FIFO，先进先出，但不是必须的，也有例外，如优先队列是根据提供的比较器排列元素，</code></pre><p>或自然排序;栈是先进后出的顺序。无论是用什么顺序存储元素，队列的头都是那个可以调用remove()<br>或者poll()方法删除的元素。先进先出的队列是从队列尾部插入新元素的。 </p><p>   队列操作根据操作错误主要分2类：</p><p>  | 异常情况处理 | 新增 | 删除 | 查看 |<br>  | 抛出异常  | add(e) | remove()| element()|<br>  | 返回特殊值| offer(e)| poll()| peek()|</p><p>offer(e)方法通过返回特殊值来告知调用者新增失败适用于失败是普通的行为，如向一个固定容量的<br>队列中新增元素的情况。add(e)方法只能通过抛出非受查异常来告知失败，只适用于失败是异常情况时。</p><p>remove()和poll()方法都会删除并返回队列的头元素，具体的元素由队列的排序规则而定。当在一个<br>空队列上执行这2个操作时，remove()方法抛出异常，poll()方法返回null值。</p><p>element()和peek()方法会返回当前的队列头元素。</p><p>对于并发编程中常见的阻塞队列的方法是定义在Queue的子接口BlockingQueue中，Queue本身没有定义<br>相关操作。<br>队列的实现一般不允许插入null元素，但也有例外，如LinkedList就没有禁止这样做。但是并不建议<br>这样做，因为poll()方法是通过返回null值来表示当前是空队列的异常情况，插入null元素会与该<br>方法产生冲突。<br>队列实现的equals和hashCode方法并没有基于元素来定义，它只是继承了Object的相关方法，因为根据<br>元素来定义的话，相同的元素组由于不同的排序规则会对这2个方法的实现产生影响。</p><p>实现Queue接口的主要类有AbstractQueue,ConcurrentLinkedQueue, 子接口有BlockingQueue，Deque.</p><pre><code>Deque: double ended queue 双端队列。队列两端都能进行新增删除元素的队列</code></pre><p>大部分Deque实现都没有容量限制，但Deque接口本身也支持固定大小的实现。<br>   |            | Head  || Tail ||<br>   |异常情况处理| 抛异常|返回错误值|抛异常|返回错误值|<br>   |    新增    |  addFirst(e)|offerFirst(e)| addLast(e)|offLast(e)|<br>   |    删除    |  removeFirst()|pollFirst()| removeLast()|pollLast()|<br>   |   查看    |  getFirst() | peekFirst() | getLast() | peekLast() |   </p><p>当Deque被当作Queue使用时，它遵循的是先进先出(FIFO)的原则,从队尾添加元素，队头删除元素。<br>同样分异常情况不同处理方式有等效方法如下表：<br>     |         | Queue方法  |  等效的Deque方法 |<br>     |队尾新增1| add(e) |  addLast(e) |<br>     |队尾新增2| offer(e)| offerlast(e) |<br>     |队头删除1| remove() | removeFirst()|<br>     |队头删除2| poll() | pollFirst()|<br>     |队头查看1| element() | getFirst()|<br>     |队头查看2| peek() | peekFirst()|</p><p>另一方面Deque也可以被用作后进先出(LIFO)的栈使用(优于遗留类Stack).这时候，元素是在deque<br>的头部进行入栈和出栈操作的。以下是栈操作的等效方法：<br>    |     | Stack方法 | 等效Deque方法 |<br>    | 入栈| push(e) | addFirst(e)   |<br>    | 出栈| pop()   | removeFirst() |<br>    | 查看| peek()  | peekFirst() |</p><p>不过，Deque接口中同样提供了push(e),pop()方法，它们就是直接调用addFirst(e),removeFirst()。<br>将Deque用作栈时，使用这2个方法具有更强的可读性。</p><p>Deque接口还提供了2个方法用于删除内部的元素: removeFirstOccurrence(object)和<br>removeLastOccurrence(object).Deque继承自Queue接口，没有随机访问的方法。<br>同Queue接口保持一致，Deque实现也不应该插入null元素，equals和hashCode方法也是直接继承自<br>Object类。</p><p>Deque也继承了总接口Collection的方法，如remove(object):实现为调用removeFirstOccurrence(obj),<br>contains(obj), size()方法。提供了迭代器iterator(): 遍历顺序为从队列头到队列尾;<br>descendingIterator():遍历顺序与iterator()相反，从队列尾到队列头。</p><p>Deque接口的主要实现类为LinkedList, ArrayDeque, ConcurrentLinkedDeque,子接口为BlockingDeque.</p><p>LinkedList:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;,Deque&lt;E&gt;,</span><br><span class="line">   Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure></p><p>LinkedList是双向链表，同时实现了List和Deque接口，这意味着它同时支持随机访问方法和双端队列<br>相关的操作。从get(index)方法的实现看，它会将参数index同中间索引进行比较，index较小时从<br>头开始遍历链表，index较大时从尾开始遍历。</p><p>同ArrayList一样，LinkedList一样也是线程不安全的，也一样可以使用以下方法进行包装:<br><code>List list = Collections.synchronizedList(new LinkedList(...));</code></p><p>LinkedList返回的迭代器同ArrayList的迭代器机制相同，同样是快速失败机制但并不确保必定发生。<br>不同的是ArrayList定义了2个迭代器Itr和ListItr, LinkedList(重写了AbstractList中的2个迭代器)，<br>LinkedList定义了一个ListItr和一个倒序遍历迭代器DescendingIterator.</p><p>总之，LinkedList是链表结构，使用它的随机访问方法如get(index)效率较低，应使用迭代器进行遍历<br>处理。随机访问方法的效率应查看是否实现了RandomAccess接口。</p><h4 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet:"></a>AbstractSet:</h4><p>AbstractSet继承自AbstractCollection类，同时实现了Set接口。<br>AbstractSet没有重写AbstractCollection的任何方法实现，它只是增加了equals(object),<br>hashCode(), removeAll(collection)方法的实现。</p><p>   Set接口:<br>Set接口是Collection接口的三大接口之一(前面已经总结了List和Queue).<br>Set集合即为不含重复元素的集合。确切的说，Set集合不包含这样一对元素e1,e2,其中<br>e1.equals(e2) = true, 并且Set集合最多只能包含一个null元素。在数学上，<br>a set is a collection of distinct objects.</p><p>Set接口的主要实现类有AbstractSet(HashSet(LinkedHashSet)),子接口有SortedSet.</p><p>   SortedSet:</p><p>SortedSet是一个给元素提供了排序规则的set集合。元素可以使用自带的Comparable接口进行排序或<br>是创建sortedSet时提供的Comparator接口。这也意味着sortedSet集合中的元素必须要实现Comparable<br>接口或是可以使用指定的Comparator接口进行排序，同时，元素之间需要能够进行双向比较，即<br>进行比较时不应抛出类型转换异常。</p><p>同时，sortedSet使用的排序规则应当与equals方法保持一致，即a.compareTo(b) == 0时\<br>a.equals(b) == true.这时因为set集合的操作都是建立在equals方法的基础上的(前面说的无重复元素<br>定义)，但sortedSet进行比较时使用的是compareTo或compare方法，sortedSet只有在这两个方法返回<br>0时才认为比较对象相同，所以如果equals和排序方法不保持一致，可能会产生意想不到的错误, 如<br>Comparable类注释中给出的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.equals(b) == false &amp;&amp; a.compareTo(b) == 0</span><br><span class="line">sortedSet.add(a); </span><br><span class="line">sortedSet.add(b);</span><br></pre></td></tr></table></figure></p><p>添加元素b时会返回false并且sortedSet集合大小不变，因为在sortedSet看来，a与b是相同的元素。</p><p>SortedSet建议实现类应当提供4个构造器：</p><ol><li>无参构造器: 元素按自然排序排列</li><li>有一个Comparator参数的构造器: 元素按指定的Comparator接口排列</li><li>有一个Collection类型参数的构造器: 使用参数Collection中全部元素构造一个新SortedSet,按<br>元素的自然排序规则排序。</li><li>有一个SortedSet类型参数的构造器: 使用与参数sortedSet中相同的元素和相同的排列规则建立<br>一个新的sortedSet.</li></ol><p>值得注意的是, SortedSet有些方法是返回有区间限定的子set集合，子集元素的边界默认是半开区间，<br>即包含低边界，不包含高边界(包头不包尾).如果想得到全闭边界的子集，可以将高边界向后推进一个<br>元素。如以下例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt;String&gt; sub = s.subSet(low, high+&quot;\0&quot;);</span><br></pre></td></tr></table></figure></p><p>同理可以得到全开边界区间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortdSet&lt;String&gt; sub = s.subSet(low + &quot;\0&quot;, high);</span><br></pre></td></tr></table></figure></p><p>SortedSet接口比Set接口主要新增了以下几个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Comparator&lt;? super E&gt; comparator();</span><br><span class="line">2. SortedSet&lt;E&gt; headSet(E toElement);</span><br><span class="line">3. SortedSet&lt;E&gt; tailSet(E fromElement);</span><br><span class="line">4. E first();</span><br><span class="line">5. E last();</span><br></pre></td></tr></table></figure></p><p>SortedSet的主要子接口为NavigableSet.</p><p>  NavigableSet:<br>NavigableSet比SortedSet多定义了一些方法，如返回集合中离被搜索元素最近的元素方法:<br>lower: 返回小于参数的元素，floor: 返回小于或等于参数的元素，ceiling:大于等于，<br>higher: 大于。NavigableSet集合支持升序遍历和倒序遍历，需要注意的是descendingSet方法<br>并没有新键一个set集合，它是在原集合的基础上进行处理的，如果改变其中的一个集合，另一个<br>集合也会受到影响(可以查看TreeSet的该方法实现，使用了navigableMap.descendingMap())。</p><p>Navigable接口还增加了pollFirst(),pollLast()用于删除第一个或最后一个元素(如pollFirst在升序<br>排列时删除最小值，倒序排列时删除最大值)。</p><p>不同于父类SortedSet中的subSet,headSet,tailSet方法，NavigableSet中的这些方法添加了是否包含<br>边界的参数，可以使调用者更方便的控制。<br>因为SortedSet集合需要元素间进行比较，所以不建议在其中插入null元素。</p><p>NavigableSet接口的主要实现类有TreeSet, ConcurrentSkipListSet.</p><p>AbstractSet的主要子类有HashSet, TreeSet, EnumSet.</p><pre><code>1. HashSet</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, </span><br><span class="line">   java.io.Serializable</span><br></pre></td></tr></table></figure><p>从代码实现看，HashSet是用HashMap实现的，为了保证元素的唯一性，HashSet里的元素被当作<br>HashMap的键，值是一个简单的Object对象PRESENT = new Object().HashSet的add方法实现即为<br><code>map.put(e, PRESENT) == null;</code>,remove方法实现为<code>map.remove(e) == null;</code>其中put和remove方法<br>返回的是value值。HashSet的迭代器实现为<code>map.keySet().iterator()</code>.</p><p>由HashMap实现的HashSet无法保证集合的元素遍历顺序，同时HashSet允许null元素(HashMap允许null<br>键),因为键的唯一性，null元素同其他元素一样，也只能有一个。<br>遍历HashSet集合的时间与HashSet元素数量加上内部实现HashMap的容量大小之和成正比。因为元素<br>之间无联系(散列算法放入)，需要遍历整个空间。<br>HashSet是线程不安全的，同ArrayList,LinkedList一样，可以使用如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(new HashSet(...));</span><br></pre></td></tr></table></figure></p><p>HashSet的迭代器也是快速失败的。</p><p>HashSet有一个子类LinkedHashSet.</p><p>   LinkedHashSet:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, </span><br><span class="line">   java.io.Serializable</span><br></pre></td></tr></table></figure></p><p>查看LinkedHashSet的实现可知，它调用了定义在HashSet中的重载构造器(使用bool值dummy区分)，<br>在其中使用LinkedHashMap而不是HashMap实现Set集合，其他方法都使用默认的HashSet实现，没有进行<br>重写。<br>同LinkedHashMap一致，LinkedHashSet维护了一个双向链表来记录元素的插入顺序(重复插入相同元素<br>不会改变它的次序),可以使用它来记录参数set集合的元素顺序(底层是LinkedHashMap比HashMap在键上<br>新增了一个双向链表来记录键的插入顺序)，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo(Set s) &#123;</span><br><span class="line">  Set copy = new LinkedHashSet(s);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于维护了一个双向链表，LinkedHashSet效率比HashSet低一些，但遍历集合时，由于链表的存在，<br>它的时间是与元素个数成正比的，而HashSet(HashMap实现)它是与集合的容量成正比的。 </p><p>这样看来，当修改较少，遍历查询较多时，应使用LinkedHashMap或LinkedHashSet，而不是HashMap或<br>HashSet.<br>同HashSet一样，LinkedHashSet也是线程不安全的，可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(new LinkedHashSet(...));</span><br></pre></td></tr></table></figure></p><ol start="2"><li>TreeSet<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable,</span><br><span class="line">   java.io.Serializable</span><br></pre></td></tr></table></figure></li></ol><p>同HashSet类似，TreeSet底层也是使用了TreeMap实现的，TreeMap是NavigableMap接口的红黑树实现，<br>而NavigableMap继承自SortedMap,SortedMap继承自Map接口，它们之间的关系和Set,SortedSet,<br>NavigableSet的关系基本相同，都是sortedXXX新增了可排序功能，NavigableXXX进一步扩展:返回目标<br>附近元素，提供倒序遍历，优化获取子集合边界控制的方法。</p><p>同HashSet一样，TreeSet的add方法即<code>m.put(e, PRESENT) == null;</code>,remove为<br><code>m.remove(o) == PRESENT;</code>,NavigableSet的first方法为<code>m.firstKey();</code>,last方法为<code>m.lastKey();</code>,<br>其他也都是类似的调用TreeMap中相应的方法。<br>TreeSet也是线程不安全的。</p><ol start="3"><li>EnumSet<br>枚举可以看作不可变的常量对象，当这些枚举对象需要批量处理时可以使用EnumSet。它有2个实现，<br>如果枚举值个数超过64个，使用JumboEnumSet实现类，如果小于等于64个，使用RegularEnumSet实现。<br>查看它们的实现可知，由于枚举的常量特性，RegularEnumSet使用一个long数值作为整个set集合的<br>容器，add,remove,get操作都是对该长整型数值的位操作(其中size方法是使用Long.bigCount()方法<br>来统计1的个数实现的)。同理，JumboEnumSet是使用一个long[]数组作为容器进行存储。</li></ol><p>EnumSet使用noneOf(Class elementType)方法创建一个空的枚举集，方法中根据枚举值个数判断选择<br>是JumboEnumSet还是RegularEnumSet实现;使用allOf(Class elementType)创建一个包含了所有枚举值<br>的枚举集，还可以使用of方法对1到5个枚举值快速创建枚举集。</p><p>EnumSet集合中的所有元素都必须显式或隐式的来自同一个枚举类型.EnumSet是用位向量(bit vectors)<br>表示的。它返回的迭代器永远不会抛出ConcurrentModificationException(对位进行操作),无法得知<br>遍历过程中修改集合的影响。EnumSet不允许插入null元素，会抛出空指针异常。</p><p>EnumSet同样是线程不安全的，可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;MyEnum&gt; s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));</span><br></pre></td></tr></table></figure></p><p>由于EnumSet是由位操作实现的，所以所有的集合基础操作都是常数时间内完成，比HashSet高效很多。<br>如果批量操作方法的参数也是EnumSet,它也是常数时间完成。由此可知，如果元素集合可以被定义为<br>枚举类型，使用EnumSet进行处理是非常高效的。</p><h4 id="AbstractQueue"><a href="#AbstractQueue" class="headerlink" title="AbstractQueue:"></a>AbstractQueue:</h4><p>AbstractQueue继承AbstractCollection类，实现了Queue接口。<br>从代码可以看出，AbstractQueue使用Queue接口的方法如offer,poll,peek实现了集合的基础操作如<br>add,remove,element,addAll方法，如果操作失败抛出相应的异常。clear()方法则是死循环出队操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(poll()!=null);</span><br></pre></td></tr></table></figure></p><p>像前面说的Queue接口一样，AbstractQueue的子类应实现一个不允许插入null元素的offer方法(因null<br>被当作特殊返回值),peek,poll,size,iterator方法。</p><p>AbstractQueue的主要子类有PriorityQueue,并发包下的ArrayBlockingQueue, LinkedTransferQueue,<br>SynchronousQueue,LinkedBlockingDeque, DelayQueue, LinkedBlockingQueue, ConcurrentLinkedQueue,<br>PriorityBlockingQueue.从这也可以看出，并发编程大量使用到了队列。</p><p>PriorityQueue:<br>二叉堆实现的优先队列。<br>现实生活中有时候我们需要在一堆元素中选出最大或最小值，然后插入一些新元素，再在其中选出最值，<br>或者是输入集合过于巨大，无法进行存储或存储后排序过于缓慢，这些场景都可以使用优先队列来解决。</p><p>使用场景:<br>比如输入N个字符串，每个字符串都有一个整数作为键，需要找出输入流中键最小的M个字符串。<br>(字符串的比较对象是一个整数，我们可以通过该索引来引用优先队列中的元素并进行操作，<br>这实际是索引优先队列的一个使用场景)</p><p>解决方案:<br>这里的整数索引即为对应字符串的优先级，我们可以将每个字符串存入优先队列中，并检查优先<br>队列中的元素是否超出M,如果超出则删除其中优先级最低(整数最大)的字符串。通过这种方式优先队列<br>中始终存储的都是优先级最高的M个字符串。</p><p>这就是优先队列的常见用法，使用者只需要执行入队和出队操作，并控制队列的大小，即可以得到需要<br>的元素集合，并且整个过程是动态的，支持无限输入。</p><p>那么优先队列是如何新增元素并确保每次出队操作都是优先级最低(值最小)的元素呢？可以使用<br>普通数组或链表实现:</p><ol><li>正常插入元素，删除时再找出最大的元素，最差时需要线性时间，即每个元素都比较了一遍。</li><li>每次插入后都保持有序，较小元素都向后移动，保证第一个元素是最大值，删除时直接删除它即可。<br>同样，插入时最差也是线性时间，插入的是最小值，每个元素都被移动了。<br>优先队列实际使用的是一种叫二叉堆的数据结构，它可以保证插入和删除都是对数时间，最多只需要<br>处理一半的元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二叉堆定义: 二叉堆中的每个顶点都大于或等于它的两个子节点。二叉堆的根节点即为最大值。</span><br></pre></td></tr></table></figure><p>二叉堆可以定义到数组a[]中，a[k]的子节点为a[2k]与a[2k+1].</p><p>当每次插入新的元素时，需要进行重新排列使得数组保持堆有序，这个过程叫堆的有序化(reheapifying).<br>具体为上浮或下沉，元素与父节点或子节点进行比较后决定是否需要互换位置。</p><p>PriorityQueue同样使用数组存储堆，默认升序排列，即队列头queue[0]存储的是最小值，这样执行<br>出队poll()操作后，删除的是最小值，队列中保存的是较大者的集合，即PriorityQueue是MaxQueue,<br>这一点在实际使用中应当注意。</p><p>与SortedSet相同，优先队列中的元素需要根据其自身进行排序(实现Comparable接口)或指定<br>Comparator比较器，所以优先队列不允许插入无法比较的元素或null元素。如果有多个相等的最小值，<br>优先队列会任选一个作队列头，方法poll,remove,peek,element处理的都是队列头的元素。<br>优先队列本身同ArrayList一样，内部实现的数组会自动进行扩容，同样是grow方法，当数组大小小于<br>64时扩大一倍，超过64时扩容原大小的一半。</p><p>PriorityQueue也提供了迭代器iterator,但同ArrayList或TreeSet不同的是，在遍历过程中调用迭代器<br>的remove方法进行删除时，实际调用的是PriorityQueue.this.removeAt(index)方法，其中同样会进行<br>堆的有序化操作，从而对剩余元素的顺序产生影响(实际上为了全部遍历到，迭代器中特意定义<br>了一个ArrayDeque来存储被影响到的元素)，所以无法保证元素的遍历顺序。若想要固定的遍历顺序，<br>可以使用<code>Arrays.sort(queue.toArray());</code>.</p><p>PriorityQueue与ArrayList,LinkedList, HashSet, TreeSet一样是线程不安全的，若需要线程安全可以<br>使用PriorityBlockingQueue.由于底层的数组实现和二叉堆的数据结构，add(e),offer(e),poll(),<br>remove()方法都是O(logN)时间，remove(object),contains(object)是线性时间，peek(),element(),<br>size()是常量时间。</p><p>从实现看，PriorityQueue的初始默认大小是11,定义了多个构造器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 无参构造器: 使用默认大小，自身Comparable比较</span><br><span class="line">2. 一个指定初始大小参数的构造器: 自身Comparable比较</span><br><span class="line">3. 一个指定比较器Comparator参数的构造器: 使用默认大小</span><br><span class="line">4. 同时指定初始大小和Comparator</span><br><span class="line">5. 一个Collection集合参数的构造器: 如果参数是PriorityQueue类型，可以直接使用queue.toArray()</span><br><span class="line">  方法快速新建对象，否则需要拷贝数组后进行堆有序化操作。</span><br></pre></td></tr></table></figure></p><p>从offer(e)方法的实现可以看出，新增元素时需要执行上浮操作SiftUp(size,e),将新元素从队尾<br>开始循环与父节点比较直到新元素大于或等于父节点。</p><p>remove(object)实际调用的是removeAt(index)方法，如果删除的是队尾元素，则直接删除并返回null<br>不影响堆有序，否则将队尾元素先删除后再将其值插入到要删除的位置上，执行下沉操作，如果其位置<br>没变动，再执行上浮操作，以这种方式来保证堆有序(像这种执行上浮操作并位置确实变动的元素在<br>迭代器中刚好”逃过”了待遍历部分，removeAt(index)方法会直接返回该元素，迭代器的remove方法会<br>根据removeAt返回值是否为null来判断是否需要加入特殊ArrayDeque队列forgetMeNot中)。</p><p>heapify()方法保证了整个数组的堆有序，它从个数大小的一半开始倒序遍历直到为0，对每个元素<br>执行下沉操作。将被操作元素沿树向下比较，直到该元素小于或等于子节点。<br>在从Collection集合参数的构造器中有使用到heapify()方法，复制数组后调用它使得堆有序。</p><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;, Cloneable,</span><br><span class="line">   Serializable</span><br></pre></td></tr></table></figure><p>使用动态循环数组的Deque接口实现类。数组默认初始大小为8, 数组容量用完时(head == tail)固定<br>是扩大一倍现有容量。 </p><p>ArrayDeque也是线程不安全的，不允许插入null元素(Queue统一限制),被当作栈使用时比Stack类快，<br>当作队列使用时比LinkedList快。<br>ArrayDeque的迭代器同样基于快速失败机制，但不保证一定会抛异常。</p><p>总之，ArrayDeque应是最常用的普通栈和队列(无线程安全要求)的实现类，push(e),pop(),offer(e),<br>poll()方法也非常明确简洁，无需关心具体实现。同样，初始化时指定大小可以减少扩容次数。</p><h4 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="AbstractMap"></a>AbstractMap</h4><p>HashSet基于HashMap,TreeSet基于TreeMap,可知Map是比Set更通用的存在。</p><p>   <code>Map&lt;K,V&gt;</code>接口:<br>Map接口定义了键集合映射到值集合的关系，键不能重复，每个键最多只能映射一个值。<br>Map接口提供了3种集合视图展示Map集合中的内容，a set of keys(keySet()),<br>a collection of values(values()), a set of key-value mappings(entrySet()).<br>Map集合中元素的顺序取决于迭代器遍历元素的顺序，如TreeMap是有序的，HashMap是无序的。</p><p>当使用可变对象作为键时，如果该对象发生了改变，改变了它的equals相等性，那么它对Map集合<br>产生的影响是无法确定的。</p><p>所有Map接口的实现类应当提供2个构造器，一个无参构造器，一个以单个Map集合为参数的构造器。<br>可以利用后者复制任意一个Map集合。一些Map实现对键或值的类型有限制，插入不相符的类型可能会<br>报空指针异常或类型转换异常，查询一个不相符的键或值可能抛异常，或者仅仅返回false，这取决于<br>具体的实现。</p><p>Map接口定义了很多对Map集合的通用操作方法，如boolean containsKey(key),<br>boolean containsValue(value), Value get(key)。键集合视图<code>Set&lt;K&gt; keySet()</code>, 值集合视图<br><code>Collection&lt;V&gt; values()</code>, 键值对集合<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>.</p><p>最后一个视图是在Map接口中定义了一个内部接口<code>Entry&lt;K,V&gt;</code>, entrySet方法返回的set集合元素<br>即为该Entry类型，Map.Entry对象在整个遍历过程中都可以被有效访问。从另一方面来说，<br>如果在迭代器返回Map.Entry对象后修改了Map集合，Map.Entry的行为无法被确定，除非使用<br>Map.Entry的setValue()方法，这一点同其他集合的迭代器调用自身的remove()方法才可以正常删除<br>是一样的道理。</p><p>Entry接口本身代表了一对键值对，它定义了很多操作该键值对的方法，如K getKey(), V getValue(),<br>V setValue(V), 同时定义了很多利用λ表达式实现的Comparator比较器，如comparingByKey(),<br>comparingByValue(), comparingByKey(keyComparator), comparingByValue(valueComparator),<br>默认方法getOrDefault(key, defaultValue), replaceAll(BiFunction), putIfAbsent(K,V),<br>remove(K,V), replace(key, oldValue, newValue), replace(key, value),<br>computeIfAbsent(key, function), computeIfPresent(key, BiFunction), compute(key, BiFunction),<br>merge(key, value, BiFunction).</p><p>Map接口的主要实现类有AbstractMap(HashMap(LinkedHashMap), WeakHashMap, IdentityHashMap等),<br>HashTable 主要子接口有CocurrentMap, SortedMap.</p><p>AbstractMap:<br>  AbstractMap为Map接口的部分方法提供了实现，如containsValue(v), containsKey(k), get(k),<br>remove(key), keySet()(定义AbstractSet的匿名内部类，复用EntrySet的迭代器)，values()<br>(实现方法类似keySet()).entrySet()方法为抽象方法，equals(object), hashCode(), toString()<br>方法。同时它提供了<code>SimpleEntry&lt;K,V&gt;</code>内部静态类实现Map.Entry接口，该类支持setValue(V)<br>方法修改map集合，类似的还有<code>SimpleImmutableEntry&lt;K,V&gt;</code>, 它没有setValue(V)方法，适合于<br>返回线程安全的map集合元素快照。</p><p>如果想实现一个不可变的Map集合，用户只需要继承AbstractMap类并实现entrySet()方法，通常它与<br>keySet()方法一样是基于AbstractSet类，由于它的不可变性，该Set集合不应当实现add(e), remove(obj)<br>方法，迭代器也不应实现remove()方法。(因为各个Map.Entry的具体实现类不同，所以entrySet()方法<br>只能写为抽象方法)</p><p>反之，如果需要实现一个可变的Map集合，用户需要重写put方法，并且entrySet().iterator必须实现<br>remove()方法。</p><p>AbstractMap的主要子类有HashMap, TreeMap, WeakHashMap, IdentityHashMap, EnumMap,<br>ConcurrentHashMap. </p><ol><li>HashMap<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K, V&gt; implements Map&lt;K,V&gt;, Cloneable, </span><br><span class="line">   Serializable</span><br></pre></td></tr></table></figure></li></ol><p>用哈希表实现的Map接口，基本等同于HashTable, 只不过HashMap是线程不安全的，并且HashMap允许<br>null键和null值。在散列函数可以恰当散列元素到每个桶的情况下，基本操作如get和put方法的性能<br>是常量时间。HashMap中的元素遍历顺序是随机的。遍历HashMap的时间与以下两者之和成正比:<br>hashMap的容量(桶的个数)与hashMap的元素个数。所以不应将HashMap的初始容量设置的太高, 或者<br>是加载因子设置的太低。</p><p>一个hashMap对象的性能主要受2个参数影响: 初始容量和加载因子。初始容量即为哈希表在创建时<br>哈希表中桶的个数，加载因子为哈希表中元素数量达到一定程度时才允许它自动扩容的比例大小。<br>当HashMap中的元素数量超过加载因子和现有容量的乘积时，HashMap会重新”哈希化”(rehash),过后<br>桶的数量会变为之前的两倍。</p><p>默认的加载因子0.75是在时间和空间消耗之间的平衡比例，高于0.75虽然提高了空间利用率，但是增加<br>了查询的时间消耗，包括get和put方法。低于0.75会浪费空间，所以在设置初始容量大小时应同时考虑<br>预计的元素个数和加载因子的大小。实际上如果初始容量大小大于最大的预计个数除以加载因子的得到<br>的值，就不会发生重新哈希化，不需要扩容。但如果容量太大可能查询较慢，同时遍历时间也长，还是<br>要看具体的性能要求。</p><p>使用一个足够大的hashMap来存储大量元素要比使用hashMap的动态扩容机制来存储效率高。使用相同<br>哈希值的元素作为键必定会降低HashMap的性能，HashMap使用CompareTo方法(假设不等)在重新哈希化<br>时打破相等性，如果CompareTo方法也相等，则使用System.identityHashCode()进行比较。具体可见<br>HashMap.TreeNode的TieBreakOrder方法实现。</p><p>HashMap也是线程不安全的，同样可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = Collections.synchronizedMap(new HashMap(...));</span><br></pre></td></tr></table></figure></p><p>HashMap的三个视图keySet(),values(), entrySet()中的迭代器都是快速失败的，同样不保证抛出异常。</p><p>当哈希表中桶过大时，HashMap会将桶的实现由list转换为树，如果元素变小，它又会转换回来<br>(像之前说的一样，它使用ComparaTo方法和identityHashCode值来区分HashCode值相同的树节点)。<br>HashMap定义了一个实例域<code>TREEIFY_THRESHOLD = 8</code>, 意味着一个桶中的元素超过8个时，HashMap<br>就会开始树化。同理反转化有实例域<code>UNTREEIFY_THRESHOLD = 6</code>,少于6个时开始反转。还定义了<br>实例域<code>MIN_TREEIFY_CAPACITY = 64</code>,意味者如果HashMap的容量小于64时，如果这时一个桶过大，<br>它并不会树化，而会对HashMap实现扩容操作。</p><p>HashMap定义了<code>Node&lt;K,V&gt;</code>类实现Map.Entry接口，一个Node类实例就是一个键值对，Node有实例域<br>hash(key的hash值)，key(键), value(值)， next(相同hash值链表中的下一个Node节点)，Node类<br>实现了Entry接口的setValue(v), equals(object), hashCode()等方法。</p><p>HashMap最常用的get(key)是根据给定值查找对应的键，它返回null值代表两种情况，可能该键不存在，<br>也可能该键对应的值就是null值。所以get(key)方法通常是和contains(key)方法一起使用，以区分这<br>两种情况。<br>HashMap的存储容器其实是<code>Node&lt;K,V&gt;[]</code>数组，get(key)方法通过计算hash值定位到数组中某个索引的<br>位置(first = tab[(n -1) &amp; hash]),再通过比较键来解决”哈希碰撞”(不同键产生相同哈希值)的问题<br>(<code>e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))</code>)</p><p>get(key)实际调用的是getNode(hash, key)方法，它返回的是一个Node节点，<br>containsKey(key)方法也是通过getNode(hash, key)方法的返回对象是否为空来判断是否存在该键<br>对应的节点，从而判断出HashMap是否包含该键。</p><p>V put(key, value)方法将新的键值对节点追加到key对应的hash值链表中，方法的返回值是该键对应的<br>旧值，如果为null的话，像get(key)方法一样，可能是原来不存在这个键或原来映射的值就是null.<br>查看put方法的实现注意到，找到对应链表的最后一个节点并替换值以后或是新增一个节点以后，<br>它会调用afterNodeAccess()方法或AfterNodeInsertion方法，注释说是要回调LinkedHashMap的后<br>处理，这样做的原因待后续补充…(ToDo)</p><p>关于resize()方法的实现，网上搜索到jdk8以前扩容时需要根据<code>e.hash &amp; (oldCap - 1)</code>重新计算<br>hash值，比较耗费性能，jdk8时改为根据<code>e.hash &amp; oldCap == 0</code>判断是否需要移位。相当于原数组相同<br>索引的链条的后半部分被移动到扩增的数组部分了，前半部分保持原位不动。</p><p>HashMap中为树化定义了一个内部类TreeNode, 它继承自<code>LinkedHashMap.Entry&lt;K, V&gt;</code>,查看定义可知<br>后者是在继承HashMap.Node类的基础上新增了before, after的Node指针(即双向链表)。<br>而这个TreeNode中即是定义了红黑树的相关实例域和方法。</p><p>HashMap说到底还是一种符号表的实现，在《算法》第4版的第3章查找一章中对符号表的api, 使用场景<br>进行了详细的说明，尤其是红黑树的讲解是公认非常棒的。</p><p>以下为该书中相关知识的笔记:<br>符号表性能要求就是大量查询操作和一般插入的高效性，即对get和put方法的性能要求。</p><ol><li><p>最简单的实现: 无序单向列表<br>使用一长串无序单向链表来存储整个符号表，每次查询都从头节点开始查询，直到找到目标节点为止，<br>找到时修改目标节点的值为新值;若未查找到目标，则将该键值对作为新节点追加到链表的头部。<br>最差的情况是插入的键都是不同的，这时每次查找都需要比较全部的元素，总比较次数为n ^ 2 / 2。</p></li><li><p>使用一个有序数组存储键，另一个数组相应位置存储对应值的方式存储整个符号表。由于数组的<br>有序性，可以使用二分查找法来实现对数级别的查找效率，但是进行插入时需要将比新键大的元素<br>统一向后移动一格以空出位置插入新元素。这样虽然查询很快，但插入操作效率太低: 因为查询时<br>元素的比较次数是对数级别，而put方法移动时最糟糕时是全部N个元素移动，一共有2个数组，所以<br>数组的访问次数是2N，N个元素进行插入时就是<code>N^2</code>级别。</p></li><li><p>使用二叉查找树存储符号表。二叉查找树结合了链表新增节点的灵活性和有序数组的查找高效性，<br>是集成了链表和数组两者优点的数据结构。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二叉查找树(BST): 每个节点都含有一个Comparable的键(以及值), 每个根节点的键都大于左子树的</span><br><span class="line">任意节点键，同时小于右子树的任意节点键。</span><br></pre></td></tr></table></figure><p>即从左到右将每个节点的键映射到水平轴上可以得到一个从小到大的升序序列。<br>二叉查找树独特的结构使得(在树平衡的情况下)查找和插入都是对数级别，极大的提高了操作效率。</p><p>二叉查找树查询代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public V get(K key) &#123;</span><br><span class="line">  if (key == null) throw new NullPointerException(&quot;null key&quot;);</span><br><span class="line">  return get(root, key);</span><br><span class="line">&#125;</span><br><span class="line">public Node get(Node x, K key) &#123;</span><br><span class="line">  if (x == null) return null;</span><br><span class="line">  int cmp = key.compareTo(x.key);</span><br><span class="line">  if     (cmp &lt; 0) return get(x.left, key);</span><br><span class="line">  else if(cmp &gt; 0) return get(x.right, key);</span><br><span class="line">  else             return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二叉查找树最难实现的操作是删除的实现。</p><ol><li>deleteMin()方法实现。删除最小的节点很容易实现， 寻找根节点的左子树，一路向左直到某个<br>节点的左子树为空，则说明该节点为最小节点，返回它的右子树根节点即可。</li><li>delete()方法删除任意一个节点。因为一个节点只有一个被指向的链接，但它有左子树和右子树<br>2个节点子链接，为了保持键的有序性，需要特殊处理。T.Hibbard提出可以使用被删节点的后继节点<br>来作为新的根节点代替被删节点的位置。后继节点为被删节点的右子树中最小的节点，新根节点的左<br>子树保持原有左子树不变，右节点指向删除了该后继节点后的新右子树。</li></ol><p>这种解决方案确实保持了二叉树的有序性，但实际上也可以使用前继节点，即没有考虑删除后二叉树<br>的高度，多次删除后树的性能降低，所以应随机使用前继或后继节点作为新节点。<br>可以按键升序遍历整棵二叉查找树，即中序遍历： 先打印左子树的所有节点，再打印根节点，<br>最后打印右子树的所有节点。</p><p>为了提高性能，不管用户输入的键顺序如何，保证新增和查找都是对数级别，需要使用平衡二叉树。<br>(完美平衡即根节点到任意一个空节点的距离都是相等的，都是树的高度)</p><p>为了整体降低树的高度，平衡二叉树引入了3-节点，即它有2个键，3条链接。其中2个键将整个键的取值<br>范围分为3个区间，同样从左到右递增。<br>2-节点插入一个新键时可以变为3-节点，3-节点插入一个新键时可以临时变为一个4-节点，单独的一个<br>4-节点(如根节点)可以变为3个2-节点并保持平衡性，树高加1.如果原3-节点有一个2-节点，则将新的<br>4-节点中的中间键向上传递到上面的2-节点中，使之变为一个3-节点，具体是左键还是右键根据原来<br>的节点关系确定。通过这种层层”冒泡”的方式我们一直保持着树节点的有序性和平衡性，而这也为递归<br>处理的同时保持树的平衡性提供了保证。</p><p>红黑树: 它即是二叉查找树，又是上述的2-3节点二叉树。确切的说，其中的3-节点表示为使用一条<br>左斜的红色链接连接两个2-节点，黑色链接即为普通的2-3树链接。<br>由这样的定义出发可以得到红黑树的另一种定义或说是特性:</p><ol><li>红链接都是左链接。</li><li>没有任何一个节点同时与两条红链接相连。</li><li>该树是完美黑色平衡的。(根节点到任意一个空节点上的黑色链接数量是相同的)<br>为了方便表示颜色，在Node类中定义域boolean red = true代表指向该节点的链接为红链接，即一个<br>节点是红色的说明它与父节点之间是红色链接，两者可看作一个3-节点。</li></ol><p>旋转: 在红黑树操作过程中可能会出现红色右链接或一个节点有2个红链接的情况，这时我们可以使用<br>旋转使它变为正常的链接情况。如左旋转即从较小的键作为根节点转变为以较大的键作为根节点，同时<br>这2个节点下的左右子树也进行相应移动的过程。可以将这个旋转的过程动态的想象为节点与红色链接<br>向左平移的过程; 同理，右旋转是节点和红链接右移的过程(或者说拉扯更形象)。</p><p>实际新增时默认新增的节点都是红色的，再根据其是否是右链接，或父节点为2-节点、3-节点的情况<br>进行左旋转，右旋转，变色等处理。</p><p>旋转操作让红黑树这种特殊表示的2-3树能够真正实现上面说明的2-3树插入新节点时”冒泡”的概念过程。<br>如向一个3-节点中插入一个比3-节点中2个键都要大的新节点时，可以得到一棵已经有序的二叉树，它<br>有2条红色链接与中间键相连，此时只需要将2条红链接变为黑链接，最后根节点的颜色由黑变红！！<br>这整个变色的过程(链接和根节点)即实现了上面2-3树的冒泡过程, 同时也可以看到，这个新的红链接<br>一直沿着树在向上传递，直到遇到一个2-节点或根节点为止。</p><p>红黑树的插入在不同的情形下可以由每个节点顺序执行以下判断操作来实现:</p><ol><li>右子节点为红色，左子节点为黑色，则进行左旋转。</li><li>左子节点为红色，左子节点的左子节点也为红色，进行右旋转。</li><li>左右子节点都是红色，进行变色处理(3个节点都变色)。</li></ol><p>由红黑树的put方法实现可以看出，前面与普通二叉查找树一样从根节点开始比较，小于它就递归调用<br>左子树根节点，大于它就递归调用右子树根节点，相等就是命中查找。这是一个从上到下的查找过程，<br>而2-3树新增节点是从下往上冒泡的过程，所以我们需要在递归调用的代码结束后进行旋转变色处理，<br>即递归方法的出栈过程是逆序过程，符合了从下往上冒泡的要求。</p><p>红黑树put方法实现代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public void put(K key, V val) &#123;</span><br><span class="line">  if (key == null) throw new NullPointerException(&quot;null key&quot;);</span><br><span class="line">  if(val == null) &#123;</span><br><span class="line">    delete(key);  </span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  root = put(root, key, val);</span><br><span class="line">  root.color = BLACK;  // 在变换最后根节点需要手动变为黑色</span><br><span class="line">&#125;</span><br><span class="line">private Node put(Node h, K key, V val) &#123;</span><br><span class="line">  if (h == null) return new Node(key, val, RED, 1); // new node color is red, and size = 1 </span><br><span class="line"></span><br><span class="line">  // 向下查找</span><br><span class="line">  int cmp  = key.compareTo(h.key);</span><br><span class="line">  if     (cmp &lt; 0)  put(h.left, key, val);</span><br><span class="line">  else if(cmp &gt; 0)  put(h.right, key, val);</span><br><span class="line">  else              h.val = val;</span><br><span class="line"></span><br><span class="line">  // 向上变幻</span><br><span class="line">  // 旋转变色使红黑树保持其特性</span><br><span class="line">  if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h);</span><br><span class="line">  if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);</span><br><span class="line">  if (isRed(h.left) &amp;&amp; isRed(h.right))  flipColors(h);</span><br><span class="line">  h.size = size(h.left) + size(h.right) + 1;  // 别忘了加1</span><br><span class="line"></span><br><span class="line">  return h;</span><br><span class="line">&#125;</span><br><span class="line">private Node rotateLeft(Node h) &#123;</span><br><span class="line">  Node x = h.right;</span><br><span class="line">  h.right = x.left;</span><br><span class="line">  x.left = h;</span><br><span class="line">  x.color = h.color;</span><br><span class="line">  h.color = RED;</span><br><span class="line">  x.size = h.size;</span><br><span class="line">  h.size = size(h.left) + size(h.right) + 1;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">private Node rotateRight(Node h)&#123;...&#125; // 相反即可</span><br><span class="line">private void flipColors(Node h) &#123;</span><br><span class="line">  h.color = !h.color;  </span><br><span class="line">  h.left.color = !h.color;</span><br><span class="line">  h.right.color = !h.right.color;</span><br><span class="line">&#125;</span><br><span class="line">private int size(Node x) &#123;</span><br><span class="line">  if(x == null) return 0; </span><br><span class="line">  return x.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>红黑树的5大性质(根据这些性质可以排除某些删除节点的情形是不可能发生的，如一个黑节点只有黑<br>左子树或只有黑右子树，一个红节点有一个黑左子树或一个黑右子树的情况，它们都违反了性质5的高度)</p><ol><li>节点为红或黑</li><li>根节点是黑色的</li><li>每个叶节点(null节点)是黑色的</li><li>每个红节点的2个子节点都是黑色的(不能有2条红链接链接到同一个节点)</li><li>从任一个节点向下到每个叶子的路径包含的黑色节点数目相同，即黑色树高是相同的。</li></ol><p>删除算法: </p><p>先考虑删除最小键的问题:<br>2-3树中3-节点可以删除一个节点，没有影响，但2-节点删除一个节点后会形成一个空节点，<br>这时相当于在某条路径上减少了一个黑节点的高度，破坏了树的平衡性。这时我们可以将后者转化为<br>前面一种情况来解决。 </p><p>删除时检查是否为以下情况之一:</p><ol><li>如果当前节点的左子节点不是2-节点，结束。</li><li>如果当前节点的左子节点是2-节点而左子节点的亲兄弟节点不是2-节点，从兄弟节点中移动(借)一个节点到<br>左子节点中，结束。</li><li>如果当前节点的左子节点和右子节点都是2-节点，就将左子节点，父节点最小键和左子节点最近<br>的兄弟节点合并为一个4-节点替换当前节点，父节点减少一个键，结束。</li></ol><p>从以上3种情况中任意一种结束都能得到一个包含最小键的3-或4-节点，直接删除该最小键即可。然后再<br>回头向上分解生成的临时4-节点(第3布产生的)。</p><p>以上是删除最小键，如果删除树中任意一个节点，同二叉树的处理类似，可以使用被删节点的后继节点<br>替代被删节点，然后新节点的右子树指向删除了后继节点后的新树(删除最小键)。删除后同样需要向上<br>分解临时的4-节点。</p><p>红黑树删除最小键具体代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void deleteMin() &#123;</span><br><span class="line">  if(isEmpty()) throw new NoSuchElementException(&quot;BST underflow&quot;); </span><br><span class="line">  // 左右子树都是黑的，将根节点变为红色，相当于根节点与左右子节点一起变为一个4-节点</span><br><span class="line">  if(!isRed(root.left) &amp;&amp; !isRed(root.right)) &#123;</span><br><span class="line">    root.color = RED;</span><br><span class="line">  &#125;</span><br><span class="line">  root = deleteMin(root);</span><br><span class="line">  if (!isEmpty()) root.color = BLACK; // 删完之后还需将根节点手动置为黑色, 与插入相同。</span><br><span class="line">&#125;</span><br><span class="line">private Node deleteMin(Node h) &#123;</span><br><span class="line">  if (h.left == null) return null; // 无左子树，删除h节点，返回null即为用null代替节点h</span><br><span class="line">  if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) &#123;  //此即为上述的第2种情况，需要借用节点</span><br><span class="line">    h = moveRedLeft(h);</span><br><span class="line">  &#125;</span><br><span class="line">//此时h.left本身已为红色(可再次调用moveRedLeft)，或它的子节点为红色(直接进入下一个节点的删除)</span><br><span class="line">  h.left = deleteMin(h.left); </span><br><span class="line">// 删除之后，从下往上恢复红黑树，解除4-节点(2红键)</span><br><span class="line">  return balance(h);</span><br><span class="line">&#125;</span><br><span class="line">// 调用此方法时，h本身是红色的，h.left, h.left.left都是黑色的，即h的左子节点为2-节点的情况</span><br><span class="line">// 调用结束时h的左子节点为红色，或它的子节点之一为红色，即h</span><br><span class="line">private Node moveRedLeft(Node h) &#123;</span><br><span class="line"></span><br><span class="line">  flipColors(h);   // 对应上述的第3步  反转颜色 h变为黑色，左右子节点变为红色，4-节点</span><br><span class="line">  if (isRed(h.right.left)) &#123;  // 对应上述第2种情况， 兄弟节点有红键</span><br><span class="line"></span><br><span class="line">     h.right = rotateRight(h.right);</span><br><span class="line">     h = rotateLeft(h);</span><br><span class="line">     flipColors(h);   </span><br><span class="line"></span><br><span class="line">     // 这3步变幻可以使得h.left变为红色，达到了上述的左子节点变为3-节点的要求，</span><br><span class="line">     // 从而可以对其再次调用deleteMin方法</span><br><span class="line"></span><br><span class="line">     // 从这也可以进一步思考变幻的实际意义，旋转操作实际上并没有改变树的结构，红链接在左边</span><br><span class="line">     // 或右边其实是3-节点的内部2个键哪个键为根节点的问题。只有变色才是将键在父子节点中</span><br><span class="line">     // 传递的操作(冒泡)，或者说是2-变成3-，3-变长4-节点的操作。所以这里如果不进行判断处理</span><br><span class="line">     // 的话会形成5-节点，这一点通过再次调用flipColors(h)避免，而如果没有进入该条件语句时</span><br><span class="line">     // 即h的右子节点为2-节点，则只需要一步变色为4-节点即可，不用担心5-节点。</span><br><span class="line">  &#125;</span><br><span class="line">  return h;</span><br><span class="line">&#125;</span><br><span class="line">private void balance(Node h) &#123;</span><br><span class="line">  </span><br><span class="line">  if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h);</span><br><span class="line">  if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);</span><br><span class="line">  if (isRed(h.left) &amp;&amp; isRed(h.right))  flipColors(h);</span><br><span class="line"></span><br><span class="line">  h.size = size(h.left) + size(h.right) + 1;  // 别忘了加1</span><br><span class="line">  return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>红黑树删除任意键代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 与deleteMin基本相同</span><br><span class="line">public void delete(K key) &#123;</span><br><span class="line">  if(isEmpty()) throw new NoSuchElementException(&quot;BST underflow&quot;); </span><br><span class="line">  if(!contains(key)) return;</span><br><span class="line"></span><br><span class="line">  // 左右子树都是黑的，将根节点变为红色，相当于根节点与左右子节点一起变为一个4-节点</span><br><span class="line">  if(!isRed(root.left) &amp;&amp; !isRed(root.right)) &#123;</span><br><span class="line">    root.color = RED;</span><br><span class="line">  &#125;</span><br><span class="line">  root = delete(root);</span><br><span class="line">  if (!isEmpty()) root.color = BLACK; // 删完之后还需将根节点手动置为黑色, 与插入相同。</span><br><span class="line">&#125;</span><br><span class="line">private Node delete(Node h, K key) &#123;</span><br><span class="line"></span><br><span class="line">  if (key.compareTo(h.key) &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">    // 目标键比当前节点小的时候与deleteMin(node)相同处理</span><br><span class="line">    if (!isRed(h.left) &amp;&amp; !isRed(h.left.left)) &#123;  </span><br><span class="line">      h = moveRedLeft(h);</span><br><span class="line">    h.left = delete(h.left, key);</span><br><span class="line"></span><br><span class="line">  &#125;else&#123;</span><br><span class="line"></span><br><span class="line">    if (isRed(h.left)) &#123;</span><br><span class="line">      h = rotateRight(h);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key.compareTo(h.key) == 0 &amp;&amp; (h.right == null)) &#123; </span><br><span class="line">      // 查询命中的是无右子节点的最大键，直接删除即可,delete方法返回null就是删除该节点</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isRed(h.right) &amp;&amp; !isRed(h.right.left)) &#123;</span><br><span class="line">      h = moveRedRight(h);     // 通过旋转变色得到红键</span><br><span class="line">    &#125;</span><br><span class="line">    if (key.compareTo(h.key) == 0)&#123; //命中查询，使用后继节点替换h,同时h.right中删去该后继节点</span><br><span class="line">      Node x = min(h.right);</span><br><span class="line">      h.key = x.key;</span><br><span class="line">      h.val = x.val;</span><br><span class="line">      h.right = deleteMin(h.right);</span><br><span class="line">    &#125;else&#123;    // 目标键还在右子树中</span><br><span class="line">      h.right = delete(h.right, key); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  return balance(h);   // 同样恢复红黑树性质</span><br><span class="line">&#125;</span><br><span class="line">// assume that h is red and both h.right and h.right.left are black,</span><br><span class="line">// using this method to make h.right or one of its children red.</span><br><span class="line">private Node moveRedRight(Node h) &#123;</span><br><span class="line">  flipColors(h);</span><br><span class="line">  if(isRed(h.left.left)) &#123;</span><br><span class="line">    h = rotateRight(h);  </span><br><span class="line">    flipColors(h);</span><br><span class="line">  &#125;</span><br><span class="line">  return h;</span><br><span class="line">&#125;</span><br><span class="line">private Node min(Node x) &#123;</span><br><span class="line">  if (x.left == null) return x;</span><br><span class="line">  else                return min(x.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是红黑树的相关知识，下面来看看HashMap中红黑树的相关代码。<br>上面说过put(key,value)方法中会判断一个桶中是否有过多的Node节点，如果超过一定阈值，它会进行<br>树化。实际调用为putVal中的treeifyBin(table, hash)方法，treeifyBin方法中先判断hashMap容量是否<br>小于64,若小于64会扩容而不是树化，若大于它，则先使用replacementTreeNode(e, null)来构造一个<br>个TreeNode节点，再使用hd.treeify(table)方法来生成树。</p><p>在treeify方法中，以hd头节点开始遍历该链条，x代表该链条中的每一个节点，首先判断根节点是否为<br>空，为空时设置x为根节点并置为黑色，否则从树的根节点开始查询以插入x节点，其中p表示每个被比较<br>的节点，通过变量dir的正负区分键的大小，当指针变量p的左子节点(x比它小时)或右子节点(x比它大时)<br>为null时，说明查询命中，可以将x键插入，调用balanceInsertion(root,x)方法，再break跳出查询树<br>的循环，继续处理链条中的下一个节点。</p><p>treeify方法中已经将树的根节点置为黑色，BalanceInsertion中类似于上面的红黑树的balance方法。<br>其中大量有赋值语句，==比较和三目运算符混用的情况，虽然显得代码非常简洁，但是比较难理解，<br>需要自己画图帮助理解。balanceInsertion方法前面2步判断是针对x或xp为根节点的情况，简单处理<br>即可。后面分xp为xpp左子节点和右子节点2种情况讨论，它们是对称的，只看左子节点即可。</p><p>第一个if语句的情况即上面红黑树的左右子节点都为红色链接的情况，变色即可。然后下面依次进行的<br>左旋，右旋也对应上面的1,2种情况。理解代码实现中有2点需要注意:</p><ol><li><p>经过代码 <code>else if(!xp.red) || (xpp = xp.parent) == null)</code>判断之后，继续执行下面代码时<br>可以确认xp是红色的，并且xpp不为null.</p></li><li><p>代码<code>root = rotateLeft(root, x = xp);</code>执行时会先执行表达式赋值语句，再进行方法调用。<br>这时x,xp都指向同一个引用对象，rotateLeft方法中改变了该参数对象的属性(parent,left,right等),<br>所以x,xp变量是同时指向了变换前xp的左子节点的，即左旋后的引用情况为<br><code>xpp (左) -&gt; L(无变量，原来的x)(左) -&gt; x与xp</code>,后面的一句为<br><code>xpp = (xp = x.parent) == null ? null : xp.parent;</code>，这里个人觉得三目运算符判断没什么意义<br>(xp即为插入的x,不可能是null), 更多是利用其语法简洁性重置了xpp, xp, x的对象引用关系。</p></li></ol><p>再看其左旋转的具体代码实现，它增加了对根节点root的处理，看起来没有上面红黑树的实现简洁清晰，<br>但画图可以发现，逻辑是一样的，如左旋转，实际上是4个相关的节点发生了改变:pp, p, r, rl,另外<br>2个节点pl,rr没有发生变化;同理右旋转改变的是pp, p, l, lr节点。要注意的是，左右旋转方法中还有<br>对根节点的置黑处理，而上面红黑树中是在put方法的最后才对根节点进行置黑处理的。</p><p>经过treeify中针对链表每一个节点查询比较键值后插入再balance后，最后还调用了moveRootToFront<br>(table, root)方法来确保树的根节点是链表的首节点。<br>该方法的关键为NodeTree即是红黑树结构，也是双向链表结构。moveRootToFront的主要操作为将root<br>节点从原有的链表位置删除，并与原有的first节点重新确定链表关系的过程。如以下初看难理解的代码<br><code>((TreeNode&lt;K,V&gt;)rn).prev = rp;</code>即为root节点的后节点的前序节点指针指向root的前序节点，这<br>一步即等同于删除了root节点。后面同理是对pr,first，root节点的链表指针进行操作。</p><p>最后要看的是HashMap的删除remove(key)方法,它调用的是removeNode方法，首先是查询到该节点，如<br>果是树节点，则调用treeNode.getTreeNode(hash, key)方法，否则按链表来查找，同样的，找到以后<br>如果是树节点调用treeNode.removeTreeNode(this, table, movable)方法，否则通过修改对应的节点<br>指针来删除该链表中的节点。</p><p>因为TreeNode即是红黑树，也是双向链表，所以删除节点时要先删除链表节点，再删除红黑树节点并<br>做平衡处理。这里也是寻找待删除节点的后继节点与之交换并平衡的操作，具体操作不再仔细查看。</p><p>HashMap的主要子类有LinkedHashMap.<br>      LinkedHashMap:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>同LinkedHashSet在HashSet上的处理一致(或者说更本质)，LinkedHashMap在HashMap的基础上对键增加<br>了双向链表记录插入的顺序，这个链表使得LinkedHashMap的元素遍历顺序是固定的，相同键被重新<br>赋值不影响键的顺序， 因为节点位置没有改变。LinkedHashMap可用来记录参数map的顺序。也由于它<br>的有序性，遍历map的时间只与元素的总个数相关，与Map集合的容量无关。同样，LinkedHashMap是<br>线程不安全的，可以用<code>Collections.synchronizedMap(new LinkedHashMap())</code>方法得到线程安全<br>的map集合。</p><p>具体实现可以看到LinkedHashMap中定义了静态内部类Entry(继承自HashMap.Node类),通过这个额外的<br>容器来存储键插入的顺序，其中有before，after2个方向指针。LinkedHashMap还提供了一个实例域<br>accessOrder,可以在构造器中指定该布尔值为true或false(默认false).true代表访问的顺序，<br>false代表迭代顺序。LinkedHashMap的查询get(key)方法比HashMap的get(key)方法多出一步处理<br>就是判断该accessOrder值，如果是true,则执行afterNodeAccess(node)方法，它会将这个被访问的<br>节点放到Entry链表中的尾部。由于LinkedHashIterator从链表头部开始遍历，所以如果此时开始遍历<br>集合，最后访问的节点将最后被访问到。</p><p>可以发现LinkedHashMap没有定义put和remove方法，即它默认使用的是父类HashMap的方法，<br>虽然LinkedHashMap没有重新定义put,remove方法，但它通过重新定义newNode,newTreeNode方法，在<br>其中调用linkNodeLast(node)方法维护该双向链表。另外HashMap中的空方法afterNodeInsertion,<br>afterNodeRemoval在LinkedHashMap中都定义了对额外的双向链表进行处理。</p><p><em>即LinkedHashMap元素的容器同HashMap一样，使用Node[]数组”拉链法”存储的,只不过额外定义了<br>双向链表来存储节点顺序。</em></p><p>注: HashMap中定义的TreeNode内部类继承的是<code>LinkedHashMap.Entry&lt;K,V&gt;</code>类，所以TreeNode类本身<br>也是双向链表。</p><ol start="2"><li>TreeMap<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable,</span><br><span class="line">  java.io.Serializable</span><br></pre></td></tr></table></figure></li></ol><p>同SortedSet, NavigableSet基本相同，SortedMap提供了submap，headMap,tailMap方法按照键的顺序<br>截取子map集合。NavigableMap基于顺序提供了更多的区间操作，如floorEntry, floorKey,<br>ceilingEntry,ceilingKey等方法。</p><p>TreeMap即Map的红黑树实现。保证对于containsKey,get,put,remove操作都是对数级别。TreeMap的<br>红黑树算法来源于算法导论中的实现,即CLR.同样的，compare或compareTo方法需要与equals方法保持<br>一致。TreeMap不是线程安全的，可以通过<code>Collections.synchronizedSortedMap(new TreeMap());</code><br>来得到线程安全的SortedMap集合。</p><p>具体实现可以看到TreeMap定义了自己的Entry类(继承自Map.Entry类)存储键值对，同时定义了左子节点<br>指针，右子节点指针，父节点指针。get(key)查询方法即通过Comparator或Comparable进行比较得到<br>需要的节点，put(key,value)方法同样是先查询到位置插入后再进行红黑树调整，值得注意的是put<br>方法中没有HashMap中的扩容操作，是一颗无限增长的树或链表。</p><p>将TreeMap的rotateLeft方法实现与上面的实现比较发现，CLR算法实现多使用了一个parent父指针，实际<br>上是可以省去它的，父指针增加了额外的复杂性。<br>具体实现不再赘述。</p><ol start="3"><li>WeakHashMap<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><p>使用弱键的哈希表Map接口实现类。当WeakHashMap中的某个键不再被正常使用时，这个键值对会自动<br>被删除。具体的说就是，一个已经存在的映射关系不能阻止垃圾回收机制回收这个键，当键被删除了，<br>这个键值对也就不存在了。WeakHashMap同样支持null键和null值，同样是线程不安全的，可使用<br><code>Collections.synchronizedMap(new WeakHashMap(...))</code>得到线程安全的map集合。</p><p>WeakHashMap主要适用于equals方法使用==号实现的键对象，如String对象。对于那些可重复创建的键<br>对象来说，WeakHashMap的自动删除操作会出现问题。垃圾回收器就好像WeakHashMap背后默默运行的<br>一个线程一样，它会在任何时间进行删除操作,所以WeakHashMap中的方法如size(), isEmpty(),<br>containsKey(), get(), put()调用的结果随时间可能会发生变化。每个键对象是用一个弱引用存储的，<br>只有当这个弱引用在Map集合内部和外部的引用都被垃圾回收器回收后这个键才会被删除。</p><p>WeakHashMap的值对象是用普通的强引用来存储的，所以应注意值对象不应该强引用(直接或间接)它<br>对应的键，这样会阻止键被回收。有时候会出现这样的情况，即键x映射值X,键y映射值Y,此时值X又<br>强引用键y，而值Y强引用键x,而映射本身算是强引用的，这样就形成了x,X和y,Y之间间接强引用的关系。<br>为避免这样的情况，对于不依赖WeakHashMap集合来存储引用的值对象来说，可以在插入前进行包装:<br><code>m.put(key, new WeakReference(value));</code>,在查询调用get(key)方法时再进行拆箱即可。</p><p>以下为相关背景知识补充:</p><p>Reference分几种类型: </p><ol><li><p>强引用(Strong Reference) 即普通的引用，如Object obj = new Object();当内存不足时，虚拟机<br>会抛出内存溢出异常，而不会回收强类型的引用。需要回收这种类型引用时，需要赋值obj = null.<br>它对应着Reference的子类FinalReference,JVM采用其子类Finalizer来管理每个强引用对象，要清理<br>对象时将其放入对应的引用队列中并调用对象的finalize()方法进行清理。</p></li><li><p>软引用(Soft Reference) 当内存空间不足时，垃圾回收器就会回收软引用对象。所以它适合用于<br>内存敏感的高速缓存。实际应用如网页的后退按钮，内存充足时可以将网页浏览记录保存为软引用作为<br>缓存使用，但内存不够时它就会被垃圾回收器回收。</p></li><li><p>弱引用(Weak Reference) 弱引用对象比软引用对象生命周期更短，当垃圾回收器扫描到只具有弱<br>引用的对象时，不管内存大小都会回收这个对象。但垃圾回收器优先级很低，所以通常不会很快就发现<br>这些对象。当内存不足时，垃圾回收器也会回收弱引用对象(即内存不足时垃圾回收器会回收一切可回收<br>对象)。</p></li><li><p>虚引用(PhantomReference) 虚引用并不会决定对象的生命周期，它和没有任何引用一样，随时可能<br>被垃圾回收器回收。虚引用主要用来追踪对象回收的情况，它必须和引用队列ReferenceQueue一起使用，<br>当垃圾回收器回收一个对象时，如果它有虚引用，则在回收前会将它加入到相应的队列中。</p></li></ol><p>软引用，弱引用同垃圾回收关系<br>java.lang.Reference是所有引用对象的基类,它定义了所有引用对象的通用操作，因为引用对象是与<br>垃圾回收器紧密合作实现的，所以不能直接继承Reference类。可以继承它的子类。</p><p>Reference实例对象可能处在4种状态中:active, pending, enqueued, inactive.</p><ol><li><p>active: 新创建的实例是active状态，垃圾回收器监测到它的引用对象的可达性发生变化时，会将该<br>实例对象变为pending(如果创建的时候有注册相应的引用队列ReferenceQueue)并且将该实例加入到<br>pending-reference list中，或者直接为inactive(创建时未注册引用队列)。Active状态时queue为<br>创建时定义的queue或为null, next = null, discovered = GC维护的discovered引用列表中当前元素<br>的下一个元素。</p></li><li><p>Pending: 该实例是pending-reference list中的一个元素，等待Reference-handler线程对它进行<br>入队操作。queue为创建时定义的queue, next = this，discovered = pending-reference list中当前<br>元素的下一个元素，如果当前元素为最后一个，则discovered = null.</p></li><li><p>Enqueued: 该实例成为创建它时指定队列中的一个元素(即入队状态)，当该实例从队列中被删除时，<br>它会变为inactive状态。queue = ReferenceQueue.ENQUEUED; next指向队列中的下一个实例，如果当<br>前实例是队列中的最后一个元素，则next = this. discovered = null(tryHandlePending方法中有赋值)</p></li><li><p>Inactive: 一旦一个实例变为Inactive状态，它的状态就不会再改变了，相当于结束。<br>queue = ReferenceQueue.NULL; next = this.</p></li></ol><p>所以垃圾回收器可以通过next == null来判断一个reference实例状态是否为active.<br>Reference类中的几个实例域分别为:</p><p>referent:  引用指向的对象<br>queue:  reference对象关联的队列，即引用队列。<br>next: 上面referenceQueue中当前元素的下一个元素。<br>discovered: pending-reference list中当前元素的下一个元素，jvm给它赋值。</p><p>ReferenceQueue:<br>  当对象可达性发生变化时该引用对象被垃圾回收器放入的注册引用队列。<br>通过实现可以看出，ReferenceQueue中定义了一个Reference Head头节点，实际的队列结构是由<br>Reference对象本身的next属性构成的，只是入队，出队操作定义在ReferenceQueue中。可以看到，<br>Reference和它的容器ReferenceQueue是互相定义的，这一点显示了它们之间包含与注册的关系。</p><p>ReferenceQueue的入队方法enqueue(reference)只能被Reference类调用，可以通过<br>reference.enqueue()方法的实现明确这一点(但实际上垃圾回收器没有调用该方法，它是直接操作的)，<br>referenceQueue.enqueue(r)方法一开始判断r.queue是否为NULL或ENQUEUED状态，若是直接返回false.<br>其中NULL代表该引用对象创建时使用的是默认的NULL队列注册的，没有指定相应队列所以入队失败;<br>ENQUEUED代表该引用对象已入队，重复入队为失败操作。下面的逻辑可以看到新入队的节点为头节点，<br>r.next = (head == null) ? r : head;  r = head.实际出队方法reallyPoll()中判断r == rn，说明<br>r是队列中最后一个元素，将head = null.删除操作即将r.queue = null, r.next = r. poll()即加锁<br>调用reallyPoll()方法。remove()方法提供了一个超时时间，时间为0即lock.wait(0)表示永久阻塞<br>直到被唤醒。</p><p>WeakReference和ReferenceQueue配合使用代码如下，可以看到对象被回收后队列中仍然存有该对象的<br>引用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestReferenceQueue &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        Person person = new Person();</span><br><span class="line">        ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        WeakReference&lt;Person&gt; weakReference = new WeakReference&lt;&gt;(person, queue);</span><br><span class="line">        System.out.println(weakReference);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        person = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        Reference&lt;? extends Person&gt; ref = queue.remove();</span><br><span class="line">        System.out.println(ref);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Person&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Person&#123;&#125;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为:</span><br><span class="line">java.lang.ref.WeakReference@1540e19d</span><br><span class="line">Person&#123;&#125;</span><br><span class="line">java.lang.ref.WeakReference@1540e19d</span><br><span class="line">null</span><br></pre></td></tr></table></figure></p><p>WeakHashMap弱引用实战代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class WeakHashMapDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">         </span><br><span class="line">        WeakHashMap&lt;String, byte[]&gt; whm = new WeakHashMap&lt;String, byte[]&gt;();</span><br><span class="line">     // HashMap&lt;String, byte[]&gt; whm = new HashMap&lt;String, byte[]&gt;();</span><br><span class="line">        String s1 = new String(&quot;s1&quot;);</span><br><span class="line">        String s2 = new String(&quot;s2&quot;);</span><br><span class="line">        String s3 = new String(&quot;s3&quot;);</span><br><span class="line">         </span><br><span class="line">        whm.put(s1, new byte[100]);</span><br><span class="line">        whm.put(s2, new byte[100]);</span><br><span class="line">        whm.put(s3, new byte[100]);</span><br><span class="line">         </span><br><span class="line">        s2 = null;</span><br><span class="line">        s3 = null;</span><br><span class="line">         </span><br><span class="line">        /*此时可能还未执行gc,所以可能还可以通过仅有弱引用的key找到value*/</span><br><span class="line">        System.out.println(whm.get(&quot;s1&quot;));</span><br><span class="line">        System.out.println(whm.get(&quot;s2&quot;));</span><br><span class="line">        System.out.println(whm.get(&quot;s3&quot;));</span><br><span class="line">         </span><br><span class="line">        System.out.println(&quot;-------------------&quot;);</span><br><span class="line">         </span><br><span class="line">        /*执行gc,导致仅有弱引用的key对应的entry(包括value)全部被回收*/</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(whm.get(&quot;s1&quot;));</span><br><span class="line">        System.out.println(whm.get(&quot;s2&quot;));</span><br><span class="line">        System.out.println(whm.get(&quot;s3&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为WeakHashMap中s2,s3对应的值已变为null,HashMap仍存在。</span><br></pre></td></tr></table></figure></p><p>从WeakHashMap的实现可以看出，它的存储容器同HashMap类似，是Entry[]数组，但是WeakHashMap<br>自定义的Entry类为<br><code>private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implement Map.Entry&lt;K,V&gt;{}</code>,<br>从这可以看出，WeakHashMap的键属于弱引用类型。从代码中可以看到，get(key), size(), put()方法<br>都间接调用了expungeStaleEntries()方法，该方法对引用队列进行出队操作，利用队列中的引用来<br>删除WeakHashMap链表中已经失效的节点。</p><ol start="4"><li>IdentityHashMap<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class IdentityHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, </span><br><span class="line">  java.io.Serializable, Cloneable&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><p>该map使用引用的等价性而不是对象的对价性来比较键，即使用==符号而不是equals方法来区分不同的<br>键。从这一点上说，它违反了Map接口默认使用equals方法进行比较键的定义，所以它不适合作为常用<br>接口使用，只适用于需要使用引用等价性的场景，如序列化，深度拷贝，代理对象集合等。这个类实现<br>了Map接口的所有方法，同HashMap一样允许null键null值，不保证键的顺序。它有一个预计最大容量的<br>参数来决定初期桶的数量，同样，超出后自动扩容重新哈希化的代价很高，同时，过大的容量又会造成<br>迭代元素实践过长，所以需要定义一个合适的容量大小。IdentityHashMap也不是线程安全的，可以使用<br>Collections.synchronizedMap(…)得到线程安全的map集合。它的迭代器也是快速失败的，不保证<br>一定会抛出异常。</p><p>IdentityHashMap是哈希表的线性探测法实现，可以在《算法》第4版中看到该算法实现。<br>以下为书中的相关笔记。</p><p>散列表有2种实现: 拉链法(HashMap)和线性探测法(IdentityHashMap)，拉链法是让哈希值相同的键<br>放入同一个索引的桶中形成链表来解决碰撞问题，而线性探测法是利用数组中的空位来解决碰撞问题。<br>一般将检查一个数组位置上是否是需要查找的键的操作称为探测，与追加链表不同，当发生碰撞时，<br>它会探测下一个索引的元素是否为空，如果为空就将新键写入其中。查询时按索引递增进行查找，若<br>碰到空元素即代表相同哈希值的键(键簇)遍历结束，即查找元素不存在。同时也由于空元素代表结束，<br>所以删除一个元素时不能简单的将其置为null(这样会使得后面的元素无法被查询到，因为哈希值是<br>通过哈希函数计算得出所以是固定的), 这时可以将后面的元素重新哈希化插入到数组中。<br>(一组连续的非空元素具有相同的哈希值，也叫做键簇。键簇越小查询效率越高)。</p><p>这种利用空元素来作为结束的机制决定了线性探测法的数组容量必须足够大，对于不同的哈希值都要<br>有一个空元素作为结束符。所以在插入元素前或删除元素后都需要判断元素个数和数组容量的比值大小，<br>适当进行扩容或缩容操作，使得数组的使用率保持一定的大小。</p><p>《算法》书中使用2个大数组来分别存储键和值，而从IdentityHashMap的实现中可以看到它只使用了<br>一个数组来存储键值对，由put(key, value)方法可以看出，一对键值对是存储到2个紧邻的元素位置中。<br>put方法中根据哈希值查询到对应的索引，然后向后递增查找(nextKeyIndex方法也是以2追加), 使用<br>==判断对象引用相同时，将tab[i+1]赋值为新的键值。内存循环结束条件为item == null, 即该键为<br>新键时，下面有判断<code>s + (s &lt;&lt; 1) &gt; len</code>条件，即<code>size &gt; len / 3</code>, 意思为元素个数超过容量的<br>1/3时，它就会进行扩容操作(扩大一倍)，扩容完毕后重新进行插入逻辑判断。get(key)方法也是通过<br>==进行键的比较，并返回下一个索引位置的键值。同HashMap一样，IdentityHashMap允许null键null值，<br>所以get方法返回null值可能是该键不存在，也可能它的键对应就是null值，这一点可以通过调用<br>containskey(key)方法进行区分。remove()方法即将被删除元素后的键全部都重新哈希并插入，直到<br>遇到空元素为止。</p><ol start="5"><li>EnumMap<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class EnumMap&lt;K extends Enum&lt;K&gt;, V&gt; extends AbstractMap&lt;K,V&gt; implements</span><br><span class="line">  java.io.Serializable, Cloneable&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><p>同EnumSet类似，EnumMap的键都属于同一个枚举类。插入空键会报空指针异常 ，允许空值。EnumMap<br>也是线程不安全的，可以使用Collections.synchronizedMap(new EnumMap())得到线程安全的map集合。<br>因为枚举类型本身的有序性(ordinal()方法), 所以EnumMap只需要定义一个存储值的数组即可，数组<br>的索引为枚举的索引值，数组元素值为对应的键值。可以看到，这种方式get,put方法都是常量时间性能。</p><p>以上为本人根据jdk源码整理出的java集合类笔记，下面回归到JavaCore10一书的笔记。</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>LinkedList的ListIterator迭代器add方法返回值为void类型，即它默认即是要改变链表结构的，它在<br>当前的光标位置处插入新元素，add方法只依赖迭代器的位置，所以可以连续调用add方法，而remove方法<br>依赖于迭代器的状态，不能连续调用，调用前必须移动一次光标位置。</p><p>关于迭代的并发修改问题，书中明确指出迭代器是建立了自己独立的计数器，在方法开始的时候即检查<br>自己改动的操作次数是否与集合的被改动次数一致，如果不一致，说明有除迭代器以外的操作改动了集合，<br>这时即可以抛出并发修改异常。</p><p>注: set方法不被认为是集合的结构性修改，不计入改动次数，Collections类的许多算法都使用了这个<br>功能。</p><p>java中散列表用链表数组实现，每个列表被称为桶(bucket), 将散列码与桶的总数(数组长度)取余即<br>得到查找键所在的桶索引，当出现散列冲突(哈希碰撞)时，即将查找键与桶中对象逐一进行比较。这个<br>过程在前面的HashMap实现中可以看出，这里用桶的概念再次说明。</p><p>散列函数由于不需要关心排序，所以查询和操作元素的速度是最快的，如果需要排序，应使用树集。</p><p>双端队列接口为Deque,实现类有LinkedList, ArrayDeque.</p><p>优先级队列PriorityQueue调用remove方法时，删除的是当前队列中最小的元素。在实际使用中，我们<br>经常需要取到优先级最高的元素，此时，我们可以将1(最小元素)设置为优先级最高，次高为2,依次<br>类推，数值越大优先级越低，从而达到应用的目的。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>map接口中有一个getOrDefault方法可以在对应键不存在时返回默认值(对应值确实为null时即返回null)<br>迭代一个map集合最方便的方法为Map接口的<code>forEach(BiConsumer&lt;T,U&gt;)</code>方法，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k,v) -&gt; System.out.println(&quot;key=&quot; + k + &quot;, value=&quot; + v));</span><br></pre></td></tr></table></figure></p><p>更新映射的值时如果键存在我们可以先获取原值再修改，如对不同的单词计数:<br><code>map.put(key, map.get(key) + 1);</code><br>但如果键不存在，get方法将会抛出空指针异常。这时我们可以使用以下方法：</p><ol><li>使用getOrDefault方法，如<code>map.put(key, map.getOrDefault(key, 0) + 1);</code></li><li><p>先调用putIfAbsent方法，先存入不存在的键值映射，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.putIfAbsent(key, 0);</span><br><span class="line">map.put(key, map.get(key) + 1);</span><br></pre></td></tr></table></figure></li><li><p>使用Map接口的merge方法，如<br><code>map.merge(key, 1, Integer::sum);</code></p></li></ol><p>查看源码实现，merge(key, value, BiFunction(V,V,V))方法实现为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">V newValue = (oldValue == null) ? value : remappingFunction.apply(oldValue, value);</span><br><span class="line">if (newValue == null) &#123; </span><br><span class="line">  remove(key); </span><br><span class="line">&#125;else&#123;</span><br><span class="line">  put(key, newValue); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从实现看，正是我们需要实现的功能: 将函数应用到旧value和新value上，得到的结果作为新的映射值，<br>当新value本身为null或BiFunction返回null时会进行删除操作。Map接口还提供了其他如<br>compute(key, BiFunction(k,V,V))方法对键和值本身进行计算得到新值的方法等，用途比较小(从应用<br>上说，键和值进行关联得到新值使用场景很小)。</p><p>弱散列映射<br>WeakHashMap周期性的检查队列，如果其中有新添加的弱引用，说明该引用已经不再被使用了，那么<br>WeakHashMap即会删除该键值对(即expungeStaleEntries()方法)。</p><p>LinkedHashSet和LinkedHashMap用来记住插入元素的顺序。<br>链表映射需要使用访问顺序而不是插入顺序进行迭代时，可以在初始化链表时指定accessOrder参数为<br>true.这一点对实现高速缓存的”最近最少使用”原则非常重要。LinkedHashMap中定义了<br>removeEldestEntry(oldestEntry)方法，它在插入元素后使用，可以自定义子类重写该方法实现该功能，<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 该map存储的是访问次数最多的100条数据  get,put方法调用都进行计数</span><br><span class="line">Map&lt;K,V&gt; cache = new LinkedHashMap&lt;&gt;(128, 0.75F, true) &#123;</span><br><span class="line">   protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</span><br><span class="line">     return size() &gt; 100;  </span><br><span class="line">   &#125; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p><p>EnumSet使用位序列实现，对应的值在set集合中时，对应的位即为1.<br>EnumMap使用值数组实现，数组索引对应枚举键。</p><p>IdentityHashMap使用System.identityHashCode计算散列值，使用==比较对象，在对象序列化时很有用。</p><h3 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h3><p>如HashMap的KeySet集合不是新建一个set集合，向其中填充元素再返回，而是返回一个实现了Set接口的<br>类对象，这种集合即称为视图。</p><ol><li>轻量级集合包装器<br>如Arrays.asList(T…)方法返回的不是ArrayList,而是一个视图，不支持改变list的大小。<br>同理有Collections.nCopies(n, obj)可以得到一个包含了n个相同的obj对象的集合，但它实际只存储<br>了一个obj对象引用。其他还有Collections.singleton(obj), singletonList(T), singletonMap(K,V)<br>方法。</li><li>子范围<br>可以对取出的子范围进行操作，如删除等，它会反映到全集中。<br>对于有序集或映射，如SortedSet, SortedMap等也有相应的方法， NavigableSet, NavigableMap则有更<br>进一步的处理，对边界元素的控制。</li><li>不可修改的视图<br>Collections类有几个方法可以得到集合的不可修改视图，如Collections.unmodifiableList等，得到<br>的视图可以调用List接口的方法，但所有更改器方法都会抛出UnsupportedOperationException.视图<br>只是包装了接口而不是实际对象，所以实际类中的非接口方法将不能调用。</li><li>同步视图<br>Collections类的synchronizedMap等方法即使用了视图(内部类)来得到线程安全的map集合。</li><li>受查视图<br>针对泛型检查不到的情况。如以下代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ints = new ArrayList&lt;&gt;();</span><br><span class="line">ArrayList raw = ints;</span><br><span class="line">raw.add(&quot;str&quot;);</span><br><span class="line">System.out.println(ints.get(0).intValue());  //这一行报错，在使用时报错，不利于debug</span><br><span class="line"></span><br><span class="line">List safes = Collections.checkedList(ints, Integer.class);</span><br><span class="line">safes.add(&quot;sd&quot;);   // 这一行报错，checkedList在add方法时即进行类型检查</span><br><span class="line">System.out.println(ints.get(0).intValue());</span><br></pre></td></tr></table></figure></li></ol><p>注意: <code>ArrayList&lt;Pair&lt;String&gt;&gt;的受查视图无法检测出Pair&lt;Date&gt;类型。CheckedCollection的typeCheck方法是使用isInstance()方法进行判断的，它对泛型类型是无效的。</code></p><ol start="6"><li>可选操作<br>可选操作是类库设计者综合各方便需求，如易于学习，使用方便，泛型化，通用性与算法高效性综合<br>考虑的结果，并不值得应用到实际的编程中。</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>集合接口为不同的数据结构提供了一种统一的算法实现。比如得到一个数组，或数组列表，或链表中<br>的最大元素，就不需要重复编写类似的代码，只需要定义一个通用接口类型如Collection类作为方法参数，<br>在此基础上实现算法逻辑(如统一利用迭代器进行迭代处理)，从而达到算法通用的目的。总的来说，<br>算法的实现都是建立在泛型集合的基础上的。</p><ol><li>排序与混排<br>Collections.sort(List)方法调用的是List接口的List.sort(Comparator)方法，它是将集合转换为<br>数组排序完成后再通过迭代一个个复制回集合中。Arrays.sort方法使用了归并排序算法，而不是<br>通用的快速排序，因为归并排序算法不会比较相同的元素，所以它是更稳定的算法。</li></ol><p>在集合的基础上实现算法，需要集合本身是可以修改的，但不一定需要可以更改大小: 即可以使用set<br>方法，不一定需要支持add或remove方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">排序相关的方法有:</span><br><span class="line">1. Collections.sort(List)</span><br><span class="line">2. Collections.shuffle(List)</span><br><span class="line">3. List.sort(Comparator)</span><br><span class="line">4. Comparator.reverseOrder() 接口静态方法</span><br><span class="line">5. Comparator.reversed()     接口默认方法</span><br></pre></td></tr></table></figure></p><ol start="2"><li>二分查找<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.binarySearch(collection, element)</span><br><span class="line">Collections.binarySearch(collection, element, comparator)</span><br></pre></td></tr></table></figure></li></ol><p>这2个方法定义了二分查找的算法实现。二分查找是建立在支持随机访问的有序列表基础上的，即被<br>比较的集合应当实现RandomAccess接口，否则它将利用迭代器进行遍历比较，这样就失去了二分查找<br>的优势。方法的返回值若为正数，代表搜索命中的元素索引，未找到返回的是最后搜索结束的位置<br>(如i),可以将新元素插入-i-1位置处(具体是使用List.add(index, el)方法，在指定的索引处插入元素<br>el, 该位置原有元素及以后元素全部右移，二分查找方法返回值为-(low+1), 所以可以认为是应在low<br>位置处插入新元素)，从而保证列表的有序性。</p><ol start="3"><li><p>简单算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Collections类:</span><br><span class="line">1. T min(Collection)</span><br><span class="line">2. T max(Collection)</span><br><span class="line">3. T min(Collection, Comparator)</span><br><span class="line">4. T max(Collection, Comparator)</span><br><span class="line">5. void copy(List to, List from)</span><br><span class="line">6. void fill(List, value)</span><br><span class="line">7. boolean addAll(Collection, T... values)</span><br><span class="line">8. boolean replaceAll(List, T oldValue, T newValue)</span><br><span class="line">9. int indexOfSubList(List l, List s)   第一个子列表的索引，如s为s,t, l为a,s,t,则方法返回1</span><br><span class="line">10. int lastIndexOfSubList(List l, List s) 最后一个子列表的索引 </span><br><span class="line">11. void swap(List, int i, int j) 交换给定索引的2个元素</span><br><span class="line">12. void reverse(List) 反转列表的顺序</span><br><span class="line">13. void rotate(List l, int d) 将索引i的元素移动到位置(i + d) % l.size()处。从这个计算公式</span><br><span class="line">可以看出d为正数时是向右移动(backward)，d为负数时向左移动(forward)。</span><br><span class="line">文档注释中提到如果只需要移动一个元素从j移动到k位置(j&lt;k),其余元素不变，可以使用sublist,代码为</span><br><span class="line">Collections.rotate(list.subList(j, k + 1), -1);</span><br><span class="line">14. int frequency(Collection, Object obj)  返回集合中与obj元素相同的元素个数 </span><br><span class="line">15. boolean disjoint(Collection c1, Collection c2) 如果2个集合没有共同元素，返回true</span><br><span class="line">// </span><br><span class="line">Collection接口:</span><br><span class="line">1. boolean removeIf(Predicate&lt;T&gt;)  删除满足条件的元素</span><br><span class="line">//</span><br><span class="line">List接口:</span><br><span class="line">1. void replaceAll(UnaryOperator&lt;T&gt;)  对集合中所有元素进行指定操作</span><br><span class="line">示例如:</span><br><span class="line">wordList.removeIf(word -&gt; word.length() &lt; 3);</span><br><span class="line">wordList.replaceAll(String::toLowerCase);</span><br></pre></td></tr></table></figure></li><li><p>批操作<br>快速取出a, b集合的交集可以这样实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashSet resultSet = new HashSet(a);</span><br><span class="line">resultSet.retainAll(b);</span><br></pre></td></tr></table></figure></li></ol><p>同样，可以利用前面提到的视图技术方便的集合进行批处理，如删除HashMap中的部分映射:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set toBeDeletedSet = ...;</span><br><span class="line">hashmap.keySet().removeAll(toBeDeletedSet);</span><br></pre></td></tr></table></figure></p><ol start="5"><li><p>集合与数组的转换<br>数组-&gt;集合: Arrays.asList(T… values)<br>集合-&gt;数组: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = new String[collectionSize];</span><br><span class="line">collection.toArray(arr);</span><br></pre></td></tr></table></figure></li><li><p>编写自己的算法<br>应当尽可能使用接口而不是具体的实现类作为方法参数来实现操作。同样的，方法的返回值也应当<br>尽可能是接口，这样方便以后可以修改方法的实现。如原方法是将集合中每个元素处理后的新集合<br>返回给调用者，后面可以修改为集合的视图(自定义匿名内部类)返回，这样返回的集合是不可修改的，<br>某些情况下更加安全。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;JMenuItem&gt; getAllItems(JMenuItem item) &#123;</span><br><span class="line"></span><br><span class="line">   return new AbstractList&lt;&gt;()&#123;</span><br><span class="line">      public JMenuItem get(int i) &#123;</span><br><span class="line">        return menu.getItem(i); </span><br><span class="line">      &#125;</span><br><span class="line">      public int size() &#123;</span><br><span class="line">        return menu.getItemCount();  </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Collections.unmodifiableXXX内部就是使用了视图技术实现的，所以实际编程中可以使用它: 除非<br>参数如上面的例子一样是一个特殊对象，而不是一个常见的集合对象。</p><h3 id="遗留的集合"><a href="#遗留的集合" class="headerlink" title="遗留的集合"></a>遗留的集合</h3><ol><li>Hashtable类<br>不应当使用它，它与HashMap有相同的接口，一般正常使用是HashMap,需要并发时使用ConcurrentHashMap.</li><li>枚举<br>遗留集合使用Enumeration接口对集合进行遍历，有hasMoreElement和nextElement方法，与迭代器<br>Iterator接口功能相同。应当使用Iterator接口。<br>注: C++中使用迭代器作为参数十分普遍，java中一般直接使用集合作为参数，需要时从集合中获取<br>迭代器即可。</li><li>属性映射<br>Properties类(继承自HashTable):<ol><li>键和值都是字符串</li><li>表可以保存到一个文件中，也可以从文件中加载</li><li>使用一个默认的辅助表</li></ol></li><li>栈<br>Stack类，它继承了Vector类，从而可以使得Stack类可以调用不属于栈操作的insert和remove方法。</li><li>位集<br>BitSet类，用于存放一个位序列，表示一系列boolean值，BitSet使用字节存储每一位，所以比Boolean<br>对象的ArrayList更高效。bits.get(i)获得第i位的状态，bits.set(i)将第i位设置为true,<br>bits.clear(i)将第i位设置为false.<br>BitSet实际应用例子有查找素数的方法，先将范围内索引的位都设置为true,然后将相应的倍数设置为<br>false,最后留下来为true的位即为素数。</li></ol><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190330_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java, Char with UTF-16, C++, 数组，&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.taoblog.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.taoblog.cn/tags/Java/"/>
    
      <category term="C++" scheme="http://www.taoblog.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java1_Core10Note</title>
    <link href="http://www.taoblog.cn/post/2a1ddb5b/"/>
    <id>http://www.taoblog.cn/post/2a1ddb5b/</id>
    <published>2019-05-12T12:10:28.000Z</published>
    <updated>2019-09-17T08:31:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java, Char with UTF-16, C++, 数组，<br><a id="more"></a></p><p><strong>以下是阅读javaCore第10版中文版pdf的笔记，看熟2卷后可以再翻看第11版，因为11目前没找到<br>中文版&gt;_&lt;</strong></p><h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><p>安装后将jdk安装目录/bin加入到path环境变量即可,不用设置其他。</p><h2 id="基本程序设计结构"><a href="#基本程序设计结构" class="headerlink" title="基本程序设计结构"></a>基本程序设计结构</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java有8种基本类型，4种整型，2种浮点型，1个unicode字符类型char,1个boolean类型.</p><ol><li><p>整型<br>java需要保证不同机器上相同程序运行结果相同，所以java的数据取值范围是固定的<br>（C,C++在不同机器上数据取值范围不同，如在16位处理器上整型占2个字节，32位处理器上<br>整型占4个字节，java没有无符号形式的数据类型unsigned）<br>byte 1个字节 -127 ~ 127<br>short 2个字节 -3万2 ~ 3万2<br>int 4个字节  -21亿 ～ 21亿<br>long 8个字节  -9（共19位） ～ 9（共19位）</p><p>long类型有后缀L/l, 十六进制前缀0x/0X,八进制前缀0</p><p>从java7开始，二进制可以加前缀0b/0B, 数字字面量可以加下划线，编译器会自动去除，如<br><code>10_00_1</code>代表数字10001。</p></li><li><p>浮点类型<br>float 4字节   有效位数6～7位（后缀f/F)<br>double 8字节  有效位数15位(无后缀或后缀D/d)</p><p>有3个特殊的浮点数，正无穷大，负无穷大，NaN<br>Double中分别为<code>Double.POSITIVE_INFINITY,Double_NEGATIVE_INFINITY,Double_NaN</code></p><p>在整型中1/0会抛出算数异常，但1.0/0则会得到<code>Double.POSITIVE_INFINITY</code>,由于所有非<br>数值都认为是不相等的，所以<code>1.0/0 == Double.POSITIVE_INFINITY</code>永远是false,可以<br>这样判断Double.isInfinite(1.0/0),同理可以这样判断x是否是一个数字Double.isNaN(x)</p><p>由于浮点数由二进制表示，所以它无法精确表示0.1,就像十进制中无法精确表示1/3一样，所以<br>如果需要精确表示，需要用到bigDecimal.</p></li><li><p>char<br>char字面量用单引号括起来，它的值可以表示为十六进制,范围是\u0000到\Uffff<br>\u可以在引号外使用，它会在编译前转换为对应的符号，所以在注释中使用\u容易引起报错<br>如<code>\\ C:\users\</code>会报错非法的unicode转义 因为\u后不是4位16进制数<br>还有其他转义字符如’\n’，’\t’可以在引号内使用代表特殊含义。</p><p>编码：<br>UTF-16原来是定长16位的，但后来字符总数超过了65536（2^16)个，所以它变成了变长，<br>原字符集为基本字符集，多的字符集称为增补字符集。</p><p>unicode码点（code point)指编码表中与某个字符对应的代码值，用16进制数字表示，加上前缀U+<br>码点可以分为不同的代码级别(code plane)，分基本多语言级别和其他级别;<br>UTF-16使用变长长度来表示不同的unicode码点，针对基本多语言级别，使用16位表示一个字符，<br>这也称为一个代码单元(code unit)，其他级别使用2个代码单元来表示该字符。</p><p>java char类型表示UTF-16编码中的一个代码单元。<br>由此可知：</p><ol><li>大部分unicode字符可以用一个char值表示（基本多语言级别），少部分特殊字符（增补字符）<br>需要用2个char值表示。</li><li>1 byte = 8 bit, 1个字节代表8位，说明char类型是占用2个字节的。</li></ol><p>注： </p><ol><li>UTF-8是变长编码，它用1到4个字节表示不同区间的代码点。</li><li>增补字符集用2个代码单元表示一个字符，其范围是U+D800到U+DFFF,这个范围内的码点值没有<br>分配给任何字符，所以可以通过一个代码单元的码点值来判断它是基本字符还是增补字符的高/低位。</li></ol><p>show the code:<br><code>System.out.println(&quot;𐐷&quot;.length());</code> 输出2</p><p>最佳实践：不要在程序中使用char类型，尽量使用String类型。</p></li><li><p>boolean类型<br>java的布尔类型和整数值之间无法转换，而C++中数值或指针都可以代替布尔值，0代表false,非<br>0代表true.如下java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 11;</span><br><span class="line">System.out.println(x = 0); // 输出0</span><br><span class="line">if (x = 1) &#123;&#125; // 编译报错incompatible types,即表达式值为1时，它不会自动转换成bool值true.</span><br></pre></td></tr></table></figure></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量由字母开头，由字母和数字构成，字母和数字的范围很大。字母包括<code>a-z,A-Z,_,$和其他表示字母unicode字符</code>,数字也包括0-9和其他表示数字unicode字符。</p><p>c,c++中变量的声明和定义是不同的，java中则不区分，声明和定义是一个意思。<br>java使用final定义常量，常量名全大写。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>像前面说的一样，整数除以0会产生异常，浮点数除0得到无穷大或NaN.<br>由于数学上默认余数都要大于0,但是-6%4表达式执行结果为-2,可以用Math.floorMod(-6,4)来得到正<br>数的结果。<br>不同数值类型之间转换可能会产生精度丢失。如int-&gt;float,long-&gt;float,long-&gt;double等。<br>强制类型转换是直接截断小数部分，如(int)9.99999的结果是9,如果需要四舍五入，可以使用<br>Math.round方法。<br>注：将boolean类型和数值类型进行转换会产生错误，应使用三目运算符。</p><p>自增自减运算符与c,c++相同，不建议在表达式中使用该运算符，容易产生bug.</p><p>位运算<br>可以使用掩码技术来得到某个数二进制表示的某一位是0还是1,如<code>(15&amp;0b1000)/0b1000</code>结果为1代表15<br>右起第4位是1，同理<code>(24&amp;0b1000)/0b1000</code>也是1,注意括号不可少，限制了运算符顺序。<br>&lt;&lt;表示位模式左移,&gt;&gt;表示右移，具体来说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10&lt;&lt;2等同于0b1010 数字左移，其后补0变为0b101000 = 40.</span><br><span class="line">10&gt;&gt;2等同于ob1010数字右移，高位补符号位，变为0b0010 = 2.</span><br><span class="line">-10&gt;&gt;2 结果为-3,高位补符号位1</span><br><span class="line">-10&gt;&gt;&gt;2 结果为1073741821,高位补0</span><br><span class="line">注： 二进制和十进制转换</span><br><span class="line">System.out.println(0b1010);  //10</span><br><span class="line">System.out.println(Integer.toBinaryString(-10));//111111...补码，反码......</span><br></pre></td></tr></table></figure></p><p>java中没有逗号运算符</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>子串： substring(0,3)包头不包尾，包括0,1,2,这样子串长度可以很容易的由3-0=3得出。<br>拼接： 2个或较少的字符串拼接可以用’+’，多个字符串用一个指定分隔符拼接可以用String.join<br>      方法，如String.join(“/“, “A”, “B”,”C”);为A/B/C.<br>不可变字符串： 因为实际字符串修改需求较少，而且共享字符串的性能提高比拼接的耗费要多很多。<br>注：java字符串不等同于c中的字符数组，而是类似于<code>char*</code>指针。</p><p>比较字符串：因为只有字符串常量是共享的，其他如+或substring是不共享的，所以无法用==来判断<br>字符串相等，而因使用equals方法。<br>空串””与null串</p><p>码点与代码单元： char代表采用UTF-16编码一个码点需要的代码单元，string.length()方法返回的<br>就是字符串需要的代码单元个数，这样也就解释了”𐐷”.length() = 2，这个字符需要2个代码单元。<br>同时”𐐷”.codePointCount(0,2)返回了码点个数，即实际的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">码点和代码单元都是从0开始（和C一样）。</span><br><span class="line">使用&quot;XXX&quot;.codePointAt(i)来得到第i个码点的值</span><br><span class="line">如遍历字符串&quot;𐐷 is good&quot;,无论使用toCharArray还是使用&quot;𐐷 is good&quot;.charAt(i)遍历得到的都是</span><br><span class="line">2个代码单元，可以使用如下的条件判断来遍历输出字符串的各个码点。</span><br><span class="line">for(int i = 0; i &lt; test.length() - 1;) &#123;</span><br><span class="line">  int cp = test.codePointAt(i);</span><br><span class="line">  System.out.print(cp+&quot;,&quot;);</span><br><span class="line">  if (Character.isSupplementaryCodePoint(cp)) &#123;</span><br><span class="line">    i += 2;   // 补充字符占用2个代码单元</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">更简单的方法，使用intstream流。</span><br><span class="line">int codePoints = test.codePoints().toArray();</span><br><span class="line">for(int codePoint: codePoints) &#123;</span><br><span class="line">  System.out.print((char)codePoint + &quot;,&quot;);  //转换得到另一个特殊字符...</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.print(new String(codePoints, 0, codePoints.length())); //由数组反转得到字符串成功</span><br></pre></td></tr></table></figure></p><p>构建字符串<br>StringBuffer是多线程安全的，但性能不如StringBuilder,单线程时应使用StringBuilder.</p><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>读取输入：可以使用System.console对象来从控制台获取密码<br>printf格式化输出：<br>% 1 $ , 8.2 f<br>参数索引 标志(用,区分3位) 宽度.精度 转换符号<br>注： 经测试(负数用括号括起与宽度标志冲突，只能使用一个。</p><p>文件输入与输出：<br>Scanner in = new Scanner(Paths.get(“D:\a.txt”)), “utf-8”);<br>PrintWriter out = new PrintWriter(“D:\b.txt”, “utf-8”);</p><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>java break语句可以带标签，从而实现从内层循环跳出，C语言中使用goto语句，java没有goto.<br>另外java有foreach循环，C,C++没有。</p><p>块：<br>大括号内的内容叫做块，java不允许在嵌套块内重复定义相同变量，C++可以，它允许内层块覆盖外<br>层块的变量。</p><p>while语句的循环体可能一次也不执行，如果想循环体至少执行一次，可以使用<br>do{…}while(…)语句。</p><p>switch语句可能会导致执行多个case语句（在没有break语句的时候），所以一般程序中不使用switch<br>语句。（jdk 7之后case语句中可以为String类型）</p><p>带标签的break与continue语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label&#123;</span><br><span class="line">  ...</span><br><span class="line">  if(condition) break label;  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注： break与continue是可选的，完全可以避免使用它们（使用合理的判断条件即可）</p><h3 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h3><p>BigInteger和BigDecimal<br>可以使用valueOf将基本类型数值转换为bigInteger或bigDecimal类型</p><p>这2个对象加法用add方法，乘法用multiply方法…<br>注： C++可以自定义重载运算符，Java只重载了+号，它没有并且不允许程序员自己重定义重载运算符。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>java允许数组长度为0，长度为0的数组也是一个对象，可以用来作为方法返回值，避免返回null，造成<br>空指针。<br>数组扩容可以使用<br><code>luckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length);</code></p><p>java数组与C++数组指针基本一致，但它没有指针运算，即不能通过a加1得到数组的下一个元素。</p><p>数组排序可以使用Arrays.sort方法，它使用了快速排序算法，<br>使用Arrays.binarySearch方法实现二分查找<br>使用Arrays.fill方法将所有元素值设置为统一值<br>使用Arrays.equals方法比较两个数组是否相同</p><p>反转数组：</p><ol><li>面试时的回答<br>先Arrays.sort升序排列，再将第一个元素和最后一个元素互换，直到指针小于length/2(索引从0开始)</li><li><p>实际工作使用</p><ol><li><p>将数组转换为List,再用Collections.reverse(list)方法反转，最后用list.toArray(newArray)来<br>得到反转后的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer[] c = new Integer[5];</span><br><span class="line">c[0] = 8;</span><br><span class="line">c[1] = 3;</span><br><span class="line">c[2] = 6;</span><br><span class="line">c[3] = 5;</span><br><span class="line">c[4] = 2;</span><br><span class="line">Arrays.sort(c);</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br><span class="line">List&lt;Integer&gt; blist = Arrays.asList(c);</span><br><span class="line">Collections.reverse(blist);</span><br><span class="line">Integer[] newC = new Integer[c.length];</span><br><span class="line">blist.toArray(newC);</span><br><span class="line">System.out.println(Arrays.toString(newC));</span><br></pre></td></tr></table></figure></li><li><p>使用commons.lang3包中的ArrayUtils工具类，支持int,float,object.<br>通过查看源码可见，它也是使用了前后元素交换的算法实现的</p></li></ol></li></ol><p>随机打乱数组：</p><ol><li><p>网上说比较经典的方法是用Arrays.sort(array, comparator)，其中comparator的compare方法<br>使用Math.random()来实现在比较时随机产生正负数从而实现乱序，但由于sort排序底层实现中无论是<br>插入还是快排的比较次数都做了优化，达不到全部元素两两比较的绝对乱序要求。下面是sort的java<br>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> Integer[] c = new Integer[5];</span><br><span class="line"> c[0] = 8;</span><br><span class="line"> c[1] = 3;</span><br><span class="line"> c[2] = 6;</span><br><span class="line"> c[3] = 5;</span><br><span class="line"> c[4] = 2;</span><br><span class="line"> System.out.println(Arrays.toString(c));</span><br><span class="line"></span><br><span class="line"> // Arrays.sort(c, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"> //         @Override</span><br><span class="line"> //         public int compare(Integer x, Integer y) &#123;</span><br><span class="line"> //                 double i = 0.5 - Math.random();</span><br><span class="line"> //                 int flag = i &lt; 0 ? -1 : (i &gt; 0 ? 1 : 0);</span><br><span class="line"> //                 System.out.print(flag + &quot;,&quot;);</span><br><span class="line"> //                 return flag;</span><br><span class="line"> //         &#125;</span><br><span class="line"> // &#125;);</span><br><span class="line"> Arrays.sort(c, (x, y) -&gt; &#123;</span><br><span class="line">   double i = 0.5 - Math.random();</span><br><span class="line">   int flag = i &lt; 0 ? -1 : (i &gt; 0 ? 1 : 0);</span><br><span class="line">   System.out.print(flag + &quot;,&quot;);</span><br><span class="line">   return flag;</span><br><span class="line"> &#125;);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure></li><li><p>想实现绝对乱序，每个元素都参与比较，可以使用Fisher-Yates shuffle算法，基本思路是通过<br>随机数得到一个随机索引，将索引的元素值和最后一个元素进行交换，然后是倒数第二个元素，依次<br>进行即可，这样每个元素都得到了比较和交换的机会，实现了绝对乱序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Integer[] c = new Integer[5];</span><br><span class="line">c[0] = 8;</span><br><span class="line">c[1] = 3;</span><br><span class="line">c[2] = 6;</span><br><span class="line">c[3] = 5;</span><br><span class="line">c[4] = 2;</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br><span class="line"></span><br><span class="line">int i = c.length;</span><br><span class="line">while (i &gt; 1) &#123;   // i = 1时picked和后面的i都为0，交换自身可省略,选随机数次数为c.length-1</span><br><span class="line">  int picked = new Double(Math.floor(Math.random() * i--)).intValue();</span><br><span class="line">  System.out.print(picked + &quot;,&quot;);</span><br><span class="line">  int tmp = c[i];</span><br><span class="line">  c[i] = c[picked];</span><br><span class="line">  c[picked] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure></li></ol><p>注： javaCore书中的抽彩游戏算法与这里的洗牌算法思路相同，不同的是它不是原地排序，而是<br>将抽中的数字放到一个新数组中。</p><p>多维数组的快速打印可以使用Arrays.deepToString(array)方法</p><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><p>必须是一个数组或一个实现Iterable接口的集合，才能使用foreach循环</p><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><p>面向对象的程序设计过程</p><ol><li>识别类<br>简单的将名词作为类，动词作为方法<br>注：根据设计模式的解析，类的作用应该是封装变化，应将变化的部分作为一个类</li><li>绘制UML图确定类之间的关系</li></ol><h3 id="使用jdk包中预定义类"><a href="#使用jdk包中预定义类" class="headerlink" title="使用jdk包中预定义类"></a>使用jdk包中预定义类</h3><ol><li><p>对象与对象变量<br>java对象变量等同于C++中的对象指针<br>C++对象拷贝可以在类的内部进行，但Java只能通过clone方法。</p></li><li><p>访问器方法和更改器方法<br>Java更改器方法会修改类的对象状态，如set方法，而访问器方法不改变当前对象，如get方法。<br>C++中访问器方法有const后缀，而java中没有语法区别。</p></li><li><p>date<br>jdk8引入了LocalDate类，可以操作时间<br>常用api有now(),of(int year,int month,int day),getYear(),getMonthValue(),getDayOfMonth(),<br>getDayOfWeek(),plusDays(),minusDays(),进一步用法在卷2里有。</p></li></ol><h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><p>C++构造器可以省略new关键字正常运行，但Java不可以</p><p>C++可以在类的外部定义方法，在类内部定义的方法自动成为内联方法（直接用方法体替换方法调用<br>代码的操作为内联），Java方法是否内联需要由jvm决定，需要内联时首先方法必须为final修饰，<br>即时编译器才会判断是否需要内联。</p><p>LocalDate没有更改器方法，无法改变对象状态，Date有一个setTime方法，可以改变对象状态，<br>实际上破坏了对象的封装性。如get方法返回Date对象，实际上可以拿到这个date引用对原对象状态<br>进行改变从而带来危险。<br>所以，访问器方法应避免返回一个可变对象的引用，若无法避免，应当clone后再返回，从而保护<br>原对象的封装性。<br>注：java.time.LocalDate是一个不可变的，线程安全的类。</p><p>基于类的访问权限<br>一个类的方法可以访问所属类的所有对象的私有属性，这在C++中同样适用。</p><p>私有方法<br>如果不想自己的方法被他人调用，应当将方法设置为private,这样当以后删除该方法时就不用担心<br>有其他地方调用该方法了。</p><h3 id="静态域与静态方法"><a href="#静态域与静态方法" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h3><p>静态域<br>private static修饰一个域时，它也被称为类域，可以修改,但该域无法被其他类访问到(private)，<br>用public static final修饰常量时，因为常量不可变（final控制），所以可以用public修饰供其他<br>类使用，同时不用担心封装性被破坏。</p><p>注：private限制的是访问范围，static限制的是类变量-无需实例化即可使用。</p><p>静态方法<br>静态方法可以认为是没有this参数的方法，有2种情况使用它</p><ol><li>不需要对象状态，只需要显式参数。</li><li>只需要访问静态域的方法。<br>注： C++使用::访问自身作用域之外的静态域和静态方法。<br>C++与java中static关键字的意义是一样的：即属于类且不属于类对象的变量与函数。</li></ol><p>静态工厂优点</p><ol><li>因为构造器必须与类名相同，静态工厂不受此限制，相当于带名字的构造器。</li><li>构造器没有返回值，它构造的对象类型就是当前类，静态工厂可以构造当前类的子类对象返回，<br>更加灵活。</li></ol><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p>值传递 call by value<br>引用传递 call by reference<br>java只有值传递，针对基本数据类型很好理解，被传的参数值无法被改变;针对对象引用类型，java<br>会拷贝一份该对象的引用，该引用和原参数对象引用指向同一个对象，改变其中一个另外一个引用也受到<br>了影响，从而实现了改变对象的目的。</p><p>证明java是值传递-即拷贝了引用的值，而不是引用传递-传递对象地址的是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">  public void main(String[] args)&#123;</span><br><span class="line">    P a = new P(1);</span><br><span class="line">    P b = new P(2);</span><br><span class="line">    swap(a,b);     </span><br><span class="line">     //执行可以发现swap没有生效，因为swap内交换了拷贝的引用，对原来的a,b对象引用无影响</span><br><span class="line">    System.out.println(a.getId());</span><br><span class="line">    System.out.println(b.getId());</span><br><span class="line">  &#125;  </span><br><span class="line">  public static void swap(P x, P y)&#123;</span><br><span class="line">     P tmp = x;</span><br><span class="line">     x = y;</span><br><span class="line">     y = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class P&#123;</span><br><span class="line">  private int id;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这个程序可以总结出下面这个关键的结论：<br><strong>一个java方法不能让参数对象指向一个新的引用，它在方法内始终是以拷贝的形式存在的。</strong></p><p>这一点从以下代码片段看的更清楚：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">  public void main(String[] args)&#123;</span><br><span class="line">    P a = new P(1);</span><br><span class="line">    newP(a);</span><br><span class="line">    System.out.println(a.getId());  //还是打印1</span><br><span class="line">  &#125;  </span><br><span class="line">  public static void newP(P x)&#123;</span><br><span class="line">    x = new P(888);    // 对传递进来的a对象无影响</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class P&#123;</span><br><span class="line">  private int id;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>方法无法改变基本类型的参数对象。</li><li>方法可以改变引用类型对象的状态。</li><li>方法无法将引用类型参数对象指向一个新的引用。</li></ol><p>注：C++有值传递和引用传递，引用参数使用&amp;来进行标识。</p><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><p>重载<br>方法签名不能重复，它包括方法名和参数类型，返回值不是签名的一部分</p><p>域初始化<br>java可以直接初始化各个域，C++不行，C++只能在构造器中对域进行设值，但它有特殊语法连续调用<br>多个构造器。</p><p>参数名<br>C++通常对实例域加上特定的前缀<code>_</code>,x,m等，java没有。</p><p>调用另一个构造器<br>java可以使用this(…)来调用另一个构造器,这样可以使得公共构造器编写一次即可。<br>C++无法进行构造器间调用,必须将公共部分编写成一个独立的方法。</p><p>构造器执行顺序</p><ol><li>所有域被初始化成默认值。</li><li>按照声明顺序依次执行域初始化语句和初始化块。</li><li>如果第一行调用了其他构造器，执行其他构造器。</li><li>执行接下来的构造器主体。</li></ol><p>注：jdk 6以前可以使用静态初始化块来打印hello world，jdk7以后则会先检查是否有main方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line"> static &#123;</span><br><span class="line">  System.out.println(&quot;hello world&quot;); //类第一次加载的时候会进行静态域的初始化</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++有显式的析构器方法，Java因为有自动垃圾回收机制，所以不需要手动回收内存。<br>finalize方法会在垃圾回收器清除对象前被调用，但无法确定时间,所以不推荐使用它。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包名层级通常是域名的倒序。以前没有注意过这一点，这样我写的代码包应为cn.taoblog</p><p>一个类可以使用所属包中的其他类和其他包中的公有类。<br>由此可知，同私有方法一样，如果不想外界调用该类，可以将其设置为私有类，仅供同包的其他类使用。<br>这种情况该私有类一般作为内部类。</p><p>静态导入<br>import是导入一个类，import static可以导入静态方法和静态域，如使用<br><code>import static java.lang.System.*</code>之后可以将<br><code>System.out.println(...)</code>直接写为<code>out.println(...)</code></p><p>不过实际这样写不好理解，可以针对特定类使用，如<br><code>sqrt(pow(x,2) + pow(y,2))</code>比<br><code>Math.sqrt(Math.pow(x,2) + Math.pow(y,2))</code>要清晰很多。</p><p>编译器不会检查目录结构，即如果package声明错误，如果该类没有依赖其他包，编译不会报错，<br>程序可以正常执行…<br>(经实际测试，比如一个在目录com.demo下的类Test，如果包声明为com,编译后可以发现它的class<br>文件是出现在target/com目录下的。同样的javac命令指定-d选项时它也是根据包声明来生成字节码<br>文件目录的(如javac -d . Test.java)，这样如果Test类中需要引用com.demo包下的其他类时，<br>同样需要import语句，这就违反了目录和包的一致性，造成程序理解困难和隐藏问题，<br>所以包声明报错虽然不影响程序编译和运行，但可能会需要不必要的import和其他潜在问题)</p><p>类或域如果没有public，private修饰，默认是同一个包内的方法可以访问到（default).<br>而默认情况下，包是可见的，即任何人都可以向一个包中添加更多的类，如在自定义的类中修改<br>package声明，并将该类放置在对应目录下即可访问目标包中的其他类。</p><p>jdk本身由于修改了类加载器，禁止加载用户自定义的，包名以java.开始的包来达到安全防范的目的，<br>但用户自己的包没有这个特性，不过可以通过包密封(package sealing)机制来解决这个问题。<br>包被密封之后，就不能再向这个包中添加类了。<br>(经实际测试，自定义一个包java.mypack,实例化其中的类编译成功，运行报错<br>java.lang.SecurityException: Prohibited package name: java.mypack,<br>说明了自定义包不能以java开头)</p><p>可以使用jdk自带的jar工具来生成自己需要的jar包。可以使用如下命令来指定Manifest文件：<br>先新建一个名为manifest.txt的文件，内容可以为<br><code>Sealed: true</code> // 需要一个回车才能生效<br>然后执行命令<br><code>jar cvfm  XXX.jar .\manifest.txt .</code>(可以查看jar –help)</p><p>而jar包是否密封可以通过Manifest中的<code>Sealed: true</code>进行配置，可以指定多个包或整个jar包<br>进行密封，如果包密封后发现有相同包在不同类中的情况出现，会抛出sealing violation异常。<br>主要有以下2种情况：</p><p>(在URLClassLoader类的源码中可以看见)</p><ol><li>尝试加载一个已经被密封的包,报错sealing violation: package is sealed.</li><li>尝试密封一个已经被加载的包，触发安全异常，报错sealing violation: already loaded.</li></ol><p>这样，包密封增强了版本的一致性和安全性。<br>(查看spring和mybatis的jar包可以发现它们都没有进行包密封，应该是开源的原因，不过目前都是<br>统一由maven或gradle统一管理jar包，也不用担心这个问题，自己的项目产品还是应注意这个问题。)</p><p><a href="https://dev.tencent.com/u/wutaotao/p/mybatis-demo/git/tree/master/self-stuff/src/main/java/com" target="_blank" rel="noopener"><strong>密封性测试代码地址</strong></a></p><p>测试时先将Test1,Test2打成jar包(注意检查生成的jar包的包目录结构和MANIFEST.MF文件内容)，<br>然后注释掉相应代码，运行TestSealException类来进行测试，因为类加载后无法卸载，所有需要<br>一个个案例单独测试。<br>结论在代码中已指出：</p><ol><li>sealing violation: package is sealed.</li><li>sealing violation: already loaded.</li><li>sealed package不包括被密封的父类包</li><li>sealed package不包括被密封的子类包</li></ol><p>关于jar和包密封性在javacore version10的第13章，书中说第9章，也算一个小错误。</p><h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><p>类路径是所有包含类的路径的集合。<br>windows中用;分隔，unix下中用:分隔。<br>(刚学java时配置环境变量我们被要求配置classpath变量(这是不好的行为)，其值类似为<br><code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code>，其中.代表当前目录，默认的类路径中包含了<br>当前目录，如果自定义的类路径中少了.,会导致类编译通过，运行失败，具体测试如下：<br>使用javac命令进行编译时注意包结构，如以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javac .\com\demo\Test.java</span><br><span class="line">java com.demo.Test   //测试成功</span><br><span class="line">java -classpath %JAVA_HOME%\lib com.demo.Test   //运行失败，报错找不到或无法加载主类Test</span><br><span class="line">java -classpath %JAVA_HOME%\lib;. com.demo.Test   //加上当前目录后运行成功</span><br></pre></td></tr></table></figure></p><p>)<br>虚拟机搜寻一个类时，首先查看jdk自带的lib中是否包含，若未找到，再根据类路径进行逐个查找。</p><p>注：java -jar运行jar包时会屏蔽环境变量和命令行中的classpath，可以使用下列方法来引用其他的<br>jar包：</p><ol><li>-Xbootclasspath/a: 后缀。将classpath添加在核心class搜索路径后面。常用!!</li><li>在jar包内的MANIFEST.MF文件中添加<code>Class-Path: XXX.jar</code>,路径为该jar包对当前jar包的<br>相对路径。</li></ol><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>只需要对公有域(静态常量)建立注释<br>生成javadoc文档<br><code>javadoc -d D:\javadoc\ com.demo</code><br>若想生成的文档详细，文档注释需要很详细</p><h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ol><li>保证数据私有<br>即不要破坏封装性，如访问器方法返回一个可变对象显然不行，应clone后再返回。</li><li>明确初始化数据</li><li>不要使用过多基本类型<br>可以将部分域分离为另外一个类，实现类的单一职责和灵活性</li><li>不是所有域都需要get和set方法</li><li>职责过多的类分解<br>同3</li><li>类名和方法名要体现职责<br>命名明确</li><li>优先使用不可变的类<br>同1保护封装性原则</li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>is-a关系是继承的一个明显特征。<br>注： java中所有继承都是共有继承，没有C++中的私有继承和保护继承。</p><p>子类虽然继承了父类的域和方法，但由于域的私有性，子类中不能直接访问这些域，所以它需要通过<br>访问器来访问这些域，如调用<code>super.getId()</code>来获取。<br>注：C++中使用父类名::方法名来获取父类域的值，如<code>Parent::getId</code>.</p><p>同样的，子类的构造器也无法直接访问这些私有的父类域，所以需要通过如<code>super(id,name)</code>调用<br>父类的构造器来对这些域进行初始化。<br>注： 调用其他构造器的语句必须是第一条语句，如<code>this(xxx,xxx)</code>,<code>super(xxx,xxx)</code>.</p><p>如果没有这样显式的调用父类构造器时，默认调用父类的无参构造器，如找不到编译器会报错。<br>注：C++不使用super调用父类构造器，它使用初始化列表，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manager::Manager(String name,int salary)</span><br><span class="line">: Employee(name, salary)</span><br><span class="line">&#123;</span><br><span class="line">  bonus = 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注： 经测试，子类会继承父类实现的接口，如父类实现了记号接口RandomAccess,子类对象使用<br>instanceof关键字可以测试出子类也实现了RandomAccess接口。另外，子类中与父类的同名属性<br>不会覆盖父类的属性，它们可以拥有不同的值。</p><p>多态： 一个变量可以指示多种实际类型的现象叫多态。<br>动态绑定： 运行时能自动选择调用哪个方法的现象叫动态绑定。<br>注： java中动态绑定是默认行为，不用声明为虚拟方法(C++中需要),可以声明为final来取消虚拟特征。</p><p>子类和父类数组转换问题<br>有如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">&#125; </span><br><span class="line">class Child extend Parent&#123;</span><br><span class="line">&#125; </span><br><span class="line">public class Test &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">     </span><br><span class="line">   Child[] cs = new Child[];</span><br><span class="line">   Parent[] ps = cs;   // 子类元素数组向上转型为父类元素</span><br><span class="line">   ps[0] = new Parent();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上代码编译成功，但运行时报错java.lang.ArrayStoreException,因为ps[0]和cs[0]指向的是<br>同一个对象，ps[0] = new Parent()就相当于cs[0] = new Parent(),父类转化为子类，从而引起<br>了数组存储异常。因编译器无法检查出这个问题，所以当使用数组时，需要牢记它的元素类型，只<br>向其中存储能够转化为该元素类型的元素。</p><p>对象调用过程x.f(args)</p><ol><li>查找对象x类型和方法名f</li><li>重载解析(子类重写方法返回值可以为父类方法的子类型，称为具有可协变的返回值类型，同时<br>重写的子类方法的可见性(public,private等)不能低于父类方法.</li></ol><p>经测试，父类私有(private)的方法不能被重写(破坏了封装性),其他default,protected,public可以<br>被重写，如果子类的可见性更低，如父类是protected,子类是private,那么根据替换原则(子类可以替代<br>所有父类对象出现的地方)子类可见性更低可能会导致原代码无法访问的情况，所以重写的方法需要<br>可见性更强来避免这个问题，这种情况编译器会报错：attempting to assign weaker access privileges.)<br>这样看，public access privilege is strongest.</p><ol start="3"><li>如果方法是private, static,final修饰或构造器，则编译器可以准确找到需要调用的方法，这<br>称为静态绑定，相反，调用方法依赖于对象x的实际类型称为动态绑定(多态)。</li><li>动态绑定时，会从最接近x实际类型的方法开始匹配，如子类无该方法，会在它的父类去查找，<br>依次类推。</li></ol><p>为了加快方法查找过程，虚拟机会为每个类生成一个方法表，列出它的所有方法(包含继承自父类的<br>方法)。即在查找需要调用的方法时，虚拟机根据实际对象类型调出对应类的方法表，在该表中查找<br>对应的方法并进行调用即可。</p><p>阻止继承：final类<br>使用final修饰的类无法被继承(public final class A{}),<br>使用final修饰的方法无法被重写(public final void B(){}),<br>由于final类无法被继承，它里面的方法都是final方法，没有子类，没有重写,final修饰符不用<br>写明。但是它的域没有自动变为final，实例化后还是可以改变值的。<br>(经测试，声明域为final后，编译器会检查是否有赋予初始值，可以在域声明后赋予初始值，也可以<br>在无参构造器中赋值，只在有参构造器中赋值无效，同时如果有对该域的set方法存在，编译器同样<br>会报错: cannot assign value to final variable)</p><p>注：C++和C#中，所有方法默认都没有多态性，相当于默认全都加了final修饰，无法被重写。</p><p>早期的时候，使用final修饰一个方法，编译器检测到该方法没有被覆盖并且很简短，编译器就会对它<br>进行内联处理。<br>现在即时编译器处理能力强很多，如果方法简短，频繁被调用并且没有被覆盖，它会自动进行内联处理，<br>如果虚拟机加载了另一个类，它有覆盖该内联的方法，虚拟机又会取消内联。</p><p>向下转型<br>父类对象可以强制转换为子类对象，如果转换不成功，会抛出ClassCastException.<br>应养成判断的习惯(if xxx instanceof yyy)<br>另外，如果强转类型不是子类，编译器会报错。<br>注： null instanceof XXX 是false,不会产生空指针异常<br>注2： 如果碰到需要强制转型的情况，应考虑父类的设计是否合理。<br>注3： 强制转型类似于C++中的<code>dynamic_cast</code>操作，只是如果转换失败，它不会抛出异常，而是生成<br>一个null对象。类型测试和转换代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child* ch = dynamic_cast&lt;Parent*&gt;(pa);</span><br><span class="line">if (ch != null) &#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>抽象类<br>有一个或多个抽象方法的类必须被声明为抽象类。<br>反过来，抽象类中可以没有抽象方法。<br>抽象类无法被实例化，但可以作为变量引用非抽象子类的实例。<br>注：C++中用尾部 = 0的方式来标记一个抽象方法，称为纯虚函数。<br>有纯虚函数即为抽象类，C++中没有抽象类的关键字。</p><p>受保护访问<br>protected访问范围是所有子类以及同包的其他类，这与C++的保护机制不同。<br>protected域由于可以被子类直接访问到，变动父类时需要通知子类，违反了封装性。protected方法<br>适用性强一点。</p><p>Object<br>Object是所有类的超类，包括基本数据类型和引用类型的数组！如<code>Object obj = new int[3];</code><br>只有基本类型(数值，字符，布尔)不是对象——通过自动装箱技术它们会转成对应的包装类。<br>注：C++没有超类，但指针都可以转成<code>void*</code>.</p><p>equals方法<br>Object的equals方法只有一句<code>return this==obj</code>,它只比较2个对象的地址。<br>如果想要调用this或obj的equals方法进行自定义比较，可以使用<code>java.util.Objects</code>(jdk7引入)的<br>equals方法<code>return （a == b) || (a != null &amp;&amp; a.equals(b))</code>.</p><p>(经测试，如Child类继承Parent类，则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child ch = new Child();</span><br><span class="line">if (ch instanceof Parent) &#123;...&#125;  // 表达式为true</span><br></pre></td></tr></table></figure></p><p>即instanceof是检测对象是否是后者的实例或子类实例，在equals方法中检验2个对象的类型是否相同，<br>以前是使用instanceof来进行检验，但根据equals要求的对称性(x.equals(y)与y.equals(x)结果相同)<br>, 当parent.equals(child)为真时，child.equals(parent)也为真，这样就使得Child类中的equals方法<br>无法对Child类扩展的域进行检验的问题，这个问题本质还是出在instanceof关键字允许子类也为真的<br>情况上。<br>针对这个问题，有2种情况，一个是子类的扩展域不影响相等性，即不进入比较的话，可以使用<br>instanceof关键字，另一个是如果扩展域也需要比较的话，就不能使用instanceof关键字，可以使用<br>getClass()来明确指定类必须相同;所以如果一个类的equals方法使用了instanceof关键字，那么<br>它的子类重写equals方法就几乎没有意义了，因为如果它比较了扩展域，就违反了对称性原则，所以<br>一般应该将instanceof与final修饰符配合使用，反之则使用getClass()方法)</p><p>注：该问题具体案例可见jdk源码中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类： java.util.Date  其中的equals(Object obj)方法使用了instanceof</span><br><span class="line">子类： java.sql.Timestamp  其中equals(Object obj)方法中注释指明了这一点</span><br><span class="line">&quot;Note: This method is not symmetric with respect to the equals method in the base class&quot;</span><br></pre></td></tr></table></figure></p><p>注：equals方法应满足自反性，对称性，传递性，一致性。</p><p>完美equals方法建议:方法签名为equals(Object otherObject)</p><ol><li>if (this == otherObject) return true; 是否是同一个对象</li><li>if (otherObject == null) return false; 是否为null</li><li>if (getClass() != otherObject.getClass()) return false; // 不用instanceof<br>或 if(!(otherObject instanceof  ClassName)) return false;<br>// 建议方法更改为final，final可以与@Override共存</li><li>若使用了instanceof，将其强制转换类型</li><li>return 各个域的比较结果，基本类型使用==，引用类型使用java.util.Objects的equals方法，<br>它可以进行null值判断和调用域自身的equals方法，数组类型使用Arrays.equals方法。</li></ol><p>hashCode方法<br>Object的hashCode方法默认是对象的存储地址。<br>一般来说：</p><ol><li>将对象放入容器中，需要重写equals方法，可以通过比较对象内容来进行判定业务上对象相等。</li><li>将对象放入散列表中(如HashMap,HashSet等),需要重写hashCode方法，以保证equals相等的2个<br>对象在散列表中对应着同一个键！</li><li>将对象放入有序列表中，需要实现Comparable接口，重写compareTo(T o)方法，或者自定义一个外部<br>比较器Comparator,重写compare(T o1, T o2)方法。</li></ol><p>针对多个域的hashCode计算可以调用java.util.Objects.hashCode(Object… values)方法，其中有<br>对null值的处理。<br>如上面总结的一样，equals方法返回true时，hashCode方法也必须返回true.<br>具体表现为equals处理的域必须出现在hashCode方法中。<br>注： 数组类型的域可以使用Arrays.hashCode方法。</p><p>toString方法<br>查看Object的toString源码可见toString方法为<br><code>return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</code><br>可以看出对象默认输出的是类名+哈希码的16进制表示，数组也是Object类型，<br>只不过它前面的类名比较特别，如[I表示的是整型数组，[Lcom.demo.Test;@XXX表示的是对象Test数组</p><p>泛型数组列表-ArrayList<br>java5以后提供了泛型，使用时可以省略右边的泛型参数<br><code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(100);</code><br>ArrayList默认大小是10。<br>注：arraylist类似于C++中的vector,vector可以使用[]来访问元素，因为它重载了[]运算符，<br>另外vector a = b;语句会重新拷贝一个vector赋给a,而ArrayList a = b;只是让a,b指向同一个<br>引用。</p><p>arraylist使用add,set,get方法来对元素进行控制，某些情况下转换成数组更加方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;P&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(new P(1));</span><br><span class="line">list.add(new P(2));</span><br><span class="line"></span><br><span class="line">P[] pa = new P[list.size()];</span><br><span class="line">list.toArray(pa);</span><br></pre></td></tr></table></figure></p><p>泛型仅在编译时有效，编译成的字节码中没有任何泛型参数，即类型擦除。<br>这个特性会造成以下问题：</p><ol><li>泛型重载无效(编译报错)，</li><li>泛型类中静态域共享(不同泛型类对应同一个类),</li><li>捕捉异常catch语句内泛型参数无效(java运行时处理异常)</li></ol><p>自动装箱<br>所有的对象包装器类都是不可变，无法继承(final)的。<br>通过反编译代码<code>Integer a = 100</code>编译后的字节码，可以发现对于自动装箱，编译器会自动调用<br><code>Integer.valueOf(100)</code>方法，同理自动调用<code>i.intValue()</code>方法。<br>即自动装箱和泛型参数一样，属于编译器层面的操作，与虚拟机无关，可以看作语法糖。</p><p>自动装箱规范要求boolean,byte,char&lt;=127, short and int between -128 to 127这之间的数值<br>被包装到固定的对象中，所有有以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 100;</span><br><span class="line">Integer b = 100;</span><br><span class="line">Integer c = 1000;</span><br><span class="line">Integer d = 1000;</span><br><span class="line">System.out.println(a == b); // true: same wrapping objects</span><br><span class="line">System.out.println(c == d);  // false: different wrapping objects</span><br><span class="line">Character e = (char)128;</span><br><span class="line">Character f = (char)128;</span><br><span class="line">System.out.println(e == f);  // false: different wrapping objects</span><br><span class="line">Character g = (char)127;</span><br><span class="line">Character h = (char)127;</span><br><span class="line">System.out.println(g == h); // true: same wrapping objects</span><br></pre></td></tr></table></figure></p><p>自动装箱在运算符中也能自动进行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 10;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure></p><p>包装器内还包含了如<code>int i = Integer.parseInt(string)</code>这样对于不同类型间转换的静态方法。</p><p>注：包装器是不可变的，所以方法参数值传递也无法通过包装器对象来改变值，可以使用如IntHolder<br>类（jdk自带）来变更基本类型的值，它的域value是public访问权限，这样通过改变参数对象状态来<br>改变基本类型值。</p><p>可变参数<br>可变参数也是编译器层面的语法糖，它将实际传入的多个参数转化为对应的数组。<br>反过来，如果原来代码的最后一个参数是数组类型，就可以将它变为可变参数，这样对生成的字节码<br>文件没有任何变化。如<code>public static void main(String[] args){}</code>可变为<code>public static voidmain(String... args){}</code>.</p><p>枚举<br>枚举也是编译器层面的语法糖，它将枚举类编译成一个继承了Enum类的final类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Size&#123;</span><br><span class="line"></span><br><span class="line">  SMALL(&quot;s&quot;), MEDIUM(&quot;m&quot;), LARGE(&quot;l&quot;); // 调用构造器创建多个枚举实例</span><br><span class="line"></span><br><span class="line">  private String abbr;   // 自定义域</span><br><span class="line">  private Size(String abbr)&#123;//私有构造器</span><br><span class="line">     this.abbr = abbr;</span><br><span class="line">  &#125;  </span><br><span class="line">  public String getAbbr()&#123;return abbr;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译后使用<code>javap Size.class</code>进行反编译可以看到生成的枚举类。<br>上面例子中S,M,L都是Size类的public static final实例，<br>可以使用<code>Size size = Size.S</code>直接得到一个枚举值。<br><code>size.toString()</code>得到枚举常量名，<code>Size s = Enum.valueOf(Size.class, &quot;S&quot;);</code>可以通过字符串<br>得到枚举值。<code>Size.values()</code>返回一个包含所有枚举值的数组，(Enum类中的valueOf与枚举类中参数<br>不同，并且Enum也没有values方法，它们应该是编译器自动添加的),Enum和枚举类都有ordinal()方法<br>返回枚举的索引值，从0开始。compareTo方法比较的即为2个枚举的索引大小。</p><p>反射<br>获取class对象</p><ol><li>object.getClass();</li><li>Class.forName(“XXX”);</li><li>T.class (如Random.class, int.class, Double[].class)<br>Class类实际是一个泛型类，如String.class类型为<code>Class&lt;String&gt;</code>，大多数时候可以忽略这个泛型<br>参数，直接使用原始class类。<br>可以使用==来比较2个class对象是否相同，使用<code>Class.forName(&quot;XXX&quot;).newInstance()</code>来根据字符串<br>调用无参构造器得到一个对象。(调用有参构造器需要Constructor类)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class P&#123;</span><br><span class="line">  private int id;</span><br><span class="line">  public P(int id)&#123;this.id = id;&#125;</span><br><span class="line">  public int getId()&#123;return id;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   Class pc = P.class;</span><br><span class="line">   try&#123;</span><br><span class="line">     Constructor con = pc.getConstructor(int.class);  // 获取构造器，带上参数类型</span><br><span class="line">     P p = con.newInstance(667);  // 调用有参构造器</span><br><span class="line">     System.out.println(p.getId());</span><br><span class="line">   &#125;catch(Exception e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>捕获异常<br>异常分2种，已检查异常(需要使用try-catch捕获)和未检查异常(如空指针等)<br>对于已检查异常，如果没有进行捕获，编译器会报错：unhandled exception.</p><p>利用反射分析类<br>Class类的getFields,getMethods,getConstructors方法返回类提供的公有域，方法，构造器(fields和<br>methods会包含父类的公共域和方法，构造器只会显示本类构造器，另外不会显示未写明的默认无参构造器),<br>getDeclaredFields,…Methods,…Constrcutors方法会返回类声明的所有域，方法和构造器，包括<br>私有和保护成员(它们都只针对本类，不包括父类信息)。<br>(getDeclaredFields如果class是基本类型或数组类型，或者没有任何域，它将返回一个长度为0的数组。)</p><p>Field, Method, Constructor常用方法<br>all.getName(),<br>F.getType(),<br>M&amp;C.getParameterTypes(),<br>M.getReturnType(),<br>all.getModifiers()    // 返回int值以指示修饰符</p><p>注：使用Modifier.toString(int i)可以获得修饰符的字符串表示。<br>Modifier.isFinal(int i)可以判断修饰符是否是final，其他方法同理。</p><p>利用反射分析对象<br>对于编译时无法确定域值的对象(如外界传递过来的参数对象)可以利用反射得到它的域值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line"> private int bonus;</span><br><span class="line"> public C(int bonus) &#123;this.bonus = bonus;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">   C c = new C(1000);</span><br><span class="line">   Field[] fields = c.getDeclaredFields();</span><br><span class="line">   for(Field f : fields) &#123;</span><br><span class="line">     System.out.println(f.get(c)); //编译器报错unhandled exception:IllegalAccessException</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为bonus是私有的，所以无法直接访问，即反射受到访问权限限制。<br>这时需要调用Field,Method,Constructor共同父类AccessibleObject中的一个方法<br><code>setAccessible(true)</code><br>来解除限制。这里f.get(c)返回的是object类型，进行了自动装箱，如果想返回int，<br>可以使用getInt()方法，同理getDouble()等。</p><p>ObjectAnalyzer程序分析：<br>class.isArray()  判断class类型是否是数组<br>class.isPrimitive()   判断class类型是否是基本类型：<br>   boolean,character,byte,short,integer,long,float,double,void(java.lang.Void)<br>class.getComponentType()  返回数组元素类型，如果不是数组class返回null</p><p>Array.getLength()   java.reflect.Array类中的方法，返回数组长度<br>Array.get(Object, int) java.reflect.Array类中的方法，返回数组中第i个元素值<br>AccessibleObject.setAccessible(AccessibleObject[], boolean) 对AccessibleObject数组统一赋予<br>   访问权限，其子类包括Constructor, Field, Method<br>Modifier.isStatic()  判断是否是static修饰符，程序中不打印静态域<br>field.getType()  获取域类型，程序中判断是否是基本类型<br>field.get(Object) 获取域的值对象<br>field.set(Object classObj, Object newvalue)  使用新值替换object中的当前域</p><p>class.getSuperclass()  获取当前class类的父类 </p><p>注：程序执行是先打印本类的非静态域类型和值，然后是逐层向上，查看父类的非静态域值，所以可以<br>看到每个类后都至少有一个<code>[]</code>(因为java.lang.Object类无域);<br>同时可以看到它把ArrayList的初始值10个后面未用到的null值元素都打印出来了;<br>实现循环引用很简单，在类中定义一个自身的实例指向this即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line"> private C c = this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用反射编写泛型数组<br>使用<code>System.arrayCopy(oldArray, startIdx, newArray, startIdx, length)</code>来扩充数组时，在编写<br>泛型化时，由于Object[]无法强转为具体的数组类型，所以需要通过java.reflect.Array来获取具体的<br>数组元素类型并进行初始化，主要用到以下三个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class.isArray()  判断class类型是否是数组</span><br><span class="line">class.getComponentType()  返回数组元素类型，如果不是数组class返回null</span><br><span class="line">Array.getLength()   java.reflect.Array类中的方法，返回数组长度</span><br><span class="line">Array.newInstance(Class componentType, int length)  元素类型和数组长度(一维) </span><br><span class="line">Array.newInstance(Class componentType, int... dimensions)  元素类型和数组长度(多维)</span><br></pre></td></tr></table></figure></p><p>newInstance方法可以让我们动态的创建一个与原数组相同类型的空数组，这样再使用System.arrayCopy()<br>方法即可以获得一个可以进行强转的数组了。<br>(基本类型数组拷贝需要方法的参数和返回值为Object,因为如int[]可以转成Object,无法转成Object[]，<br>反过来这样Object也可以强转为int[])</p><p>方法指针<br>可以通过<br><code>class.getMethod(String methodName, Class... parameterTypes)</code><br>指定方法名和参数类型列表(完整方法签名区别重载)来获得方法指针，再通过<br><code>method.invoke(Object implicitObject, Object... parameters)</code><br>指定调用的隐式和显式参数来调用该方法。<br>通过invoke方法进行回调比直接调用速度要慢一些，所以一般不推荐使用，建议使用接口或lambda表达式。</p><p>继承设计技巧</p><ol><li>公共操作和域放在超类中</li><li><p>不要使用protected域<br>protected域子类和同包类都能访问，破坏了封装性。<br>protected方法适用于不能作为公共public接口，同时需要在子类中重新定义的方法<br>(default只有同包可见，经测试在其他包中定义的子类无法重写父类方法，同理父类private方法<br>子类不可见，也不可重写，由此可见，是否能重写受到被重写方法能否被子类访问的限制，不一定<br>是这个原因，但可以这样记忆)。</p><p>注：static是静态绑定，重写多态是动态绑定，运行时确定，所以static方法不能被重写。</p></li><li><p>继承是is-a关系，不是的情况应不使用继承。</p></li><li>除非继承的所有方法都有意义，否则就不应使用继承。 </li><li>覆盖方法时不要偏离该方法最初的设计目的，预期行为。 </li><li>如果代码有对于不同类型的判断并进行相同概念的行为，应使用多态或接口实现。</li><li>不要过多使用反射，因为编译器难以发现错误。</li></ol><h2 id="接口，lambda表达式，内部类"><a href="#接口，lambda表达式，内部类" class="headerlink" title="接口，lambda表达式，内部类"></a>接口，lambda表达式，内部类</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口中的方法默认public，public可省略，所以重写接口方法时必须为public(重写访问限制)<br>接口没有实例域，<br>jdk8之后可以实现简单方法。</p><p>如实现<code>Comparable&lt;T&gt;</code>接口，重写compareTo(T t)方法。<br>因为Arrays.sort(Object[] obj)源码实现中进行了Comparable强转并使用compareTo方法，<br>所以如果obj中元素类型没有实现Comparable接口，会在运行中报错ClassCastException，而关于这点，<br>编译器并不会给出报错信息。<br>注：compareTo方法与equals方法一样，关于继承重写有对称性的问题(x.compareTo(y) &lt; 0则<br>y.compareTo(x) &gt; 0)，解决方法也类似，分2种情况：</p><ol><li>比较时涉及到子类属性时，应使用getClass()方法进行类型判断，类型相同才进行比较，否则抛出<br>类型转换异常。</li><li>比较时不涉及子类的属性，应在父类中定义compareTo方法并定义为final.<br>(经测试情况2,父类实现了泛型的Comparable接口，子类就不能实现自己的泛型类型了，编译器报错(XXX<br>interface cannot be inherited with different type arguments)，因为子类会继承父类的接口类型。<br>这样在对子类数组进行排序后，虽然实现了排序，但其中的元素都自动向上转型为父类类型了…)</li></ol><p>接口特性<br>同抽象类一样，不能使用new运算符实例化一个接口。<br>同抽象类一样，可以声明接口变量，指向接口的实现类。<br>可以使用instanceof关键字判断一个对象是否实现了某一个接口，如<code>obj instanceof Comparable</code>.<br>接口中的方法默认public,接口中的域默认public static final,<br>实现了接口的类自动继承了接口中的常量，可以直接使用如NORTH,而不用使用TestInterface.NORTH。</p><p>接口和抽象类的区别</p><ol><li>方法实现：抽象类可以有方法实现，作为普通方法可以被子类继承，接口在jdk1.8以后可以定义<br>默认方法和静态方法，在这一点上两者相同。</li><li>继承或实现：抽象类使用extends来继承抽象类，子类如果不是抽象类，需要实现父类的所有抽象<br>方法;接口使用implements实现接口，需要实现类实现所有抽象方法。</li><li>构造器：抽象类可以有构造器，接口不能有(定义时报错abstract method cannot have body)</li><li>访问修饰符：抽象类没有限制，接口方法默认public,无法修改。</li><li>main方法： 抽象类有，接口没有</li><li>多继承： 抽象类只能继承一个类，接口可以继承多个接口</li><li>添加新方法： 抽象类添加了新方法，如果有具体实现，不影响子类，同理接口的默认方法也不影响。<br>如果添加的是抽象方法，抽象类的子类和接口实现类都需要提供该方法的具体实现。</li></ol><p>注： C++支持多继承，带来了很多复杂特性，也很少被使用。</p><p>静态方法<br>jdk8中接口可以定义静态方法，以前静态方法通常是放在伴生类中，如Collection/Collections,<br>Path/Paths，jdk8以后可以合并到接口中。</p><p>默认方法<br>jdk8后接口可以使用default关键字定义默认方法。<br>定义了默认方法后实现类就可以不必强制实现这些默认方法了，同抽象类一样，可以让某些方法提供<br>默认行为，从而实现类无需管理。<br>默认方法可以调用任何其他方法，包括抽象方法。</p><p>接口演化(interface evolution): 指接口新增了一个抽象方法，遗留的类重新编译会由于没有实现<br>该方法而产生编译错误，如果不重新编译(如使用jar包),在遗留类的实例上调用该新增方法将抛出异常，<br>默认方法即解决了这个问题。重新编译时遗留类不必实现默认方法，调用新方法时也会直接调用接口的<br>方法。</p><p>解决默认方法冲突<br>一个接口定义了一个默认方法，又在超类或另一个接口中定义了同样的方法，会发生什么？<br>1.超类优先。超类方法会覆盖所有同名同参数类型的默认方法。<br>2.接口冲突。实现类实现了2个接口，这2个接口都实现了相同的方法，编译器报错：<br><code>inherits unrelated defaults for XXX() from I1 and I2</code>,<br>这时首先需要在实现类中重写这个方法，在该方法内可以通过如<code>I1.super.XXX();</code>的方法来调用I1或<br>I2的默认方法。<br>注： 如果相同的默认方法中有一个是抽象方法，实现类编译器也会报错，要求实现该方法，而不是<br>自动使用另一个接口的默认方法。</p><ol start="3"><li>在2中报错是unrelated defaults,如果I2 extends I1,则以I2中的默认方法为准，这样就不存在<br>冲突了，class A implements I1, I2 与 class A implements I2是等价的。此时再调用<br><code>I1.super.XXX()</code>时编译器报错：<code>redundant interface I1 is extended by I2</code></li></ol><p>注：由于类优先的原则，自定义接口并实现equals,toString等默认方法无效果，应在类中重写这些方法。</p><h3 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h3><ol><li>java.swing.Timer定时回调实现了ActionListener接口的类对象</li><li>在无法改变源码或已有compareTo方法的情况下，可以自定义一个实现了Comparator<t>接口的类，<br>T为需要比较的对象类型，实际使用时还需要实例化该比较类(使用lambda表达式更方便)。</t></li><li><p>对象克隆需要实现Cloneable接口,这是一个标记接口，无任何实际作用(唯一作用是可以使用<br>instanceof判断类是否实现了它),对象克隆需要以下几步：</p><ol><li>实现cloneable接口</li><li>重新定义clone方法，修改访问权限为public，返回值为当前类型对象以供外界使用。</li><li>拷贝被克隆对象中是否有可变域，即是需要浅克隆(调用(XXX)super.clone()即可)还是深度克隆<br>(考虑给可变子域也实现clone方法)。</li></ol><p>Object中clone方法为protected的原因:<br>因为Object是所有类的父类，不能保证Object类的<br>子类中所有域都是不可变或是可以克隆的，所以Object中clone方法不是public,而是protected,<br>希望子类能根据自己的情况重写clone方法。</p><p>注：</p><ol><li>所有数组默认可以使用clone方法进行拷贝，经测试对象数组直接调用clone方法为复用对象<br>引用，并没有克隆对象。</li><li>原想可以使用上文中的反射Array.getComponentType(),Array.newInstance(),System.arrayCopy<br>来实现克隆，后来查看了Arrays.copyOf()方法的源码，正是这样的实现思路，测试后发现它<br>仍然是复用引用，即浅拷贝。问题出在System.arrayCopy上，这是一个native方法，它拷贝的结果<br>即为直接复用了对象引用,它的内部实现应该是<code>copy[i] = original[i]</code>。</li><li>同理，ArrayList的clone方法中使用了Arrays.copyOf()方法，同样是浅拷贝。</li><li>由以上可知，想实现对象数组或集合的深拷贝，需要自己遍历数组或集合对每个元素调用clone方法，<br>数组自身clone,Arrays.copyOf,arraylist.clone方法都不能实现这个目的，它们仅适用于基本类型。</li></ol></li></ol><h3 id="λ表达式"><a href="#λ表达式" class="headerlink" title="λ表达式"></a>λ表达式</h3><p>为什么需要λ表达式？<br>在上文的定时器Timer调用ActionEvent接口实现类和排序需要的compare方法中，定义的代码块都是<br>在以后将会被调用的方法，这里都通过实例化一个对象来调用这个方法，比较麻烦，λ表达式<br>以更为简洁的方式来解决这个问题。</p><p>λ表达式原义为带参数的表达式,如(String x, String y) -&gt; x.length() - y.length().<br>如果没有参数，括号也不能省略，如() -&gt; System.out.println(“hello world”).<br>如果参数类型可以推导得出，可以省略参数类型，如<br><code>Comparator&lt;String&gt; comp = (x,y) -&gt; x.length() - y.length();如果方法只有一个参数，且类型可推导，则可省略小括号，如</code>ActionListener listener = event -&gt; System.out.println(“now is “ + new Date());`<br>λ表达式不需要指定返回值类型，它会根据上下文推导得出。</p><p>函数式接口<br>主要是java.lang.FunctionalInterface注解，它本身也是一个记号接口，无任何内容，由其注释可知：<br>一个接口如果只有一个抽象方法(除了java.lang.Object类中的public方法),那么它就是一个函数接口，<br>不管该接口有没有添加FunctionalInterface注解。Comparator接口就只有一个compare方法和equals<br>方法(与Object相同),它就是一个函数接口。因为所有类都继承自Object类，Object public方法全都<br>默认有实现，所以它不计入抽象方法中。</p><p>函数式接口的作用也体现在FunctionalInterface注解的注释中：<br><code>Note that instances of functional interfaces can be created with lambda expression,method references, or constructor references</code>,说明λ表达式，方法引用，构造器引用的使用<br>对象就是这个函数式接口。</p><p>λ表达式的作用就是转化为函数接口，其他语言的函数特性都不支持。<br>java.util.Function包中定义了大量的函数式接口，常用的如Consumer,Predicate,Supplier等。<br>即如果想使用λ表达式，除了已有的之外，可以自定义一个函数式接口来接收λ表达式，加上<br>FunctionalInterface注解。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface OI&#123;        // public无论class, enum, interface，@interface都要求和文件名一致</span><br><span class="line">  int oper(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  print((x,y) -&gt; x + y, 10, 2);  // 调用者通过λ表达式来确定对操作数的操作逻辑</span><br><span class="line">  print((x,y) -&gt; x - y, 10, 2);  // 实现了操作逻辑的动态变化</span><br><span class="line">  print((x,y) -&gt; x * y, 10, 2); </span><br><span class="line">  print((x,y) -&gt; x / y, 10, 2); </span><br><span class="line"> &#125;  </span><br><span class="line"> private static void print(OI o, int x, int y) &#123;   // 操作逻辑，操作数</span><br><span class="line">   //这里进行简单的打印，实际上可以在操作之前和之后进行一些自定义的操作。</span><br><span class="line">   System.out.println(o.oper(x,y));  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即分三步来使用λ表达式：</p><ol><li>自定义函数式接口(jdk自带的可省略)</li><li>定义接收1中接口为参数的方法</li><li>调用2中方法使用λ表达式定义想要实现的操作</li></ol><p>如下调用java.util.functino.predicate函数接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">   print(x -&gt; (Integer)x == 0, 0);  // int类型为Object，需要转为Integer进行比较</span><br><span class="line">   print(x -&gt; (Integer)x - 1 == 0, 2);  // int类型为Object，需要转为Integer进行比较</span><br><span class="line"></span><br><span class="line">   // 调用Arraylist的removeIf方法</span><br><span class="line">   ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">   list.add(2);</span><br><span class="line">   list.add(null);</span><br><span class="line">   list.add(3);</span><br><span class="line">   System.out.println(list.size());  //3</span><br><span class="line">   list.removeIf(e -&gt; e == null);  //这里e的类型为Integer</span><br><span class="line">   System.out.println(list.size());  //2</span><br><span class="line"> &#125;  </span><br><span class="line"> private static void print(Predicate filter, int x) &#123;   // 操作逻辑，操作数</span><br><span class="line">    // 非空判断</span><br><span class="line">    if(filter == null) throw new NullPointerException(&quot;no predicate defined.&quot;);</span><br><span class="line">    if (filter.test(x)) &#123;  //直接调用即可，关注参数和返回值，具体操作逻辑交给调用者</span><br><span class="line">      System.out.println(true);  </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      System.out.println(false);  </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注： 如何在jdk8以前的版本中实现函数式编程？这时无法用λ表达式来传递计算函数，还是使用具体<br>对象来实现，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface Inter&#123;     // 函数式接口不可少，定义操作数和返回值</span><br><span class="line">    int oper(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 传递具体的对象来调用自定义的操作</span><br><span class="line">        f(new InterClass(), 4,5);    </span><br><span class="line">    &#125;</span><br><span class="line">    private static void f(Inter inter, int x, int y) &#123;  // 接收函数表达式的方法</span><br><span class="line">        System.out.println(inter.oper(x,y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class InterClass implements Inter&#123;   // 定义函数接口实现类以符合参数，返回值的约束</span><br><span class="line">    @Override</span><br><span class="line">    public int oper(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，在不使用λ表达式时，需要多定义一个接口实现类和初始化一个实现类对象，此方法适用于<br>jdk8以前需要函数式编程的功能。</p><p>再注： 使用下方的匿名内部类更为简便，函数接口与接受函数接口的方法不变，只不过需要将λ表达式<br>替换为匿名内部类即可，不过需要在其中重写方法，代码没有λ表达式整洁，但它是jdk8前的最佳替代<br>方案了。</p><p>方法引用<br>如果λ表达式定义的处理逻辑已经有某个方法定义了，可以使用该方法来替代λ表达式，即方法引用。<br>方法引用即为简化的λ表达式。</p><p>它分3种情况：</p><ol><li>object.instanceMethod   如System.out::println  out是静态对象，println是实例方法</li><li>Class.staticMethod      如Math::max</li><li>Class.instanceMethod    如String::compareToIgnoreCase,这种情况方法调用者是第一个参数</li></ol><p>注：方法引用相当于λ表达式的简写，最终也是要转化为函数式接口的实例，所以如Math::max出现<br>方法重载时，具体调用哪一个取决于调用方法引用的函数接口使用了什么类型的参数。</p><p>另：由方法引用的作用来看，自定义方法引用适用于某个λ表达式经常被使用到，可以像提取常量一样，<br>将该λ表达式定义为一个具体的方法，然后在接收函数式接口处调用该方法即可。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface OI&lt;T&gt;&#123;        // 使用泛型处理不同类型参数</span><br><span class="line">  T oper(T x, T y);</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   printInteger(Math::max, 3, 5);     // 5</span><br><span class="line">   printDouble(Math::max, 33.2l, 5.3);  // 33.21</span><br><span class="line">   printInteger(Test::ss, 3, 10);      // 19</span><br><span class="line"> &#125;  </span><br><span class="line"> // 这里函数式接口需要指明泛型类型，否则默认Object,编译报错找不到Math.max(Object,Object)</span><br><span class="line"> private static void printInteger(OI&lt;Integer&gt; oi, int x, int y) &#123;   // 操作逻辑，操作数</span><br><span class="line">   System.out.println(oi.oper(x,y));  </span><br><span class="line"> &#125;</span><br><span class="line"> private static void printDouble(OI&lt;Double&gt; oi, double x, double y) &#123;   // 操作逻辑，操作数</span><br><span class="line">   System.out.println(oi.oper(x,y));  </span><br><span class="line"> &#125;</span><br><span class="line"> private static int ss(int x, int y) &#123;</span><br><span class="line">   return (x * x) + y;   //这是一个简单的运算，只有复杂的操作提取才有意义  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在方法引用的第一种情况对象引用中，可以使用this和super关键字。</p><p>构造器引用<br>构造器引用即方法为new的方法引用，快捷调用某个类的构造器。如String::new,本质上说，它还是<br>方法引用，即λ表达式。<br>新建一个对象的λ表达式，这决定了构造器引用的用途不是非常广，只有需要批量初始化的时候(如<br>stream流中)可以简化写法。</p><p>数组也可以使用构造器引用，如int[]::new，这个表达式需要的唯一参数为数组的长度。利用这一点<br>可以让工具类绕过java的限制创建泛型数组，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(2);</span><br><span class="line">        list.add(3);</span><br><span class="line">        list.add(4);</span><br><span class="line"></span><br><span class="line">        // 常见方法，直接创建数组即可，这个例子里也是最快的</span><br><span class="line">        // Integer[] integers = new Integer[list.size()];</span><br><span class="line"></span><br><span class="line">        // 使用数组构造器引用。Function和BiFunction函数接口变量可以接收λ表达式，</span><br><span class="line">        // 通过调用其apply方法将参数应用到表达式中得到计算结果，这里返回值即为需要的数组</span><br><span class="line">        // Function&lt;Integer, Integer[]&gt; function = Integer[]::new;</span><br><span class="line">        // Integer[] integers = function.apply(list.size());</span><br><span class="line"></span><br><span class="line">        // 调用支持泛型方法，传递数组构造器引用，元素类型，数组大小即可。 </span><br><span class="line">        // 这里是大费周张了，但价值在于调用的泛型方法中</span><br><span class="line">        Integer[] integers = newTArray(Integer[]::new, Integer.class, list.size());</span><br><span class="line"></span><br><span class="line">        list.toArray(integers);</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> // 绕过了java不能创建T[]的限制，可以在其中进行需要的通用数组处理。这里创建后就直接返回了</span><br><span class="line">    private static &lt;T&gt; T[] newTArray(Function&lt;Integer, T[]&gt; f, Class T, Integer size) &#123;</span><br><span class="line">        T[] genericArray = f.apply(size);</span><br><span class="line">        //  do something with genericArray</span><br><span class="line">        return genericArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量作用域<br>λ表达式就是闭包。<br>λ表达式实际由3部分组成：</p><ol><li>参数</li><li>表达式代码块</li><li>自由变量——即λ表达式外的变量，既不是参数也不是代码块中定义的变量。</li></ol><p>λ表达式引用的自由变量必须是最终变量(final)或实际上的最终变量(effectively final)。<br>即事实上的final变量。<br>最佳实践： 应将使用到的自由变量都用final修饰。</p><p>因为自由变量如果可以被改变，当λ表达式并发执行时，会产生问题(具体问题卷2有)。</p><p>λ表达式的作用域与它所有的代码块是相同的，即λ表达式的参数和局部变量不能与所在代码块的变量<br>冲突，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 3;</span><br><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x * x; </span><br><span class="line">//error: variable x is already defined in the scope</span><br></pre></td></tr></table></figure></p><p>λ表达式中this是指λ表达式所在方法的所属类，与它的返回值没有关系。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class Test2() &#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">   new Test2().go(1000); </span><br><span class="line">   JOptionPane.showMessageDialog(null, &quot;stop&quot;);</span><br><span class="line">   System.exit(0);</span><br><span class="line"> &#125;</span><br><span class="line"> private void go(int delay)&#123;</span><br><span class="line">  ActionListener listener = e -&gt; &#123;</span><br><span class="line">    System.out.println(this);  // will print com.test.Test2@XXXX  </span><br><span class="line">  &#125;  </span><br><span class="line">  new Timer(delay, listener).start();  // java.swing.Timer</span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>处理λ表达式<br>λ表达式重点在于延后执行(deferred execution),可以控制代码的运行时间，条件，线程等。</p><p>jdk提供了很多函数式接口的模板，可以根据λ表达式的参数和返回值个数和类型直接使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. Runnable       void run()  适合无参数，无返回值的λ表达式，单纯的方法本身与线程无关</span><br><span class="line">2. Supplier&lt;T&gt;    T get()              无参数, 返回T</span><br><span class="line">3. Consumer&lt;T&gt;    void accept(T)       1个参数，无返回</span><br><span class="line">4. BiConsumer&lt;T,U&gt;  void accept(T,U)  2个参数，无返回</span><br><span class="line">5. Function&lt;T,R&gt;      R  apply(T)     1个参数，返回R</span><br><span class="line">6. BiFunction&lt;T,U,R&gt;  R apply(T,U)    2个参数，返回R</span><br><span class="line">下面是上面接口的特例</span><br><span class="line">7. UnaryOperator&lt;T&gt;   T apply(T)   Function&lt;T,T&gt;的子类，参数和返回值是相同类型</span><br><span class="line">8. BinaryOperator&lt;T&gt;  T apply(T,T) BiFunction&lt;T,T,T&gt;的子类，参数和返回值是相同类型</span><br><span class="line">9. Predicate&lt;T&gt;      boolean test(T)   1个参数,返回boolean值</span><br><span class="line">10. BiPredicate&lt;T,U&gt;  boolean test(T,U)  2个参数，返回boolean值</span><br></pre></td></tr></table></figure></p><p>对于基本类型int,long,double,jdk为了省去自动装箱的开销提供了一些专门的函数式接口，如<br>IntConsumer等。<br>这些接口有一些默认方法，提供了如级联调用，返回相同方法等功能。<br>如consumer.andThen(Consumer after)返回的是一个lambda表达式<br><code>(T t) -&gt; {accept(t), after.accept(t);}</code>,<br>该表达式只有一个参数，调用了2个accept方法，无返回值，其本身也是一个Consumer类型，<br>需要执行该表达式时，也是调用其accept方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">   Consumer&lt;Integer&gt; first = System.out::println;  </span><br><span class="line">   Consumer&lt;Integer&gt; second = System.out::println;</span><br><span class="line">   first.andThen(second).accept(666);   // output 666 twice   </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再谈Comparator<br>Comparator是一个常用的比较器和函数式接口。抽象方法为<code>int compare(T o1, T o2);</code>,可以通过<br>多种方式得到自己需要的Comparator比较器，如Person类对象按域name长度排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class TestPerson &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Person[] ps = new Person[]&#123;new Person(&quot;wtt&quot;), new Person(&quot;wttsan&quot;), new Person(&quot;wt&quot;)&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line"></span><br><span class="line">        // 直接自己想要的比较方式，idea会给出提示可以使用comparing</span><br><span class="line">        // Comparator&lt;Person&gt; comparator =</span><br><span class="line">        //         (Person p1, Person p2) -&gt; p1.getName().length() - p2.getName().length();</span><br><span class="line"></span><br><span class="line">        // comparing有多个变体，主要参数为keyextractor,即需要比较的键的function,这里后面</span><br><span class="line">        // 一个参数为键本身的比较器，即字符串长度</span><br><span class="line">        // Comparator&lt;Person&gt; comparator = Comparator.comparing(Person::getName,</span><br><span class="line">        //         (x,y) -&gt; x.length() - y.length());</span><br><span class="line"></span><br><span class="line">        // 最终结果是比较int值大小，可以提取到外面，使用comparingInt,参数为ToIntFunction,</span><br><span class="line">        // 需要传递返回值为int,只有一个参数的function.此方法最为简洁。</span><br><span class="line">        Comparator&lt;Person&gt; comparator = Comparator.comparingInt(p -&gt; p.getName().length());</span><br><span class="line">        Arrays.sort(ps, comparator);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;&#125;</span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同consumer.andThen(Consumer con)一样，Comparator有thenComparing方法实现级联调用，目的是<br>第一个比较器比较结果为相等时可以调用第二个比较器继续比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class TestPerson &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person[] ps = new Person[]&#123;</span><br><span class="line">          new Person(&quot;wtt&quot;, 5), new Person(&quot;wttsan&quot;,1), new Person(&quot;cll&quot;,3)&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line"></span><br><span class="line">        // 第一个p的参数类型Person不可少，应是λ表达式无法推断出来，anyway,最好是</span><br><span class="line">        // 指明参数类型</span><br><span class="line">        Comparator&lt;Person&gt; comparator = Comparator.comparingInt(</span><br><span class="line">         (Person p) -&gt; p.getName().length()).thenComparingInt(p -&gt; p.getId());</span><br><span class="line"></span><br><span class="line">        Arrays.sort(ps, comparator);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int id) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, id=&quot; + id +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果比较的键函数可以返回null,可以使用Comparator.nullsFirst()或nullsLast来对null值进行排序。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>使用内部类的三个原因：</p><ol><li>可以访问类定义所在作用域中的数据，包括私有数据。</li><li>内部类可以对同包的其他类隐藏</li><li>使用匿名内部类可以快捷定义回调函数。<br>注： C++有嵌套类，它只是类之间的关系，对象之间没有关系。命名控制和访问控制同java相似，但<br>java内部类对象有一个指向外部类对象的隐式指针，可以访问其全部状态。静态内部类没有该指针。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class TimerTest&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        TimerClock timerClock = new TimerClock(1000, false);</span><br><span class="line">        timerClock.start();</span><br><span class="line"></span><br><span class="line">        // 当内部类为public时，可以在外界使用outerObject.new InnerClass(xxx)创建内部类对象</span><br><span class="line">        // 使用OuterClass.InnerClass来引用内部类对象</span><br><span class="line">        // 内部类为private时，无法在外界创建对象</span><br><span class="line">        TimerClock.TimePrinter timePrinter = timerClock.new TimePrinter();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TimerClock &#123;</span><br><span class="line">    private int interval;</span><br><span class="line">    private boolean beep;</span><br><span class="line"></span><br><span class="line">    public TimerClock(int interval, boolean beep) &#123;</span><br><span class="line">        this.interval = interval;</span><br><span class="line">        this.beep = beep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">      // 创建内部类对象的规范写法，因为在作用域内，也可以直接new</span><br><span class="line">        ActionListener listener = this.new TimePrinter();</span><br><span class="line">        Timer t = new Timer(interval, listener);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    // 只有内部类可以作为private类，其他类只能为default或public</span><br><span class="line">    public class TimePrinter implements ActionListener &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event) &#123;</span><br><span class="line">            System.out.println(&quot;At the tone, the time is &quot; + new Date());</span><br><span class="line">            // 引用外部类域的规范写法，因为在作用域内，也可以直接写beep</span><br><span class="line">            // 同时，这样写确定了调用的是TimerClock类中的域beep，避免了被同名属性覆盖</span><br><span class="line">            if (TimerClock.this.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">            System.out.println(interval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的程序使用命令<code>javac .\TimerTest.java</code>进行编译后发现生成了3个class文件，<br><code>TimerTest.class, TimerClock.class, TimerClock$TimerPrinter.class</code>文件。<br>最后一个即为定义的内部类，使用命令<code>javap -p &#39;.\TimerClock$TimePrinter.class&#39;</code>进行反编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class com.test.TimerClock$TimePrinter implements java.awt.event.ActionListener &#123;</span><br><span class="line"></span><br><span class="line">  // 内部类自动添加了对外部类的引用域</span><br><span class="line">  final com.test.TimerClock this$0;       </span><br><span class="line">  // 内部类构造器中自动添加了对外部类的引用参数</span><br><span class="line">  public com.test.TimerClock$TimePrinter(com.test.TimerClock);</span><br><span class="line">  public void actionPerformed(java.awt.event.ActionEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此可知，内部类只是编译器层面的语法糖，虚拟机对此一无所知。<br>使用命令<code>javap -p &#39;.\TimerClock.class&#39;</code>查看外部类的反编译代码为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class com.test.TimerClock &#123;</span><br><span class="line">  private int interval;</span><br><span class="line">  private boolean beep;</span><br><span class="line">  public com.test.TimerClock(int, boolean);</span><br><span class="line">  public void start();</span><br><span class="line">  // 自动生成域的访问方法供内部类调用</span><br><span class="line">  static boolean access$000(com.test.TimerClock);</span><br><span class="line">  static int access$100(com.test.TimerClock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到针对内部类访问的2个域生成了对应的2个access方法(如果只访问了一个域只会生成对应的一个<br>access方法),内部类实际上就是通过这个自动生成的方法来访问外部类的私有属性，结合内部类反编译<br>代码，即调用了如<code>TimerClock.access$000(this$0)</code>来得到beep值。</p><p>注：编译生成的access$XXX方法实际上可以被任何同包的类调用,不仅限于内部类。由于access方法是<br>编译器自动生成的，无法在编译前直接调用，所以需要编写虚拟机指令来完成，而且还需要获得对应的<br>TimeClock对象作为方法参数，操作还是有难度的。</p><p>注2: 外部类可以访问内部类的所有成员，包括内部类的私有属性(无需如access方法等附加条件)，<br>这点可以从类包含的关系去理解，也无法解释太多。不过对于下面的局部内部类外部类将无法访问。</p><p>局部内部类<br>局部类是在方法中定义的内部类，它不能用public，private修饰，使用default,它的作用域限定在<br>这个方法中，外部类的其他方法不能访问它，内部类本身仍然可以访问外部类属性。<br>局部类实现了更深层次的封装。<br>将上面程序的TimePrint类移到start方法中，此时不能再使用<code>this.new TimePrint()</code>了，外部类对象<br>不能直接访问局部类。同样编译后再使用javap反编译可得，生成的内部类名字变了，中间变为<code>$1</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class com.test.TimerClock$1TimePrinter implements java.awt.event.ActionListener &#123;</span><br><span class="line">  final com.test.TimerClock this$0;       </span><br><span class="line">  com.test.TimerClock$1TimePrinter(com.test.TimerClock);</span><br><span class="line">  public void actionPerformed(java.awt.event.ActionEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同λ表达式一样，局部类也可以访问作用域内的局部变量，但它必须是final类型的，代码变为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TimerTest&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        TimerClock.start(1000, false);</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TimerClock &#123;</span><br><span class="line"></span><br><span class="line">   public static void start(int interval, boolean beep) &#123;</span><br><span class="line"></span><br><span class="line">     class TimePrinter implements ActionListener &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event) &#123;</span><br><span class="line">            System.out.println(&quot;At the tone, the time is &quot; + new Date());</span><br><span class="line">            if (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">            System.out.println(interval);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ActionListener listener = new TimePrinter();</span><br><span class="line">     Timer t = new Timer(interval, listener);</span><br><span class="line">     t.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令<code>javap &#39;.\TimerClock$1TimePrinter.class&#39;</code>可得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class com.test.TimerClock$1TimePrinter implements java.awt.event.ActionListener &#123;</span><br><span class="line">  final boolean val$beep;</span><br><span class="line">  final int val$interval;</span><br><span class="line">  com.test.TimerClock$1TimePrinter();</span><br><span class="line">  public void actionPerformed(java.awt.event.ActionEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与以上引用外部类域的反编译结果可知，没有引用外部类域后，局部类没有了外部类域的引用this$0,<br>构造器参数也去掉了，同时由于actionPerformed方法需要在start方法结束调用后仍然需要得到beep和<br>interval的值以继续执行，所以在内部类中相应的生成了域val$beep和val$interval来保存局部变量的<br>拷贝值。出于并发的考虑，访问的局部变量需要为final变量，最好是显式的声明出来。</p><p>可以看到，使用局部类极大的简化了代码，同时使用局部变量替代外部类实例域提高了安全性，无需<br>生成不安全的access方法供内部类调用。</p><p>注：如果需要在内部类中改变局部变量的值，可以将该变量封装在一个数组中，这时变量对该数组的<br>引用是final的，但其中的元素值可以被改变，从而避开了final的限制。start方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public static void start(int interval, boolean beep) &#123;</span><br><span class="line"></span><br><span class="line">   int[] count = &#123;1&#125;;</span><br><span class="line">   class TimePrinter implements ActionListener &#123;</span><br><span class="line">      public void actionPerformed(ActionEvent event) &#123;</span><br><span class="line">          // OK to change count[0] value, array reference not changed</span><br><span class="line">          System.out.println(count[0]++);  </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>匿名内部类<br>匿名内部类即没有名字的内部类，因为这个类只需要创建一个对象，所以它不需要给类命名，只需要<br>以特定的语法指明父类或实现的接口即可。</p><p>因为匿名内部类没有名字，而构造器需要与类名相同，所以匿名内部类没有构造器，它将构造器参数<br>传递给父类构造器，因为接口没有构造器，所以匿名内部类实现接口时，也没有参数，直接为<br><code>new InterfaceType(){...}</code>.</p><p>λ表达式可以用匿名内部类替换，如上文中λ表达式的例子可改写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Inter&#123;     // 函数式接口不可少，定义操作数和返回值</span><br><span class="line">    int oper(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">public class TestLambda &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      f(new Inter()&#123;</span><br><span class="line">         @Override</span><br><span class="line">         public int oper(int x, int y) &#123;</span><br><span class="line">           return x + y;  </span><br><span class="line">         &#125;</span><br><span class="line">        &#125;, 4,5);    </span><br><span class="line">  &#125;</span><br><span class="line">  private static void f(Inter inter, int x, int y) &#123;  // 接收函数表达式的方法</span><br><span class="line">      System.out.println(inter.oper(x,y));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是继承一个类的匿名内部类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  private int id;</span><br><span class="line">  public Person(int id) &#123;</span><br><span class="line">    this.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  public void say()&#123;</span><br><span class="line">   System.out.println(&quot;person&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public int getId()&#123;return id;&#125;</span><br><span class="line">  @Override</span><br><span class="line">  public String toString()&#123;</span><br><span class="line">    return &quot;Person&#123;id=&quot; + id + &quot;&#125;&quot;;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    final String x = &quot;hello&quot;;</span><br><span class="line">    Person p = new Person(88) &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void say()&#123;</span><br><span class="line">        // 匿名内部类实际上是Person的子类，无法直接访问Person私有属性id,也getId访问</span><br><span class="line">        System.out.println(x + getId());  // output hello88</span><br><span class="line">        System.out.println(this); // output Person&#123;id=88&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public void test()&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    p.say();</span><br><span class="line">    // p.test();   // 编译报错无法解析，原因在于多态</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由以上程序可以看出，匿名内部类与局部类的作用域相同，可以对所在作用域(即声明的所在方法)内<br>的final or effective final变量有访问权限。<br>关于p.test()多态报错的问题，网上找到一个经测试可以运行的办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Person(88) &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void say()&#123;</span><br><span class="line">    // 匿名内部类实际上是Person的子类，无法直接访问Person私有属性id,也getId访问</span><br><span class="line">    System.out.println(x + getId());  // output hello88</span><br><span class="line">    System.out.println(this); // output Person&#123;id=88&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public void test()&#123;&#125;</span><br><span class="line">&#125;.test();  // 直接在类声明后调用可以调用成功，未进行向上转型</span><br></pre></td></tr></table></figure></p><p>无论如何，匿名内部类主要还是用于重写方法。</p><p>还是使用javap命令反编译以上程序，匿名内部类会自动生成一个Outerclass$1.class：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final class com.test.InnerTest$1 extends com.test.Person&#123; // 证实了子类的关系</span><br><span class="line">  com.test.InnerTest$1(int);   // 构造器参数与Person一致</span><br><span class="line">  public void say();</span><br><span class="line">  public void test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注：有时需要传递一个匿名数组列表，可以是使用双括号初始化(double brace initialization):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleTest&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">   showList(new ArrayList&lt;Integer&gt;() &#123;&#123;</span><br><span class="line">    add(6);</span><br><span class="line">    add(5);</span><br><span class="line">    add(111);</span><br><span class="line">   &#125;&#125;);      // 适用于只需要使用一次的list参数</span><br><span class="line"> &#125;</span><br><span class="line"> private static void showList(List&lt;Integer&gt; list) &#123;</span><br><span class="line">   System.out.println(Arrays.toString(list.toArray())); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>静态内部类<br>如果不需要在内部类中引用外部类对象属性，可以将其设置为静态内部类。</p><p>静态态可以有静态域和静态方法，非静态类不可以。<br>因为静态变量和方法属于类的范围，它们会在具体的对象初始化前被加载，而非静态内部类的初始化<br>依托于外部类对象，所以非静态内部类中不能定义静态变量和方法，因为加载它们时需要的内部类<br>还未生成。</p><p>对静态内部类进行反编译可以发现其类名与普通内部类组成相同：Outerclass$Innerclass,类中没有<br>对外部类的引用,无构造器参数，为普通类编译结果。</p><p>静态类初始化语法<code>Outer.Inner inner = new Outer.Inner(XXX);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTest&#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Outer.Inner inner = new Outer.Inner(66); </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">class Outer&#123;</span><br><span class="line">  public static class Inner&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public Inner(int id)&#123;</span><br><span class="line">      this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理是一种设计模式，主要作用为对被代理对象的方法调用进行监控或加工处理等，是AOP和其他开发<br>框架常用的技术。</p><p>代理分为静态代理和动态代理，静态代理为显式的定义一个被代理对象的包装类，<br>实现与被代理对象相同的接口，该方法不具有广泛性，每个代理类都写死为某个接口与对象。<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class StaticProxy &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Bird bird = new Bird();</span><br><span class="line">     BirdProxy birdProxy = new BirdProxy(bird);</span><br><span class="line">     birdProxy.fly();</span><br><span class="line">  &#125;</span><br><span class="line">  interface Fly&#123;</span><br><span class="line">     void fly();</span><br><span class="line">  &#125;</span><br><span class="line">  static class Bird implements Fly&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;bird fly&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static class BirdProxy implements Fly&#123;</span><br><span class="line">     private Fly target;</span><br><span class="line">     public BirdProxy(Fly target) &#123;</span><br><span class="line">       this.target = target;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void fly() &#123;</span><br><span class="line">       System.out.println(&quot;do something before&quot;);</span><br><span class="line">       target.fly();</span><br><span class="line">       System.out.println(&quot;do something after&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>动态代理使用jdk的Proxy类和InvocationHandler接口，自定义代理类实现InvocationHandler接口，<br>同样包装被代理对象，重写invoke方法调用被代理对象的具体方法。调用时使用Proxy.newProxyInstance<br>(classloader, class[] interfaces, invocationHandler)方法在运行时生成代理对象。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">     Bird bird = new Bird();</span><br><span class="line">     Object proxy = Proxy.newProxyInstance(bird.getClass().getClassLoader(),</span><br><span class="line">                     bird.getClass().getInterfaces(),</span><br><span class="line">                     new ProxyFactory(bird));</span><br><span class="line">     Fly birdProxy = (Fly)proxy;  // proxy instance implements the interfaces assigned</span><br><span class="line">     birdProxy.fly();</span><br><span class="line">     System.out.println(birdProxy);  // toString方法同样调用invoke方法</span><br><span class="line">  &#125;</span><br><span class="line">  interface Fly&#123;</span><br><span class="line">     void fly();</span><br><span class="line">  &#125;</span><br><span class="line">  static class Bird implements Fly&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void fly() &#123;</span><br><span class="line">       System.out.println(&quot;bird fly&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  static class ProxyFactory implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">     private Object target;</span><br><span class="line">     public ProxyFactory(Object target) &#123;</span><br><span class="line">       this.target = target;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;do sth before&quot;);</span><br><span class="line">       Object result = method.invoke(target, args);</span><br><span class="line">       System.out.println(&quot;do sth after&quot;);</span><br><span class="line">       // System.out.println(proxy);       // error and exception</span><br><span class="line">       return result;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(参照java.reflect.Proxy类注释和javaCore书)</p><ol><li><p>newProxyInstance方法会在运行时生成一个代理类，类名以<code>$Proxy</code>开头，它继承了<br><code>java.reflect.Proxy</code>类，并以相同顺序实现方法参数中传递的的接口列表。</p></li><li><p>如果接口组都是public访问权限，代理类就是public final的，并且该代理类不指定包名;<br>如果接口组中有一个非public，则代理类就是非public的，并且代理类处于和其他非公有包的相同包中，<br>其中所有的非public接口需要在同一个包中。</p></li><li><p>对于相同类加载器和相同接口组生成的proxy不同实例是属于同一个proxy类的不同对象。</p></li><li><p>每个代理对象都只有一个实例域——invocationHandler,代理对象本身可以向上转型为某个实现的接口<br>引用，而通过此种方法调用代理对象的接口方法时，代理对象会调用其invocationHandler的invoke<br>方法(由于该invocationHandler会在初始化时通过参数传入，即调用了自定义的invoke方法)，invoke<br>方法中可以自定义操作，如通过反射Method调用被代理对象的方法等，invoke方法的返回值即为该次<br>代理对象上方法调用的返回值。</p></li><li><p>生成的代理类会自动重写Object的hashCode，equals,toString方法，这些方法也会被转向<br>invocationHandler的invoke方法进行处理，在实际使用中应当注意这一点，防止不必要的invoke<br>方法调用。其他的Object方法没有被重写。</p></li><li><p>如果不同代理接口中出现了重复方法，不管代理对象引用是什么接口类型，代理对象调用的<br>都是第一个出现的拥有此方法的接口(直接声明或继承而来的)，因为生成的代理类对应方法实现中<br>无法确定调用哪一个接口–都是接口数组元素。</p></li></ol><p>注：调用接口方法时转向调用invoke方法的实现原理是在生成的代理类代码中写明的，查看Proxy类<br>源码，其中有一个ProxyClassFactory静态内部类，其中的apply方法调用了<br>ProxyGenerator.generateProxyClass方法来生成Proxy类。我们可以自己调用该方法来查看生成的<br>Proxy类代码，通过类代码可以清楚的证明上述的1、4、5点。该类一旦被生成就是一个普通类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GenerateProxyTest &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    byte[] $Proxy6s = ProxyGenerator.generateProxyClass(&quot;$Proxy6&quot;, new Class[]&#123;Inte.class&#125;);</span><br><span class="line"></span><br><span class="line">    // jdk 1.7后的try-with-resource语法糖，可以对实现了autoCloseable接口的资源自动关闭</span><br><span class="line">    // 编译后为原来的try-catch-finally语句(如果用户代码和关闭代码都有异常，关闭异常被抑制，</span><br><span class="line">    // 可以通过getSuppressed方法获得该被抑制的异常)</span><br><span class="line"></span><br><span class="line">    try(FileOutputStream fos = new FileOutputStream(&quot;D:\\$Proxy6.class&quot;)) &#123;</span><br><span class="line">            fos.write($Proxy6s);</span><br><span class="line">            fos.flush();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Inte&#123;</span><br><span class="line">      void say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>取出该文件，使用jd-gui反编译(直接打开无效，进去后使用open file功能),内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">import com.example.demo.Inte;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy6     // 继承Proxy,实现Inte接口</span><br><span class="line">  extends Proxy</span><br><span class="line">  implements Inte</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m1;</span><br><span class="line">  private static Method m2;</span><br><span class="line">  private static Method m3;</span><br><span class="line">  private static Method m0;</span><br><span class="line">  </span><br><span class="line">  public $Proxy6(InvocationHandler paramInvocationHandler)</span><br><span class="line">  &#123;</span><br><span class="line">      super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Error|RuntimeException localError)</span><br><span class="line">      &#123;</span><br><span class="line">          throw localError;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable localThrowable)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final String toString()</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          return (String)this.h.invoke(this, m2, null);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Error|RuntimeException localError)</span><br><span class="line">      &#123;</span><br><span class="line">          throw localError;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable localThrowable)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 代理类中只是简单的调用了invoke方法 </span><br><span class="line">  public final void say()</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          this.h.invoke(this, m3, null);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Error|RuntimeException localError)</span><br><span class="line">      &#123;</span><br><span class="line">          throw localError;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable localThrowable)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public final int hashCode()</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          return ((Integer)this.h.invoke(this, m0, null)).intValue();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Error|RuntimeException localError)</span><br><span class="line">      &#123;</span><br><span class="line">          throw localError;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable localThrowable)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">          m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">          m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">          m3 = Class.forName(&quot;com.example.demo.Inte&quot;).getMethod(&quot;say&quot;, new Class[0]);</span><br><span class="line">          m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">      &#123;</span><br><span class="line">          throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为生成的代理类继承了java.reflect.Proxy类(和枚举继承了Enum一样),而java是单继承机制，<br>所以jdk动态代理只能代理接口，无法代理一个类，想要代理一个类，可以使用cglib包，它是通过<br>生成子类的方式实现的，据说spring的面向切面就是代理类时使用cglib,代理接口时使用proxy(这<br>一点以后研究AOP时再细看)</p><p>注：可以使用Proxy.isProxyClass来判断一个class对象是否是代理类。</p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190512_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java, Char with UTF-16, C++, 数组，&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.taoblog.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.taoblog.cn/tags/Java/"/>
    
      <category term="C++" scheme="http://www.taoblog.cn/tags/C/"/>
    
      <category term="Char with UTF-16" scheme="http://www.taoblog.cn/tags/Char-with-UTF-16/"/>
    
  </entry>
  
  <entry>
    <title>LinuxNote</title>
    <link href="http://www.taoblog.cn/post/1604d5df/"/>
    <id>http://www.taoblog.cn/post/1604d5df/</id>
    <published>2019-05-10T01:57:10.000Z</published>
    <updated>2021-04-05T05:49:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux, RHEL 7<br><a id="more"></a></p><h2 id="RHEL-7-虚拟机安装"><a href="#RHEL-7-虚拟机安装" class="headerlink" title="RHEL 7 虚拟机安装"></a>RHEL 7 虚拟机安装</h2><p>我是在ubantu LTS 18.04 系统中 xfce 桌面下用vmware workstation pro 15安装的<br><code>rhel-server-7.6-x86_64-dvd.iso</code></p><p>安装过程参照《linux就该这么学》一书，本文也是学习该书的笔记，<br>以后翻看《鸟哥的linux私房菜》时相应笔记也会补充到其中。</p><h2 id="常用linux命令"><a href="#常用linux命令" class="headerlink" title="常用linux命令"></a>常用linux命令</h2><p>在使用命令前，在终端上编辑bash终端命令本身有快捷键可以使用，记录如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">move</span><br><span class="line">ctrl + f   move forward a character</span><br><span class="line">ctrl + b   move backward a character</span><br><span class="line">alt  + f   move forward a word</span><br><span class="line">alt  + b   move backward a word</span><br><span class="line">ctrl + a   move to the beginning </span><br><span class="line">ctrl + e   move to the end</span><br><span class="line"></span><br><span class="line">edit</span><br><span class="line">backspace  delete backward  a character</span><br><span class="line">delete     delete forward   a character</span><br><span class="line">ctrl + d  命令行为空时为退出终端，不为空时删除光标下的字符，应谨慎使用</span><br><span class="line">ctrl + u  cut from cursor to the beginning (bash中叫kill and yank)</span><br><span class="line">ctrl + k  cut from cursor to the end</span><br><span class="line">ctrl + w  cut backward a word, 注意没有cut forward a word的快捷键，</span><br><span class="line">          可以使用alt+f再ctrl+w来向前删除。</span><br><span class="line">ctrl + y  paste what you have cut. 之后可以用alt+y来切换剪贴板的记录。</span><br><span class="line">ctrl + l  clean the screen 当前命令行字符不会受影响</span><br></pre></td></tr></table></figure></p><h3 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h3><ol><li>echo<br>echo $SHELL  输出SHELL变量的值</li><li>date<br>date “+%Y-%m-%d %H:%M:%S”  格式化输出当前时间<br>date -s “20170901 8:30:00” 设置当前时间<br>date “+%j” 用来显示当前时间是今年中的第几天，可以方便用来比较文件距离当前时间的新旧程度。</li><li>reboot<br>重启命令需要管理员权限，有管理员权限的可以使用sudo reboot，没有的可以su root切换到root用户</li><li>poweroff<br>关机命令需要管理员权限</li><li>wget<br>从<code>man wget</code>的description中可以对wget命令有大概的认识,这里总结如下：<br>wget是一个非交互方式的网络下载器，它可以在后台运行，这意味者用户不需要登录也可以在后台<br>进行下载操作。它还支持递归下载，跟踪网页中的链接。同时支持断点续传。<br>常用参数：<br>-b  –backgroud 后台下载模式<br>-p  –page-requisites  下载需要正常展示一个页面的所有资源，包括图片，视频等<br>-P  prefix 指定下载目录<br>-t  retries 最大尝试次数 默认20次，拒绝链接或404时不会尝试<br>-c  –continue  断点续传<br>-r  –recursive  递归下载，默认层数是5层<br>-l  –level  指定最大递归层数</li><li>ps<br>report a snapshot of current process 当前进程的快照<br>ps -ef  是standard sympton<br>ps -aux 是BSD语法<br>进程状态：<br>R run运行状态或等待运行<br>S 中断<br>D 不可中断，不响应异步信号，无法kill<br>Z 僵死 进程已经中止，但描述符仍存在<br>T 停止运行</li><li>top<br>ps是快照，top是动态监控系统进程信息</li><li>pidof<br>查询某个进程的pid值,如 pidof sshd</li><li>kill<br>终止某个进程，如kill 2856</li><li>killall<br>用来杀死某个服务的所有进程，如killall httpd</li></ol><h3 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h3><ol><li><p>ifconfig<br>默认查看活动的网卡接口，-a查看所有网卡接口<br>inet后是ip地址，ether后是物理网卡地址（MAC地址）<br>ifconfig -a </p></li><li><p>uname<br>查看系统内核和系统版本等信息<br>uname -a<br>rhel可以使用cat /etc/redhat-release查看当前系统版本的详细信息</p></li><li><p>uptime<br>查看系统负载信息<br>具体显示系统启动时间，已运行时间，运行中的和不可中断的进程的平均负载情况，1,5,15分钟时间内,<br>建议不要长期超过1,生产不超过5.<br>注: 由fish shell切换回bash时，发现系统启动时间是bash切换的时间</p></li><li><p>free<br>内存使用量<br>free -h 将数字转化为G为单位，方便阅读</p></li><li><p>who<br>显示正在登录的用户终端信息<br>用户名 终端设备 登录时间（不受终端Shell影响）</p></li><li><p>last<br>查看系统登录记录<br>查询的是日志文件，黑客可以修改，所以无法作为是否被入侵的依据。</p></li><li><p>history<br>显示最近使用的命令，默认1000条<br>bash上有数字显示,其显示的是<code>~/.bash_history</code>内容（fish上执行history是不同的命令，没有数字）<br>可以使用！15来执行第15条命令<br>history -c 可以清除命令</p></li><li><p>sosreport<br>输出系统配置和诊断信息<br>rhel上执行报no plugins enabled,使用sosreport -l发现插件都需要root权限。<br>注：针对打出的诊断包.tar.xz格式可以使用<code>tar -Jxf XX.tar.xz</code>来解压</p></li></ol><h3 id="工作目录切换"><a href="#工作目录切换" class="headerlink" title="工作目录切换"></a>工作目录切换</h3><ol><li>pwd  显示当前目录</li><li>cd  切换工作路径<br>cd -  切换到上一次所处的目录</li><li>ls<br>目录中的文件信息<br>ls -al  显示所有文件</li></ol><h3 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h3><ol><li>cat<br>cat -n 查看文本内容并显示行号</li><li>more<br>显示部分文本文件，会显示当前行所在百分比，用空格会查看下一页内容，回车查看下一行内容<br>推荐使用less命令</li><li>head  默认10行<br>head -n 20 XX.file   显示XX文件前20行内容，显示后无法进一步操作</li><li>tail  默认10行<br>tail -100f XX.file   显示文件最后100行内容并持续刷新</li><li>tr 简化版的sed命令，可以进行简单删除，替换操作。<br>echo “hello 23 world 45” | tr -d ‘2345’  删除 输出hello world<br>echo “helllllo wooorld” | tr -s ‘lo’     压缩 输出helo world<br>echo “helllllo wooorld” | tr [a-z] [A-Z]   转换大小写 输出HELLLLLO WOOORLD</li><li>wc  word count<br>wc XXX    依次显示XXX文件的行数，单词数，字节数<br>也可以单独显示某个信息，如:<br>wc -l XXX   只显示行数lines<br>wc -w XXX   只显示单词个数words<br>wc -c XXX   只显示字节数bytes</li><li>stat<br>stat XXX   显示XXX文件的存储信息和access,modify,change时间</li><li>cut  按列提取文件数据<br>cut -d: -f1 /etc/passwd   -d为delimiter为:, -f1指定第一列</li><li>diff<br>diff -q A.txt B.txt   相当于–brief 显示是否不同<br>diff -c A.txt B.txt   显示2个文件，并用感叹号显示出不同的行</li></ol><h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><ol><li>touch 新建一个文件或修改一个文件的修改时间，读取时间等<br>touch -a    只修改文件读取时间 atime   access<br>touch -m    只修改文件修改时间 mtime   modify<br>touch -d    同时修改atime和mtime    date<br>如touch -d “2019-01-01 10:00” XXX   修改XXX文件的读取和修改时间 </li><li>mkdir  创建文件夹<br>mkdir dir<br>mkdir -p a/d/b  创建所需的层级目录(parent, 必要时创建父目录)</li><li>cp<br>-a   保留文件属性 同-pdr 权限，软链接，递归复制<br>-r   递归持续复制<br>-i   若目标文件存在则进行询问<br>cp a.txt aBack.txt</li><li>mv<br>mv a.txt b.txt</li><li>rm<br>rm -rf dir/</li><li><p>dd<br>复制或转换一个文件，可用来创建指定大小的文件，或快速制作iso文件<br>if  输入文件<br>of  输出文件<br>bs  每个块的大小<br>count 块的个数</p><p>dd if=/dev/zero of=aFile count=1 bs=560M  创建一个560M的文件aFile(/dev/zero为无限空间设备名)<br>dd if=/dev/cdrom of=RHEL-server-7-x86_64.iso  从光盘中制作镜像文件</p></li><li>file<br>由于linux中文本，目录，设备都是文件，可以使用file命令来查看文件类型<br>file a         ASCII text<br>file /dev/sda    block special</li></ol><h3 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h3><ol><li><p>tar<br>tar option file<br>-c  压缩  create a archive<br>-x  解压  extract<br>-z  使用gzip压缩或解压<br>-j  使用bzip2压缩或解压<br>-v  显示压缩或解压过程 verbose<br>-f  指定目标文件名 file   (需要在参数的最后一位)<br>-C  指定解压到的目录 –directory<br>-p  保留权限与属性信息  –preserve-permissions<br>-P  使用绝对路径来压缩 –absolute-names<br>-t  显示压缩包内的文件列表  –list<br>常用用法<br>tar -czvf a.tar.gz /a<br>mkdir ss<br>tar -xzvf a.tar.gz -C ./ss/   解压无法自动创建目录，需要手动创建，使用-C指定解压目录  </p></li><li><p>grep<br>grep [options] pattern [file]<br>-i    –ignore-case 忽略大小写<br>-n    –line-number 显示行号<br>-v    –invert-match 反向选择，列出不匹配的行<br>-c    –count  仅显示行数<br>-b    将可执行文件作为text文本搜索<br>grep -n /sbin/nologin /etc/passwd</p></li><li><p>find<br>find path expression(expression由options, tests, actions组成)<br>其中tests有以下选项：<br>-name  按文件名搜索<br>-perm  按权限搜索 -perm mode 为完全匹配， -perm -mode为包含即可<br>-user  匹配拥有者<br>-group 匹配组<br>-mtime 匹配修改的时间 -n n天以内 +n n天以前<br>-atime 匹配访问的时间 -n n天以内 +n n天以前<br>-ctime 匹配修改文件权限的时间  -n n天以内 +n n天以前<br>-nouser  匹配无拥有者的文件<br>-nogroup 匹配无拥有组的文件<br>-newer f1 !f2  匹配比f1新，比f2旧的文件<br>–type 匹配文件类型<br>  b 块设备 d 目录 c 字符设备 p 管道 l 链接文件 f 文本文件<br>-size  匹配文件大小 +50KB查找大于50KB的文件，-50KB查找小于50KB的文件<br>-prune  忽略某个目录<br>-exec {} \;  对搜索结果进行处理, {}表示匹配成功的每一个文件，命令以\;结尾<br><code>find /etc -name &quot;host*&quot; -print</code><br>find / -perm -4000 -print<br>find / -user linuxprobe -exec cp -a {} /root/findresults/ \;</p></li></ol><h2 id="管道符、重定向与环境变量"><a href="#管道符、重定向与环境变量" class="headerlink" title="管道符、重定向与环境变量"></a>管道符、重定向与环境变量</h2><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>标准输入重定向(STDIN, 文件描述符为0)  默认从键盘输入，也可为其他文件或命令<br>标准输出重定向(STDOUT，文件描述符为1) 默认输出到屏幕<br>错误输出重定向(STDERR, 文件描述符为2) 默认输出到屏幕</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt; aFile   将文件作为命令的标准输入</span><br><span class="line">&lt;&lt; ;    从标准输入中读取，直到分界符;才停止</span><br><span class="line">&lt; afile &gt; bifle  afile作为标准输入，bfile作为标准输出</span><br><span class="line"></span><br><span class="line">&gt; afile   标准输出重定向到afile,并清空afile原有内容</span><br><span class="line">2&gt; afile  将错误输出重定向到afile中，并清空afile原有内容(注意2后没有空格)</span><br><span class="line">&gt;&gt; afile  标准输出重定向到afile,追加到afile原有内容后</span><br><span class="line">2&gt;&gt; afile 错误输出重定向到afile,追加到afile原有内容后</span><br><span class="line">&gt;&gt; afile 2&gt;&amp;1 或 &amp;&gt;&gt; afile  这2个命令都代表标准输出和错误输出共同重定向到afile文件(追加)</span><br><span class="line">&gt; afile 2&gt;&amp;1 或 &amp;&gt; afile 这2个命令都代表标准输出和错误输出共同重定向到afile文件(清空)</span><br></pre></td></tr></table></figure><p>其中，文件描述符1可以忽略不写，如<code>1&gt; afile</code>写为<code>&gt; afile</code>, 2不能省略</p><p>输入重定向如<code>wc -l &lt; a.txt</code>显示a.txt文件中内容的行数<br>(可用cat a.txt | wc -l代替)</p><h3 id="管道命令符"><a href="#管道命令符" class="headerlink" title="管道命令符"></a>管道命令符</h3><p>如grep会打印出符合条件的行内容，wc -l会显示文件行数，可以使用管道符来打印出符合条件的行数<br>(虽然可以用grep的-c参数…).</p><p>在修改密码时要求从键盘中输入密码，在自动化脚本中无法实现，可以使用管道符和passwd命令的<br>–stdin参数完成这一功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">echo &quot;root&quot; | passwd --stdin root</span><br></pre></td></tr></table></figure></p><p>不同用户间发送邮件,如用户root发送给用户tao,标题为subject,内容为hello tao<br><code>echo &quot;hello tao&quot; | mail -s &quot;subject&quot; tao</code><br>注：经测试用户tao给root写信没有成功…</p><p>使用&lt;&lt; ;重定向输入直到分界符;可以连续输入多行邮件内容，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail -s &quot;test&quot; tao &lt;&lt; over</span><br></pre></td></tr></table></figure></p><p>可以输入多行内容，直到最后一行以精准的over结束为止，不能多或少字符，空格等。</p><h3 id="命令行的通配符"><a href="#命令行的通配符" class="headerlink" title="命令行的通配符"></a>命令行的通配符</h3><p>与正则表达式不完全相同的是通配符的含义：</p><ul><li>表示0个或多个字符(相同)<br>? 表示1个字符(不同)<br>[] 匹配中括号中的一个字符(相同)</li></ul><h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>\  使特殊字符变为普通字符<br>‘  使引号中的变量变为单纯字符<br>“  将其中的变量求值后输出<br>`  执行其中的命令后返回结果</p><p>如执行命令echo “price is $PRICE” 会输出price is 5,双引号对变量求值。<br>而$$会打印出当前程序的进程ID,所以可以使用echo “price is \$$PRICE”来输出price is $5.<br>需要某个命令的输出值时可以使用反引号。</p><h3 id="重要的环境变量"><a href="#重要的环境变量" class="headerlink" title="重要的环境变量"></a>重要的环境变量</h3><p>linux终端执行命令步骤:</p><ol><li>检查用户命令是否以绝对路径或相对路径输入命令，如果是则直接执行。</li><li>检查命令是否是别名alias,如根用户执行命令<code>alias rm</code>可以看见输出<br><code>alias rm=&#39;rm -i&#39;</code>, 说明系统默认将rm命令加上-i参数执行。</li><li>判断命令是内部命令还是外部命令，内部命令是解释器内部的指令，它会直接执行;外部命令会由<br>步骤4继续执行。如执行命令<code>type cd</code>或<code>type pwd</code>可以看见输出为XXX is a shell builtin，说明<br>其为内部命令。</li><li>系统在PATH变量中寻找该命令文件执行。PATH变量是由多个路径组成的变量，由冒号分割，可以使用<br>命令<code>echo $PATH</code>查看PATH变量的值。</li></ol><p>不能将当前目录添加到PATH变量的原因为: 黑客可以将一个与ls命令(本身是别名)同名的木马文件存放<br>到某个常用公共目录中，用户在该目录执行ls命令时会根据环境变量找到当前目录下的木马文件执行，<br>从而中招。</p><p>最重要的10个环境变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. HOME    家目录</span><br><span class="line">2. SHELL   当前使用的Shell解释器名称</span><br><span class="line">3. HISTSIZE        输出的历史命令记录条数</span><br><span class="line">4. HISTFILESIZE    保存的历史命令记录条数</span><br><span class="line">5. MAIL       邮件保存路径</span><br><span class="line">6. LANG    系统语言</span><br><span class="line">7. RANDOM   生成一个随机数字</span><br><span class="line">8. PS1     Bash解释器提示符</span><br><span class="line">9. PATH    解释器搜索用户执行命令路径</span><br><span class="line">10. EDITOR 用户默认文本</span><br></pre></td></tr></table></figure></p><p>不同用户看到的相同环境变量可能不同，如root用户与普通用户查看到的HOME变量就不同。<br>可以使用export命令导出自定义的环境变量，这样做相当于将其提升为全局变量。</p><h2 id="vim编辑器与Shell命令脚本"><a href="#vim编辑器与Shell命令脚本" class="headerlink" title="vim编辑器与Shell命令脚本"></a>vim编辑器与Shell命令脚本</h2><p>TBD</p><h2 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h2><p>因为工作中经常需要上传前台页面的jsp和js文件到服务器上(只有服务器上才能调用后台接口), 一直<br>使用ftp工具图形化界面上传，用久了突然反应过来可以用ssh远程登录和scp命令进行操作，方便快捷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upload to server</span><br><span class="line">scp 1.txt 2.txt user@ip:/home/XXX/XXX</span><br><span class="line"></span><br><span class="line">download from server</span><br><span class="line">  // many files</span><br><span class="line">scp user@ip:&quot;/path/of/file1 /path/of/file2&quot; ./</span><br><span class="line">  // recursive download, such a dir </span><br><span class="line">scp -r user@ip:/path/of/dir ./</span><br></pre></td></tr></table></figure><p>scp默认覆盖已经存在的文件和目录。</p><h2 id="cdh-和-pushd"><a href="#cdh-和-pushd" class="headerlink" title="cdh 和 pushd"></a>cdh 和 pushd</h2><p>vim作为文本编辑器非常强大，但很多时候还是要跳出vim到命令行进行操作，如复制文件，运行命令<br>行命令等。vim中可以使用ctrlp的MRU File功能，但命令行中切换mru dir怎么办？<br>我记得之前有个autojump插件(fish shell也支持), 打算装上，但在stack overflow上看到了更多<br>的解决方案，相比这个简单需要完全不需要装插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. cd -  在2个目录间进行跳转，类似于vim的ctrl+6交互文件</span><br><span class="line">2. pushd/popd  </span><br><span class="line">   下面这个是fish shell的man页面</span><br><span class="line">   The pushd function adds DIRECTORY to the top of the directory stack and makes it the </span><br><span class="line">   current working directory. popd will pop it off and return to the original directory.</span><br><span class="line"></span><br><span class="line">   Without arguments, it exchanges the top two directories in the stack.</span><br><span class="line"></span><br><span class="line">   pushd +NUMBER rotates the stack counter-clockwise i.e. from bottom to top</span><br><span class="line">   pushd -NUMBER rotates clockwise i.e. top to bottom.</span><br><span class="line"></span><br><span class="line">   See also dirs and dirs -c.</span><br><span class="line">   You may be interested in the cdh command which provides a more intuitive way to navigate to recently visited directories.</span><br><span class="line"></span><br><span class="line">   经测试，bash下pushd, dirs也可以使用，cdh是fish shell自己封装的一个交互跳转页面</span><br></pre></td></tr></table></figure></p><p>总体来说，我本地是fish, 用cdh比较方便，其他环境使用以下命令组合:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pushd /path/of/dir</span><br><span class="line">dirs -v</span><br><span class="line">pushd +n // n 是dirs -v显示的序号</span><br><span class="line">pushd    // 等同于 pushd +0</span><br></pre></td></tr></table></figure></p><h2 id="bashrc和-bash-profile"><a href="#bashrc和-bash-profile" class="headerlink" title=".bashrc和.bash_profile"></a>.bashrc和.bash_profile</h2><p>由于我想使用xcape修改键盘，按网上博客将相关命令代码放在.bashrc中，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Run xcape once.</span><br><span class="line">if [ -z $XCAPE ];then</span><br><span class="line">  export XCAPE=1</span><br><span class="line">  /usr/bin/xcape -e &apos;Super_L=Escape;Shift_R=parenleft&apos; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>可以看到，它通过判断XCAPE变量长度是否为0进行操作，如果为空，就执行xcape命令，否则就不会重复<br>执行。之前没在意这点，后来发现多次打开终端terminator窗口，发现按右shift产生了多个括号，<br>开始以为是xcape命令的问题，后来”不小心”发现有多个xcape进程同时运行！</p><p>问题就出在.bashrc中没有实现需要的export出全局变量的功能！那么这段代码应该放在哪里？</p><p>寻找了好久，试了/etc/profile, .profile, <code>.bash_profile</code>, /etc/init.d/rc.local, .xsessionrc,<br>全都不行！</p><p>经网上资料查找到bash manual, 其中对它们的区别作出了说明。这里翻译一下bash manual相关内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 通过登录的交互式shell登录， 或是--login参数登录时:</span><br><span class="line"> 先读取/etc/profile,再是`~/.bash_profile`,`~/.bash_login`, ~/.profile.会顺序查找执行第一个</span><br><span class="line"> 找到的可执行文件，剩下的会被忽略。执行exit命令退出时，会尝试执行`~/.bash_logout`.</span><br><span class="line"> 有些shell没有按照这个顺序查找，如dash,它只看.profile, 所以如果使用其他shell作为</span><br><span class="line"> login shell时(如使用了命令chsh -s), 这时应当修改.profile才会生效。</span><br><span class="line"></span><br><span class="line">2. 如果是交互式非登录方式(一般的默认方式).</span><br><span class="line"> 会执行.bashrc, 即打开一个终端实例，即会执行一次.bashrc, 通常推荐在`.bash_profile`中包含</span><br><span class="line"> 执行.bashrc文件，为</span><br><span class="line">```txt</span><br><span class="line">  if [ -f ~/.bashrc ]; then . ~/.bashrc; fi</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>当不是交互式执行bash时，如执行脚本时<br>终端会执行<code>$BASH_ENV</code>变量，执行过程等同与执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ -n &quot;$BASH_ENV&quot; ]; then . &quot;$BASH_ENV&quot;; fi</span><br></pre></td></tr></table></figure></li><li><p>通过sh命令执行命令<br>基本等同于以上步骤，如果是login或–login的终端中执行的sh命令，会读取/etc/profile, ~/.profile;<br>如果是交互式shell, 会读取变量ENV.非交互式的Shell执行sh命令不会尝试读取任何其他的启动文件，<br>如脚本中的sh命令。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">由上可知，每次打开新的终端窗口，都会执行<span class="string">.bashrc</span>文件，所以我将想只在登录时执行一次的代码</span><br><span class="line">放到<span class="string">.bash_profile</span>中，可以登录后手动source <span class="string">.bash_profile</span>, 但不能重复执行。</span><br><span class="line"></span><br><span class="line">注: <span class="string">/etc/environment</span>是适用于所有用户的，归root用户管理，需要sudo进行修改，不应当修改它，</span><br><span class="line">它通常只包含一行:</span><br><span class="line">```txt</span><br><span class="line">PATH=<span class="string">"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games"</span></span><br></pre></td></tr></table></figure></li></ol><p>如果只适用与当前用户的环境变量应当放在.profile中，如果想适用到所有用户，也不应当直接修改<br>/etc/profile, 而是应当在/etc/profile.d/下新建可执行的XX.sh脚本。</p><p>我使用的xmonad,通过以上方法新建脚本，在其中export相应的环境变量，发现xmonad也能获取到相应的<br>环境变量，这样就不用额外执行对应的脚本了。同时在.xsessionrc执行xcape … &amp; 也能正确响应，<br>成功！</p><p>注: .xsessionrc在每次X的session启动时都会执行，而/etc/init.d/rc.local说是只有第一次启动时<br>会执行，后面xserver重启时就不会执行(待测试)。</p><h2 id="Teminator主题精选"><a href="#Teminator主题精选" class="headerlink" title="Teminator主题精选"></a>Teminator主题精选</h2><p>以下是我精选的Terminator主题，来源是<a href="https://github.com/EliverLara/terminator-themes" target="_blank" rel="noopener">github</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cai, Cobalt2, Dracula(default), Elio, Glacier, Homebrew, Jellybeans, Monokai Vivid, </span><br><span class="line">Pandora, pro</span><br></pre></td></tr></table></figure></p><p>字体选择自带的Nimbus Mono L Bold 13即可。<br>注: terminator copy and paste:<br>ctrl + shift + c<br>ctrl + shift + v<br>这适用于提取fish命令到剪切板中。</p><h2 id="kitty-and-fira-code"><a href="#kitty-and-fira-code" class="headerlink" title="kitty and fira-code"></a>kitty and fira-code</h2><p>昨天刚刚找了很多Terminator的主题,今天想找到能够区分1和l(lowercase of L)的字体，结果发现了<br>fira-code! 感觉非常神奇，但是Terminator还不能支持它，linux上可以装kitty支持它。<br>但kitty虽然速度快，但目前还非常小众，没有Terminator的精美样式。<br>所以我先装下网上推荐的input字体看看效果，毕竟我本来是要装字体的….<br>清晰的字体要能明显区分以下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 l</span><br><span class="line">O 0</span><br><span class="line">S 5</span><br><span class="line">0 o</span><br></pre></td></tr></table></figure></p><p>ubuntu上安装过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 在input页面自己定制字体，尤其是上面的l, i部分</span><br><span class="line">2. 下载自定义的input包，里面除了自定义的字体包外，有一个可以修改自定义的python脚本，先不管它。</span><br><span class="line">3. mkdir ~/.fonts</span><br><span class="line">4. cp -r ~/Downloads/input/* ~/.fonts   // 将所有的ttf格式字体拷贝到.fonts目录下</span><br><span class="line">5. fc-cache -f -v   // 强制刷新字体缓存，使得新装字体生效 </span><br><span class="line">6. 在teminator中选择input bold字体，done!</span><br></pre></td></tr></table></figure></p><h2 id="vmware-workstation-虚拟机减小硬盘容量-decrease-vmware-workstation-hard-disk-size"><a href="#vmware-workstation-虚拟机减小硬盘容量-decrease-vmware-workstation-hard-disk-size" class="headerlink" title="vmware workstation 虚拟机减小硬盘容量(decrease vmware workstation hard disk size)"></a>vmware workstation 虚拟机减小硬盘容量(decrease vmware workstation hard disk size)</h2><p>vmware虚拟机扩大硬盘容量非常简单，直接在设置中扩容即可，但想要减小容量确不能直接操作。<br>在网上搜索到quora中有人提供了3种方法。</p><ol><li>vSphere Manager. 经搜索每找到对应的工具</li><li>vmware converter. vmware推荐工具, 我最后采用的方法</li><li>qemu-img工具。它是属于QEMU的工具。</li></ol><p>第3种方法看起来最简单方便，经查看是对单个vmdk包进行大小修改，我的虚拟机中有好几个vmdk文件，<br>所有操作起来有一定风险。</p><p>第2种方法是官方工具，但使用下来主要是速度非常慢，我失败了1次，第2次成功，前后接近2小时多<br>时间才得到转换后的包。下面记录下过程和坑。</p><ol><li>下载vmware converter, 我的版本是6.2.0-8466193.exe版本。支持转换win 10.</li><li>需要关闭windows实时防护等，我自己是关闭所有防火墙。否则转换中会失败。</li><li>用管理员运行converter, 否则选择local merchine时报错permission not allowed.</li><li>开始转换，source 选local machine, destination选vmware workstation, 这里只能选到<br>vmware workstation 11/12. 在后面的edit界面中重新选择磁盘大小。</li><li>转换结束，因为我的workstation是15版本，直接启动始终转圈，后面看到有个upgrade选项，<br>果断点击clone 升级。</li></ol><h2 id="xfce使用快捷键将窗口在多显示器之间移动"><a href="#xfce使用快捷键将窗口在多显示器之间移动" class="headerlink" title="xfce使用快捷键将窗口在多显示器之间移动"></a>xfce使用快捷键将窗口在多显示器之间移动</h2><p>本来我是用xmonad的，经过不少折腾，基本上能流畅使用了，但xmonad有个问题: 即如果在vim中使用<br>如ctrlp插件快速切换多个文本文件时，vim会明显卡住，导致屏幕显示内容出现问题，该问题后来<br>没有找到合适的解决方法，个人感觉和xmonad的标准输入记录有关(即上面显示当前工作区和内容的区域),<br>怀疑是快速切换时造成xmonad的输入管道堵塞引起(纯粹个人猜测，因为目前还没有去专门学习haskell)。<br>Anyway, 后来发现wayland和xfce没有vim的该问题，快速切换时非常流畅，没有卡屏现象; 而且又发现<br>xfce提供了windows manager设置功能，完全可以将xmonad的快捷键照搬到其中，非常方便，而且它还<br>可以删减工作区(alt + insert/delete即可)，这也是我想要的一个功能，xmonad目前默认9个，想减少<br>还没有找到合适方法(同样，没有专门学习haskell). </p><p>那么最后的问题是，如何在xfce中实现多显示屏之间的窗口移动和焦点切换？<br>xfce本身没有支持，网上有提供脚本实现，这里记录下尝试过程。</p><ol><li>sudo apt install xdotool wmctrl</li><li><p>vi moveWindow.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># Move the current window to the next monitor.</span><br><span class="line">#</span><br><span class="line"># Also works only on one X screen (which is the most common case).</span><br><span class="line">#</span><br><span class="line"># Props to</span><br><span class="line"># http://icyrock.com/blog/2012/05/xubuntu-moving-windows-between-monitors/</span><br><span class="line">#</span><br><span class="line"># Unfortunately, both &quot;xdotool getwindowgeometry --shell $window_id&quot; and</span><br><span class="line"># checking &quot;-geometry&quot; of &quot;xwininfo -id $window_id&quot; are not sufficient, as</span><br><span class="line"># the first command does not respect panel/decoration offsets and the second</span><br><span class="line"># will sometimes give a &quot;-0-0&quot; geometry. This is why we resort to &quot;xwininfo&quot;.</span><br><span class="line"></span><br><span class="line">screen_width=$(xdpyinfo | awk -F&quot; |x&quot; &apos;/dimensions:/ &#123; print $7 &#125;&apos;)</span><br><span class="line">screen_height=$(xdpyinfo | awk -F&quot; |x&quot; &apos;/dimensions:/ &#123; print $8 &#125;&apos;)</span><br><span class="line">window_id=$(xdotool getactivewindow)</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">    -l )</span><br><span class="line">        display_width=$((screen_width / 3 * 2)) ;;</span><br><span class="line">    -r )</span><br><span class="line">        display_width=$((screen_width / 3)) ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># Remember if it was maximized.</span><br><span class="line">window_state=$(xprop -id $window_id _NET_WM_STATE | awk &apos;&#123; print $3 &#125;&apos;)</span><br><span class="line"></span><br><span class="line"># Un-maximize current window so that we can move it</span><br><span class="line">wmctrl -ir $window_id -b remove,maximized_vert,maximized_horz</span><br><span class="line"></span><br><span class="line"># Read window position</span><br><span class="line">x=$(xwininfo -id $window_id | awk &apos;/Absolute upper-left X:/ &#123; print $4 &#125;&apos;)</span><br><span class="line">y=$(xwininfo -id $window_id | awk &apos;/Absolute upper-left Y:/ &#123; print $4 &#125;&apos;)</span><br><span class="line"></span><br><span class="line"># Subtract any offsets caused by window decorations and panels</span><br><span class="line">x_offset=$(xwininfo -id $window_id | awk &apos;/Relative upper-left X:/ &#123; print $4 &#125;&apos;)</span><br><span class="line">y_offset=$(xwininfo -id $window_id | awk &apos;/Relative upper-left Y:/ &#123; print $4 &#125;&apos;)</span><br><span class="line">x=$((x - x_offset))</span><br><span class="line">y=$((y - y_offset))</span><br><span class="line"></span><br><span class="line"># Fix Chromium app view issue of small un-maximized size</span><br><span class="line">width=$(xdotool getwindowgeometry $window_id | awk -F&quot; |x&quot; &apos;/Geometry:/ &#123; print $4 &#125;&apos;)</span><br><span class="line">if [ &quot;$width&quot; -lt &quot;150&quot; ]; then</span><br><span class="line">  display_width=$((display_width + 150))</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Compute new X position</span><br><span class="line">new_x=$((x + display_width))</span><br><span class="line"># Compute new Y position</span><br><span class="line">new_y=$((y + screen_height))</span><br><span class="line"></span><br><span class="line"># If we would move off the right-most monitor, we set it to the left one.</span><br><span class="line"># We also respect the window&apos;s width here: moving a window off more than half its width won&apos;t happen.</span><br><span class="line">if [ $((new_x + width / 2)) -gt $screen_width ]; then</span><br><span class="line">  new_x=$((new_x - screen_width))</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">height=$(xdotool getwindowgeometry $window_id | awk -F&quot; |x&quot; &apos;/Geometry:/ &#123; print $5 &#125;&apos;)</span><br><span class="line">if [ $((new_y + height / 2)) -gt $screen_height ]; then</span><br><span class="line">  new_y=$((new_y - screen_height))</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Don&apos;t move off the left side.</span><br><span class="line">if [ $new_x -lt 0 ]; then</span><br><span class="line">  new_x=0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Don&apos;t move off the bottom</span><br><span class="line">if [ $new_y -lt 0 ]; then</span><br><span class="line">  new_y=0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Move the window</span><br><span class="line">xdotool windowmove $window_id $new_x $new_y</span><br><span class="line"></span><br><span class="line"># Maintain if window was maximized or not</span><br><span class="line">if [ &quot;$&#123;window_state&#125;&quot; = &quot;_NET_WM_STATE_MAXIMIZED_HORZ,&quot; ]; then</span><br><span class="line">    wmctrl -ir $window_id -b add,maximized_vert,maximized_horz</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>chmod +x moveWindow.sh</p></li><li>application -&gt; settings -&gt; keyboard -&gt; add<br>command: sh /home/tao/Documents/moveWindow.sh<br>shortcut: super + shift + o</li></ol><p>经测试，在双屏显示中完美生效，多次按键相同窗口在左右显示屏中来回切换。<br>网上还有针对三屏显示器的改进脚本，这里不再记述。</p><h2 id="vmware-合并多个vmdk文件"><a href="#vmware-合并多个vmdk文件" class="headerlink" title="vmware 合并多个vmdk文件"></a>vmware 合并多个vmdk文件</h2><p>vmware有个vmware-vdiskmanager工具, mac上的fusion中路径是<br><code>/Applications/VMware\ Fusion.app/Contents/Library/vmware-vdiskmanager</code><br>linux上的workstation是<code>/usr/bin/vmware-vdiskmanager --help</code>, help中有合并多个为一个的例子<br><code>即 vmware-vdiskmanager -r source.vmdk -t 0 destination.vmdk</code></p><h2 id="linux系统查找系统中的大文件"><a href="#linux系统查找系统中的大文件" class="headerlink" title="linux系统查找系统中的大文件"></a>linux系统查找系统中的大文件</h2><p>windows中有一个sniffspacer的软件可以快速查找出大文件, 而linux系统中直接使用find命令即可.<br>如以下命令查找当前目录大于1G的文件, 倒序格式化输出.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo find . -type f -size +1G  -print0 | xargs -0 du -h | sort -nr</span><br></pre></td></tr></table></figure></p><p>对于目录可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo du -lh --max-depth=1 | sort -nr | head -30</span><br></pre></td></tr></table></figure></p><h2 id="WSL-初体验"><a href="#WSL-初体验" class="headerlink" title="WSL 初体验"></a>WSL 初体验</h2><p>WSL: Windows Subsystem for Linux<br>之前听说过win10现在自带linux了, 但没有尝试. 最近感觉cmder启动太慢, 所以想着可以试试WSL,<br>看看是不是能快很多, 最终结果是打开windows自身命令行窗口超快, 再输入bash, 即可以完美使用<br>linux终端了, 使用mount命令可以看到windows系统的c, d盘都能在/mnt/c 或 d盘下找到, 至此即<br>可以卸载cmder, 享受原生命令行窗口的超速度.<br>下面是一些简单步骤, 具体可以查看网上教程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 在设置-&gt; 安全与更新 -&gt; 打开开发者选项. 这一步开始比较卡, 后面成功了, 没啥问题.</span><br><span class="line">2. 控制面板-&gt; 程序和功能-&gt;启用关闭windows功能-&gt;勾选适用于Linux的Windows子系统 </span><br><span class="line">3. 这一步网上说执行lxrun命令安装linux, 但命令行提示出一个网址, 直接复制后在浏览器打开,</span><br><span class="line">它会自动打开windows store, 点击安装ubuntu即可, 默认安装位置在c盘, 后面无法移动位置.</span><br><span class="line">注: 为提高下载速度, 说是要打开设置-&gt;更新与安全-&gt;传递优化中-&gt;打开允许从其他电脑下载-&gt;</span><br><span class="line">选择第2个, 我本地上的电脑和internet上的电脑.</span><br><span class="line">4. 在安装后的命令窗口中输入用户名和密码即可.</span><br><span class="line">5. 同真正的ubuntu系统一样, 更新数据源为阿里云</span><br><span class="line">6. 安装fish, 设置对应的fish别名, 移植vimrc配置</span><br></pre></td></tr></table></figure></p><p>注: 原生的cmd窗口毕竟太挫, 网上推荐windows terminal, 后来费劲将windows升级到最新的19, 成功<br>安装了windows terminal, 真香!</p><p>重启WSL的方式是在服务中寻找一个名为LxssManager的服务,服务介绍说是在windows上支持运行ELF格式<br>文件, 重启该服务即重启了WSL.</p><p>WSL不能直接使用windows上的jdk, 需要使用apt下载linux版的jdk, maven倒是不影响, 系统通用.<br>测试时发现, settings.xml配置文件中的localRepository也需要进行修改, 确保maven能查找到对应的<br>本地仓库, 最好就是将WSL和windows的配置分开, 使用不同的配置文件.<br>对于nodejs也是如此,需要另外下载.<br>网上有推荐使用nvm安装nodeJs的, 经测试使用命令<br><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.35.2/install.sh | bash</code><br>报错拒绝连接, 打开vpn并在环境变量配置重启WSL后成功链接上, 但是又报错<br><code>invalid argument, uv_pipe_open</code>.<br>于是改用apt来装:</p><ol><li>添加apt仓库源:(通过nodesource安装时需要指定版本)<br>curl -sL <a href="https://deb.nodesource.com/setup_12.x" target="_blank" rel="noopener">https://deb.nodesource.com/setup_12.x</a> | sudo -E bash -</li><li>sudo apt install nodejs</li><li>node -v, npm -v, done<br>因为之前windows装了windowsNVM来管理不同的node版本, 这里可以使用sudo npm i -g n安装n模块<br>来进行管理.</li></ol><p>注: 因为之前测试发现npm install时有的依赖如node-sass会根据不同的系统环境安装不同的依赖版本,<br>即在linux环境中安装的依赖是不能直接拿到windows中使用的, 所以如果想切换的话需要重新安装,<br>这里在使用windows-terminal时, default shell打开WSL, 可以写个启动脚本使用fish shell.</p><p>写WSL启动执行脚本步骤:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. sudo vi /etc/init.wsl</span><br><span class="line">内容为</span><br><span class="line">#!/bin/sh</span><br><span class="line">fish</span><br><span class="line"></span><br><span class="line">sudo chmod +x /etc/init.wsl添加可执行权限</span><br><span class="line"></span><br><span class="line">2. windows系统中使用windows+r打开startup目录,创建WSL.vbs文件夹, 内容为:</span><br><span class="line">Set ws = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">ws.run &quot;wsl -d Ubuntu-18.04 -u root /etc/init.wsl&quot;, vbhide</span><br><span class="line">其中 wsl -d 为执行wsl版本, -u用户, 后面是可执行脚本</span><br><span class="line"></span><br><span class="line">3. 重启,测试, 发现无效果, 将上面的vbs脚本的vbhide去掉, 直接双击执行,发现弹出了fish窗口, </span><br><span class="line">可以想到fish毕竟不是服务, 这种方式只适合启动后台服务, 如ssh, cron等.</span><br><span class="line"></span><br><span class="line">4. 所以还是用老老实实使用命令`chsh -s /usr/bin/fish`修改默认shell为fish, 需要bash时直接切换即可.</span><br><span class="line">注: 我linux主机上是用了terminator的command命令实现的, 现在想来没有必要</span><br></pre></td></tr></table></figure></p><p>注: 原来cmder是通过git for windows实现了windows系统上运行linux命令, git for windows的<br>/usr/bin中可以看到如bash, mintty等多个shell运行方式.这样在cmder中执行npm install<br>安装的依赖自然就是windows环境中的了, 如此看来, windows terminal通过WSL实现了linux命令的<br>运行, 但命令的执行环境还是linux(外面是一个完整的ubuntu), 完成自己需要的功能时, 如启动java<br>项目, 启动node项目时具体什么环境是无关紧要的(毕竟最重要的是代码), 但如果需要进行迁移操作时,<br>这个时候cmder(或者说git for windows bash)还是无法替代的, 毕竟它是”原生”的windows环境.<br>而windows terminal还是只有最基础的cmd窗口.</p><p>经测试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同一个node项目, 在WSL中安装node(sudo apt安装)后执行npm install得到的node_modules在</span><br><span class="line">cmder(git for windows)中无法运行, 执行npm start报错failed to start, npm install报错</span><br><span class="line">unsupported platform, 删除node_modules后cmder安装自己的依赖即可成功.</span><br></pre></td></tr></table></figure></p><p>注: 使用ahk让快捷键F12快速启动cmder时发现问题，ahk脚本命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F12::run, D:\wtt\cmder\Cmder.exe</span><br></pre></td></tr></table></figure></p><p>这时启动cmder发现启动目录是startUp目录(我的脚本是放在启动目录中的), 经搜索可以改为如下命令，<br>经测试有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F12::run, D:\wtt\cmder\Cmder.exe /START D:\</span><br></pre></td></tr></table></figure></p><h2 id="升级到WSL2失败"><a href="#升级到WSL2失败" class="headerlink" title="升级到WSL2失败"></a>升级到WSL2失败</h2><p>WSL2虽然用了虚拟机技术, 但毕竟版本更新, 支持功能更多, 还是决定升到WSL2</p><ol><li>加入体验计划</li><li>打开或关闭windows功能中勾选虚拟平台, 重启电脑.</li><li><p>wsl –set-version option不存在, 查看到操作系统版本号1909, 但操作系统版本18363, 更新时<br>提示已经是最新版, 没啥办法只有等几天看看了, 估计和体验计划有关.</p><p>2021-04-05 13:11:07 added:<br>recently I got a new laptop and that is lenovo legion with company offering the partial<br>cost, in order to use emacs org mode, I install WSL2 with ubuntu system in it. Here is<br>what I learned from the machine installation process.</p><ol><li><p>only win10 professional system version has hyper-V, which is needed for WSL to run.<br>so the initial family version with legion is useless, and in order to use vmware<br>workstation, we need to install the workstation version bigger than 15.5 as I searched<br>online, I installed the lastest 15.5.7, and tested it on old thinkpad, and it worked<br>well together with WSL2, the latest version is 15.6, but it may have activation problem.</p></li><li><p>disk partition, the computer has two disks, I make the first disk the whole C partition,<br>as WSL default installed on it, and make C partition big enough is convenient, and the<br>second disk splits into two parts, first is D, and it contains software, and the second<br>E partition contains my code and documents. And I distinguished between work doc and code,<br>and my personal doc and code, and only one note directory.</p></li><li><p>first upgrade win10 to 20H2 version, 19042 latest build, this takes time, it needs<br>patient, and when it is done,  we can install WSL2 as tutorial, then install office,<br>and other necessary software, and that is quite a lot. Finally, transferring my code<br>and document, set up idea settings and upload ssh pub key, and need to use npm install to<br>make the project can run successfully. </p></li><li><p>I initially wanted to use emacs on real linux system, so I installed WSL2. and fish<br>shell is quite convenient. But I later found out git status command will work differently<br>on windows and linux system. For stability reason, I choose to use git command on<br>windows environment to avoid wierd trouble.</p></li><li><p>And my little project need to use local mysql or mariadb database, I want to install<br>it in WSL, but I failed to connect to it. and later I started a springboot project and<br>failed to visit its http service page from windows host, even though I later found out<br>it was the project code problem(had not run npm build in frontend project), but the<br>network connection and ports, firewall restriction between WSL and windows is troublesome,<br>but the benefit of putting database in WSL is trivial, so I installed mariadb on<br>windows instead at last.</p></li><li><p>git can not be used in linux here, and run <code>kill -9 $(ps -ef | grep java | awk &#39;{print $2}&#39;)</code>has bug running, finally I found out it need to be put in a function<br>rather than  only alias command, it is the same with git commit command which needs to use<br>$1 parameter to work.</p></li><li><p>so after testing, the WSL only effect is emacs org mode note, the fish shell has little<br>usage in my working laptop now.</p></li></ol></li></ol><h2 id="虚拟机折腾"><a href="#虚拟机折腾" class="headerlink" title="虚拟机折腾"></a>虚拟机折腾</h2><p>因为之前vmware fusion升级后有虚拟机长时间不用自动关机的毛病，后来又转回parallels desktop,<br>parallel v15目前没有破解版，但对于linux 内核5.3.26版本的linux经测试只有v15的parallel tool<br>才能正常使用，因为我有v14的破解版，所以我升级到v15的试用版后安装好tool, 再重新安装v14(它会<br>覆盖v15), 这样就可以正常使用了(后来在github上找到有人提供了修改parallel tools中的文件以支持<br>新版本linux内核的办法<a href="https://gist.github.com/mag911/1a5583a766467d6023584d738cee0d98" target="_blank" rel="noopener">github链接</a>)。<br>但装好parallel tool后发现使用xmonad不支持双屏，但xfce能正常支持。<br>注： 后来又发现安装好parallel tool的标志是标题栏中没有ctrl + alt释放鼠标的提示，从这点看<br>我还是没有安装成功，包括上面github链接的方法，所以parallel desktop中的ubuntu还是有问题，<br>但windows中的游戏运行非常顺畅，说明parallel对windows的支持是非常好的。</p><p>所以我还是要转回fusion, 使用vmware fusion的导入功能直接导入parallel的pvm文件后直接启动报错<br>找不到系统，所以再链接上iso文件，在原系统中再装一个ubuntu, 进入后使用disk工具将新装的系统<br>盘直接删除后重启报错，在grub界面设置root, prefix后normal命令启动，再sudo update-grub,<br>sudo grub-install /dev/sda后即可。<br>fusion启动xmonad后可以正常识别外接显示器，但分辨率有问题，<br>主屏幕是macbook, 外屏是hkc, 使用xrandr命令可以正常设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xrandr --output Virtual1 --mode &quot;1440x900&quot;</span><br><span class="line">xrandr --output Virtual2 --mode &quot;1440x2560&quot;</span><br></pre></td></tr></table></figure></p><p>可以将它放入.xsessionrc中。<br>注: 经测试直接将xrandr命令放入.xsessionrc中无效，目前有效的办法只有在进入xmonad后，确定<br>两边屏幕是独立工作空间(切换全屏来实现)后，执行上述2个命令，将上面2个命令放入一个脚本中<br>方便执行，目前由于key.sh的键盘映射用不到，所以放入key.sh中即可。</p><p>注: 我的键盘设置如capslock to esc, left shift to left parenthesis, space to ctrl的设置在<br>macbook kerabiner中全局设置了，所以虚拟机中无需使用key.sh和xcape命令，这里记录下防止以后<br>忘记。</p><h2 id="thinkpad外接显示屏"><a href="#thinkpad外接显示屏" class="headerlink" title="thinkpad外接显示屏"></a>thinkpad外接显示屏</h2><p>最近由于疫情隔离在家远程办公, 工作用的thinkpad在家里派上用场了, 突然想到它也可以外接我的<br>大显示器. 原以为需要另外买一根hdmi线, 但是发现thinkpad t540p也是有dp接口的, 插上试试果然可以<br>使用, 首先在ubuntu wayland中使用, 同mac系统一样在display中拖拽一下2个屏幕的位置就ok了.<br>打开xmonad发现2个屏幕是克隆(即同步显示相同内容)的关系. 使用命令<code>nvidia-settings</code>打开nvidia<br>设置窗口, 发现它给出提示外接大屏无法被nvidia控制, 于是又切换回ubuntu wayland界面, 在<br>software update中将显卡驱动由nvidia改为xorg, 再登录xmonad发现没有克隆了.通过拖拽窗口发现<br>2个大屏合并为了一个大屏, 还是没有实现xmonad不同屏幕不同工作空间的功能, 切换屏幕的快捷键<br>也无效. 关于双屏设置, 网上有2种方案, 一个就是xrandr命令, 另一个是xorg.config配置文件,<br>因为我对xrandr命令用的比较多, 所以使用xrandr命令, 使用以下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xrandr --auto --output DP-1 --left-of eDP-1</span><br></pre></td></tr></table></figure></p><p>其中DP-1是大屏代号, eDP-1是thinkpad, 一运行发现就ok了, 屏幕切换的快捷键也可以使用了.<br>将这条命令放入.xsessionrc中执行的key.sh脚本中开机自动执行即可.</p><p>注: 以上是2个屏幕同时水平横置的情况, 写代码时通常需要让大屏垂直放置.这时可以在以上命令<br>中加上一个参数即可实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xrandr --auto --output DP-1 --rotate right --left-of eDP-1</span><br></pre></td></tr></table></figure></p><p>其中, rotate参数值有left, right, normal, inverted4种, 具体根据自己屏幕的旋转方向选择.</p><p>再注: 虚拟机windows系统打开后发现屏幕方向是横向的, 且是灰色状态, 无法修改, 后经搜索,<br>发现只要安装了vmware tools, 它是可以修改的, 但我已经安装了vmware tool, 于是尝试进行全屏<br>切换操作, 虚拟机就自动转换为竖屏了, 这里记录下, 对于虚拟机, 切换全屏是让vmware tool生效<br>的好方法.<br>注: 用于工作的windows虚拟机又无法在竖屏状态下正确设置分辨率了…, 折腾了半天,<br>关键还是在vmware tool上, vmx里的backdoor还是要设置为false使其成为真正的虚拟机.<br>其他设置有:</p><ol><li>vmware settings -&gt; display -&gt; autodect host settings for monitor即可. </li><li>view -&gt; autosize -&gt; autofit guest ,  non check autofit window.<br>实际上,可以先将分辨率设置为横屏的2560x1440后再重启切换全屏, 在vmware-tools生效的情况下<br>应该就可以正常展示出竖屏效果了.</li></ol><h2 id="old-mac-install-manjaro"><a href="#old-mac-install-manjaro" class="headerlink" title="old mac install manjaro"></a>old mac install manjaro</h2><p>pacman command:<br>sudo pacman -S 软件名　# 安装<br>sudo pacman -R 软件名　# 删除单个软件包，保留其全部已经安装的依赖关系<br>sudo pacman -Rs 软件名 # 除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系<br>sudo pacman -Ss 软件名  # 查找软件<br>sudo pacman -Sc # 清空并且下载新数据<br>sudo pacman -Syu　# 升级所有软件包<br>sudo pacman -Qs # 搜索已安装的包</p><p>yay command:<br>yay -S package # 从 AUR 安装软件包<br>yay -Rns package # 删除包<br>yay -Syu # 升级所有已安装的包<br>yay -Ps # 打印系统统计信息<br>yay -Qi package # 检查安装的版本</p><ol><li>install</li><li>sudo pacman-mirrors -c China -m rank</li><li><p>update source: archlinuxcn antergos arch4edu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Optional TrustedOnly</span><br><span class="line">#中科大源</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br><span class="line">#清华源</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br><span class="line"></span><br><span class="line">[antergos]</span><br><span class="line">SigLevel = TrustAll</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/antergos/$repo/$arch</span><br><span class="line"></span><br><span class="line">[arch4edu]</span><br><span class="line">SigLevel = TrustAll</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch</span><br></pre></td></tr></table></figure></li><li><p>sudo pacman-mirrors -g</p></li><li>sudo pacman -Syyu</li><li>sudo pacman -S archlinuxcn-keyring</li><li>sudo pacman -S antergos-keyring</li><li><p>before install fcitx, change locale to chinese<br>sudo pacman -S fcitx-im // install all<br>sudo pacman -S fcitx-configtool</p></li><li><p>vi ~/.xprofile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure></li><li><p>sudo pacman -S yay</p></li><li>yay –aururl “<a href="https://aur.tuna.tsinghua.edu.cn&quot;" target="_blank" rel="noopener">https://aur.tuna.tsinghua.edu.cn&quot;</a> –save</li><li>yay -P -g  // confirm the change</li><li>yay -Syu  // update like pacman</li><li><p>before install v2ray, git… etc, install graphic driver for<br>manjaro on mac according to archLinux wiki for mac<br>lspci | grep VGA    // intel corporation …<br>sudo pacman -S xf86-video-intel</p></li><li><p>yay -S xmonad xmonad-contrib</p></li><li>yay -S vim fish git</li><li>which fish // /usr/bin/fish<br>chsh -s /usr/bin/fish</li><li>git config –global user.name “wutaotao”<br>git config –global user.email “<a href="mailto:531618500@qq.com" target="_blank" rel="noopener">531618500@qq.com</a>“<br>ssh-keygen -t rst -C “<a href="mailto:531618500@qq.com" target="_blank" rel="noopener">531618500@qq.com</a>“</li><li>git clone  xxx.xmonad.config ~/.xmonad</li><li>yay -S xmobar dmenu xscreensaver stalonetray feh</li><li>copy .vimrc</li><li>yay -S curl</li><li>yay -S v2ray  // systemctl enable it and change config</li><li>yay -S proxychains-ng<br>sudo vim /etc/proxychains.conf<br>socks5 127.0.0.1 1080  // modify the old example<br>proxychains curl <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>   // usage and test</li><li>yay -S google-chrome</li><li>google-chrome-stable –proxy-server=socks5://127.0.0.1:1080    // can not add / at last position!</li><li>proxychains git clone <a href="https://github.com/VundleVim/Vundle.vim.git" target="_blank" rel="noopener">https://github.com/VundleVim/Vundle.vim.git</a> ~/.vim/bundle/Vundle.vim</li><li>proxychains vim</li><li>:PluginInstall</li></ol><h2 id="ubuntu-server-18-04-resize-disk-size"><a href="#ubuntu-server-18-04-resize-disk-size" class="headerlink" title="ubuntu server 18.04 resize disk size"></a>ubuntu server 18.04 resize disk size</h2><p>this is the way to enlarge the ubuntu file disk size.</p><ol><li>enlarge the vmware guest system SCSI disk size from 20G to 40G.</li><li>fdisk /dev/sda to create a new partition 20G, linux file system type.<br>it can also be done using cfdisk etc.<br>here the original disk partition is /dev/sda3, new one is /dev/sda4</li><li>create physical volume on new created partition /dev/sda4<br><code>pvcreate /dev/sda4</code><br>use pvdisplay to check the result.</li><li>extend the logical volume group to use the new physical volume too.<br><code>sudo vgs</code>, <code>sudo vgdisplay</code>   // get the logical volume group name<br><code>sudo vgextend ubuntu-vg /dev/sda4</code><br>use sudo vgs to check results</li><li>extend the logical volume to use the newly extended size<br><code>sudo lvs</code>, <code>sudo lvdisplay</code>   // get the logical volume path<br><code>sudo lvextend -l +100%FREE /dev/ubuntu-vg/ubuntu-lv</code><br>use sudo lvs to check results</li><li>resize logical volume<br><code>sudo resize2fs /dev/ubuntu-vg/ubuntu-lv</code> // still use the lv path</li><li>check result<br><code>df -lh</code><br>done!</li></ol><h2 id="dual-boot-with-ubuntu-server-and-centos-server-with-remote-ssh"><a href="#dual-boot-with-ubuntu-server-and-centos-server-with-remote-ssh" class="headerlink" title="dual boot with ubuntu server and centos server with remote ssh"></a>dual boot with ubuntu server and centos server with remote ssh</h2><ol><li>install ubuntu server first, 2 partitions, /, /boot, the /boot can not be omitted for<br>the dual boot installation.</li><li>then install centos server, need to remove ubuntu swap first, then it’s possible to<br>create centos /boot partition, and we can only create swap in centos os.</li><li>use the following command to set the default bootable os<br><code>txtawk -F\&#39; &#39;$1==&quot;menuentry &quot; {print i++ &quot; : &quot; $2}&#39; /etc/grub2.cfggrub2-editenv listgrub2-set-default 2grub2-editenv list`</code><br>after reboot, we can find the default os is 2, ubuntu, we can choose back to centos in<br>startup menu, i have not found a way to set the default value after entering ubuntu system.<br>so it’s necessary to use monitor and keyboard to switch oses.</li></ol><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190510_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux, RHEL 7&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.taoblog.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.taoblog.cn/tags/Linux/"/>
    
      <category term="RHEL 7" scheme="http://www.taoblog.cn/tags/RHEL-7/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 重装笔记</title>
    <link href="http://www.taoblog.cn/post/8b2fd91d/"/>
    <id>http://www.taoblog.cn/post/8b2fd91d/</id>
    <published>2019-04-14T07:30:26.000Z</published>
    <updated>2020-03-28T16:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>MacOS<br><a id="more"></a></p><h2 id="重装mac"><a href="#重装mac" class="headerlink" title="重装mac"></a>重装mac</h2><ol><li>重启mac,command+R进入恢复模式</li><li>抹掉整个硬盘，重新安装</li><li>升级到MacOS Mojave<h2 id="装软件"><a href="#装软件" class="headerlink" title="装软件"></a>装软件</h2></li><li>修改输入法，简体双拼中有小鹤输入，不用装搜狗了！</li><li>装百度网盘，从上面下载lantern客户端，这样下载快一点，github很慢。</li><li>lantern授权后，装google浏览器，登录，同步。</li><li>安装homebrew，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"># 现在不用再手动装cask了，homebrew里已自带</span><br></pre></td></tr></table></figure></li></ol><p>注： 在以上安装过程中，发现会卡死，速度很慢，网上有很多说使用镜像的，但有人觉得不好，<br>又发现有人说使用SS代理，我使用的是蓝灯，所以搜到了使用lantern来为git http方法进行代理的<br>方法，其他命令如curl等也可以设置。</p><p>git为设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;http://127.0.0.1:49612&apos;</span><br><span class="line">git config --global https.proxy &apos;https://127.0.0.1:49612&apos;</span><br></pre></td></tr></table></figure></p><p>以上具体端口查看lantern高级设置里有。</p><p>curl等其他工具http代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:49612</span><br><span class="line">export https_proxy=http://127.0.0.1:49612</span><br></pre></td></tr></table></figure></p><ol start="5"><li><p>本来想装insomniax来使得合盖外接显示屏，highSeria上可以正常运行，但Mojava上就运行不了，<br>无论是开启允许任意来源<code>sudo spctl --master-enable</code>,还是辅助功能里允许InsomniaX完全控制都<br>不能实现合盖不休眠的功能，只能解释为Mojave把相应功能屏蔽了。习惯了合盖模式外接显示屏的我<br>甚至想装回原来的High Seira,但女朋友说辛苦装的，还是用几天，早上醒来想想，还是正常升级系统，<br>用不了合盖模式也行，苹果只支持充电的时候可以合盖，合盖容易引起发热问题等，所以我就把大显示<br>屏用鞋盒垫高，下面放笔记本，就用双屏吧，以后看看能实现Xmonad在ubantu虚拟机内的多屏显示功能<br>么，或者macOS的实现-Amethyst能支持么—–To be continued.</p></li><li><p>安装vmware fusion 11,并安装ubantu 18.04 LTS,恢复备份等,想想还是不装parallel desktop了，<br>目前我的thinkpad用的是vmware workstation,为了以后迁移方便，就统一使用vm吧。</p></li><li><p>vmware中给ubantu虚拟机安装vmware-tools,在虚拟机选项中选择安装vmware-tools,ubantu中出现<br>一个外接光盘，将压缩包拷贝到download目录后解压(不能直接解压)，执行命令<code>sudo ./vmware-tool-install.pl</code>, 一直回车即可。</p></li><li><p>mac自带vim不支持共享剪贴板的问题<br>mojave上的vim –version显示-clipboard,不支持共享系统剪贴板。<br><code>brew install vim</code><br>安装了python,sqllite,ruby,perl等依赖后，执行<code>which vim</code>，发现路径已经变掉了，<br>再重新打开一个终端，在.vimrc中加入（一开始字母写错了，总报错还不知道为什么……)<br><code>set clipboard=unnamed</code></p></li></ol><h2 id="mac崩溃记"><a href="#mac崩溃记" class="headerlink" title="mac崩溃记"></a>mac崩溃记</h2><p>昨天刚更新到macOS 10.15.4, 结果今天发现鼠标滑动变卡了，而且破解版的mac cleaner也不能用了，<br>又是一次头脑发热的升级……, 更致命是后面win10虚拟机的操作，当时刚把c盘压缩后新建了d盘，<br>并清理了软件安装包，然后我发现电脑空间还是不足，发现虚拟机总共才70G, 而parallel占用了140G,<br>应该是快照的原因， 这时致命操作来了， 我在虚拟机运行的情况下做删除快照的操作！并且是删除<br>当前和其子类快照，显示一个进度条缓慢增加到4%时，电脑卡住，再过一会直接关机报出日文错误。<br>重启后虚拟机启动不了，鼠标又卡的要命！只能重装系统！还好我有timeMachine之前的备份。</p><p>开机时应该是按住option键(不确定)进入修复页面，选择从timeMachine恢复，耐心等待，刚开始显示<br>有5,6个小时，还好后面实际不用这么久，大概2个多小时就好了，自动重启。这时另一个坑出来了，<br>登录后输入密码，回车，出现个框一直在转圈loading, 上网查有人说是要输入appleId, 他插根网线<br>就好了，我的苹果没法插网线！但是知道原因就好办了！原来是要连Apple服务器！我只需要反过来，<br>拔网线–即关闭路由器就可以了，它连不了网当然会乖乖进入脱机模式！事实证明果然如此，正常启动<br>成功后，wifi无法链接，这时进行常规操作，删除wifi后新建，成功上网，重新登录icloud, 成功！</p><p>总结：</p><ol><li>备份非常重要，timeMachine对mac外部系统备份，2个虚拟机，win10, ubuntu文件本身需要备份。</li><li>虚拟机运行时严禁进行快照操作，要保存快照也应该挂起后进行，否则也非常慢，删除快照更是<br>致命，直接搞挂电脑。<br>切记切记！ written at 2020-03-29 00:00:13 </li></ol><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190415_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MacOS&lt;br&gt;
    
    </summary>
    
      <category term="Mac" scheme="http://www.taoblog.cn/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://www.taoblog.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>个人经验总结散记</title>
    <link href="http://www.taoblog.cn/post/b703434b/"/>
    <id>http://www.taoblog.cn/post/b703434b/</id>
    <published>2019-03-15T12:05:01.000Z</published>
    <updated>2021-09-28T02:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Test-driven Coding<br><a id="more"></a></p><h2 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h2><p>问题:</p><blockquote><p>今天下午在写一个微服务调用的挡板，但是报错javax-message找不到，因为jar包都是建行里自己<br>封装的包，所以确定是jar包冲突了，其中还有jar包版本号的问题，开始不知道怎么处理，最后才<br>开始想到一个个添加jar包来查看是哪个包的问题，最后终于找到了出问题的包，后面才能把交易<br>跑通。</p></blockquote><p>分析:</p><blockquote><p>因为之前做过demo，对于需要配置哪些依赖包，哪些注解，接口都很清楚，所以就一下子把<br>所有的代码，配置等全写好，但这样一报错就无法找出问题根源。因为底层的jar包依赖发生了变化，所以<br>会出现之前没有发现过的问题。</p></blockquote><p>总结:</p><blockquote><p>除非是百分百确定没有任何变数(基本是不可能的，实际工作中不可能会重复做相同的工作),我们<br>做开发(做其他事情也一样)时，需要阶段性的做测试工作，可以借助版本控制工具等来确定前期<br>工作的正确和稳定性，相当于快速迭代开发。如建房子一样，先打好地基，一步一步稳步前行，这样<br>才能及时发现问题，保证工作质量。</p></blockquote><h2 id="上线总结"><a href="#上线总结" class="headerlink" title="上线总结"></a>上线总结</h2><p>after I changed my career path, this kind of publish code online activities will be less<br>in the future. So it is reasonable and valuable to record the lessons learned from the<br>mistakes I have made.</p><p> 2020-12-25 07:18:47 added:<br>Last night, after about 2.5 months developing time, the gis 2.0 web site finally go online,<br>here is two lessons I learned:</p><ol><li>press ctrl + z in one directory in windows server affects other directories as well,<br>as it rolls back my uploaded code in other directories.</li><li>if simply change data in database is difficult, like change different fields in different<br>tables, but it have fixed pattern, like uploaded files path, then just modify the<br><strong>sql script</strong> with replaceAll method is convenient, <strong>always remember the text file power</strong></li></ol><h2 id="how-to-write-recursive-method-easily"><a href="#how-to-write-recursive-method-easily" class="headerlink" title="how to write recursive method easily"></a>how to write recursive method easily</h2><p>yesterday I write a tree-building class with ruby, I use recursive method to build it,<br>after working hard I finally made it, and I summarize the points to write recursive method:</p><ol><li>do your own job first</li><li>handle your children’s job nicely<br>PS: the input to you and to your children is the same!</li></ol><p>It feels like the Chinese traditional philosophy, pursuit the inner saint and outer king.<br>The truth is the same. Not only to hierarchical data but also network data as well.</p><h2 id="consciousness-about-coding"><a href="#consciousness-about-coding" class="headerlink" title="consciousness about coding"></a>consciousness about coding</h2><p>I have been coding for 5 years, not designing, like labour worker vs architect differences,<br>a few days ago I watched supermap’s conference video, as thinking about career path meanwhile,<br>then the question came to me what exactly is designing a software after all, just jumping<br>out of coding farmersrestriction does not mean you can think outside it, this needs<br>cousciousness in a flash.<br>Changing view positions can mean something, for learning computer technology/software design<br>/product design/system design like my reading other books like philosophy and math, the<br>key point here is peaceful mind and little steady progress forward.</p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190315_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Test-driven Coding&lt;br&gt;
    
    </summary>
    
      <category term="Thought" scheme="http://www.taoblog.cn/categories/Thought/"/>
    
    
      <category term="Thought" scheme="http://www.taoblog.cn/tags/Thought/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis学习笔记</title>
    <link href="http://www.taoblog.cn/post/7fd48667/"/>
    <id>http://www.taoblog.cn/post/7fd48667/</id>
    <published>2019-03-07T07:59:42.000Z</published>
    <updated>2020-09-29T07:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis note, Log4J, Log4J2, SLF4J,<br><a id="more"></a></p><h2 id="基本mybatis配置"><a href="#基本mybatis配置" class="headerlink" title="基本mybatis配置"></a>基本mybatis配置</h2><ol><li><p>pom.xml<br>指明需要的依赖包，mybatis和mysql-connector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.38&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>mybatis-config.xml<br>mybatis的配置，如实体类所在包的别名，JDBC配置，Mapper.xml文件路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--指定mybatis日志输出工具为log4J,因为Mybatis默认会按以下顺序查找不同的日志实现工具，</span><br><span class="line">  slf4j -&gt; apache common logging -&gt; log4j2 -&gt; log4j -&gt; JDK logging</span><br><span class="line">  所以在配置中进行指定可以保证日志的正常记录--&gt;</span><br><span class="line">  &lt;settings&gt;</span><br><span class="line">    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;</span><br><span class="line">  &lt;/settings&gt;</span><br><span class="line"></span><br><span class="line">  &lt;typeAliases&gt;</span><br><span class="line">    &lt;package name=&quot;com.model&quot;/&gt;  &lt;!--这里的别名是用于mapper.xml中如resultType可以不写全名--&gt;</span><br><span class="line">  &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">  &lt;environments default=&quot;development&quot;&gt; &lt;!--JDBC配置--&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">      &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">      &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">      &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">  &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">  &lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mapper/mybatisMapper.xml&quot;/&gt;  &lt;!--指定sql语句和映射文件的路径--&gt;</span><br><span class="line">  &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>实体类和Mapper.xml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--当前Mapper.xml的命名空间,它与sql语句的id联合起来可以被sqlSession定位识别调用,</span><br><span class="line">这与对象的全限定名调用非常相似，也就为mybatis的注解实现提供了基础--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;mapper.mybatisMapper&quot;&gt;  </span><br><span class="line"></span><br><span class="line">  &lt;select id=&quot;selectAll&quot; resultType=&quot;Country&quot;&gt;</span><br><span class="line">    select * from Country</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写单元测试运行mybatis<br>mybatis核心是sqlSessionFactory,SqlSession类，可以在测试类中使用它们来手工进行数据查询操作，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory;</span><br><span class="line">try &#123;</span><br><span class="line">    Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);</span><br><span class="line">    sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">    reader.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">try &#123;</span><br><span class="line">    List&lt;Country&gt; countryList = sqlSession.selectList(&quot;selectAll&quot;);</span><br><span class="line">    for (Country country : countryList) &#123;</span><br><span class="line">        System.out.println(country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注：作用域和生命周期</p><table><thead><tr><th>对象</th><th>作用域</th><th>实例个数推荐</th><th>说明</th></tr></thead><tbody><tr><td>sqlSessionFactoryBuilder</td><td>方法作用域</td><td>一个就够</td><td>用来创建一个或多个sqlSessionFactory,用完即删</td></tr><tr><td>sqlSessionFactory</td><td>应用作用域</td><td>单例模式</td><td>一旦创建应当在应用运行期间一直存在</td></tr><tr><td>sqlSession</td><td>请求或方法作用域</td><td>单线程</td><td>线程不安全，如请求时生成，返回响应后关闭它</td></tr><tr><td>Mapper接口实例</td><td>方法作用域</td><td>单线程</td><td>由sqlSession创建，但调用完相应数据操作接口后即可关闭</td></tr></tbody></table><ol start="5"><li>SLF4J<br>SLF4J是一个日志处理抽象层，不提供具体的日志实现，它可以与具体的日志工具进行整合，如Log4J,<br>Log4J2, LogBack, JDK日志等。适用于工具库中使用，如MQ，redis等,当这些工具被整合进具体的项目<br>中时，可以使用slf4j与不同具体实现的整合包进行<strong>静态绑定</strong>日志,从而避免了多套日志系统的麻烦。</li></ol><p>工具类中只需要使用slf4j-api即可(发布时只发布这个包，工具开发中可以自行整合)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>slf4j整合其他日志实现依赖为：</p><ol><li><p>log4j:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>logback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>由于slf4j没有自己的实现，如果想要在老项目更新slf4j的日志实现，如从commons logging转换到<br>logback，需要进行jar包处理。<br>这种情况可以使用jcl-over-slf4j.jar桥接器来进行日志的重定向。日志流转过程如下：</p><blockquote><p>java common logging -&gt; jcl-over-slf.jar -&gt; slf4j -&gt; slf4j-log4j12-version.jar -&gt;<br>log4j.jar -&gt; 输出日志</p></blockquote><p>值得注意的是这种重定向有死循环的危险，如本来就是log4j的实现，又添加了桥接器log4j-over-slf4j,<br>那么就是log4j-&gt;slf4j-&gt;log4j,造成死循环，此时要么去掉桥接器，要么改变slf4j的实现方式，如<br>logback.</p><blockquote><p>slf4j提供的适配库和桥接库<br>适配库：<br>slf4j-log4j12：使用log4j-1.2作为日志输出服务<br>slf4j-jdk14：使用java.util.logging作为日志输出服务<br>slf4j-jcl：使用JCL作为日志输出服务<br>slf4j-simple：日志输出至System.err<br>slf4j-nop：不输出日志<br>log4j-slf4j-impl：使用log4j2作为日志输出服务<br>// logback天然与slf4j适配，不需要额外引入适配库（毕竟是一个作者写的）<br>桥接库：<br>log4j-over-slf4j：将使用log4j api输出的日志桥接至slf4j<br>jcl-over-slf4j：将使用JCL api输出的日志桥接至slf4j<br>jul-to-slf4j：将使用java.util.logging输出的日志桥接至slf4j<br>log4j-to-slf4j：将使用log4j2输出的日志桥接至slf4j</p></blockquote><p>java中使用slf4j记录日志，slf4j有自己独特的占位符参数，可以减少string连接的消耗，而且它不<br>需要像log4j那样用<code>logger.isDebugEnabled()</code>来判断日志开启的级别再来输出日志，slf4j会自动<br>判断当前日志级别确定是否生成该条日志。</p><blockquote><p>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;<br>private static final Logger LOGGER = LoggerFactory.getLogger(XXX.class);<br>LOGGER.info(“{}”, object);</p></blockquote><ol start="6"><li><p>Log4J 基本使用</p><ol><li><p>依赖<br>使用slf4j用以上依赖配置即可，不使用slf4j时仅需要引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在src/main/resources下新建配置文件log4j.properties：</p><ol><li>配置根logger<br>指定日志级别和日志输出到什么地方去。<blockquote><p>log4j.rootLogger=ERROR, stdout  #输出ERROR级别，输出到配置的stdout中</p></blockquote></li></ol><p>level建议设置的有ERROR,WARN,INFO,DEBUG<br>appenderName可以同时指定多个不同的值</p><ol start="2"><li>配置日志输出地Appender<blockquote><p>log4j.appender.stdout=org.apache.log4j.ConsoleAppender<br>log4j.appender.stdout.layout=org.apache.log4j.PatternLayout<br>log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</p></blockquote></li></ol><p>第一行为appender的全限定名, 一般有如下几种：</p><blockquote><p>org.apache.log4j.ConsoleAppender    # 控制台<br>org.apache.log4j.FileAppender      # 文件<br>org.apache.log4j.DailyRollingFileAppender # 每天产生一个日志文件<br>org.apache.log4j.RollingFileAppender # 日志文件到达一定大小就记录到一个新的日志文件中<br>org.apache.log4j.WriteAppender   # 日志信息以流格式发送到任意地方</p></blockquote><p>第二行为appender的布局，有以下几种：</p><blockquote><p>org.apache.log4j.HTMLLayout    # 以HTML格式布局,生成html标签，适合输出到html文件中观看<br>org.apache.log4j.PatternLayout    # 灵活布局<br>org.apache.log4j.SimpleLayout    # 日志级别和日志信息 %l %m%n<br>org.apache.log4j.TTCCLayout    # 线程，级别，所在方法，信息  %t %l %M %m%n</p></blockquote><p>第三行为appender的日志格式化控制，常用的有</p><blockquote><p>%m 或%msg  message 代码中指定输出的日志信息，如logger.info(“log message printed.”)<br>%p priority 日志信息级别<br>%t 或tn threadname 产生该日志的线程名<br>%T 或tid threadId 该日志线程ID<br>%d date 产生日志的时间点 可以在后面指定格式，如%d{yyyy MM dd HH:mm:ss,SSS}<br>%l location 产生日志的位置 如Test.main(Test.java:10) 该项性能损耗很大，应避免开启<br>%c class 所在类的全名<br>%r relative time  产生日志时间点距离应用启动经过的时间毫秒数<br>%n 换行符 windows:rn  unix:n<br>%M method 所在方法<br>%xEx exception 异常信息</p></blockquote></li><li><p>在java中使用</p><blockquote><p> import org.apache.log4j.Logger;<br>private static final Logger LOGGER = Logger.getLogger(XXX.class);<br>LOGGER.info(object);</p></blockquote></li></ol></li><li><p>Log4J2<br>apache官方宣布Log4J已经停止支持，现在需要转向新的Log4J2日志框架。同时宣称它提供了logback<br>的一些改进，并解决了logback的一些问题。</p><ol><li><p>依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--slf4j与log4j2整合--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.11.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--log4j2 jar--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.11.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.11.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>src/main/resources中新建配置文件log4j2.xml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--status 为log4j2自身信息日志的级别--&gt;</span><br><span class="line">&lt;configuration status=&quot;error&quot;&gt;</span><br><span class="line">    &lt;!-- 先定义所有的appender --&gt;</span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;!-- 这个输出控制台的配置 --&gt;</span><br><span class="line">        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;</span><br><span class="line">            &lt;!-- 控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝(onMismatch)--&gt;</span><br><span class="line">            &lt;ThresholdFilter level=&quot;trace&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;</span><br><span class="line">            &lt;!-- 这个都知道是输出日志的格式 --&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;</span><br><span class="line">        &lt;/Console&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，</span><br><span class="line">        这个也挺有用的，适合临时测试用 --&gt;</span><br><span class="line">        &lt;!-- append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，</span><br><span class="line">        默认值是true --&gt;</span><br><span class="line">        &lt;File name=&quot;log&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;</span><br><span class="line">        &lt;/File&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 添加过滤器ThresholdFilter,可以有选择的输出某个级别以上的类别  onMatch=&quot;ACCEPT&quot;</span><br><span class="line">        onMismatch=&quot;DENY&quot;意思是匹配就接受,否则直接拒绝  --&gt;</span><br><span class="line">        &lt;File name=&quot;ERROR&quot; fileName=&quot;logs/error.log&quot;&gt;</span><br><span class="line">            &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;</span><br><span class="line">            &lt;PatternLayout</span><br><span class="line">             pattern=&quot;%d&#123;yyyy.MM.dd &apos;at&apos; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;</span><br><span class="line">        &lt;/File&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 这个会打印出所有的信息，每次大小超过size，</span><br><span class="line">        则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt;</span><br><span class="line">        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;logs/web.log&quot;</span><br><span class="line">                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/web-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;</span><br><span class="line">            &lt;PatternLayout</span><br><span class="line">             pattern=&quot;%d&#123;yyyy-MM-dd &apos;at&apos; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;</span><br><span class="line">            &lt;SizeBasedTriggeringPolicy size=&quot;2MB&quot;/&gt;</span><br><span class="line">        &lt;/RollingFile&gt;</span><br><span class="line">    &lt;/appenders&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;</span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line">        &lt;!-- 建立一个默认的root的logger --&gt;</span><br><span class="line">        &lt;root level=&quot;trace&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;Console&quot;/&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;ERROR&quot;/&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;log&quot;/&gt;</span><br><span class="line">        &lt;/root&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/loggers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>java中使用</p><blockquote><p>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;<br>private static final Logger LOGGER = LoggerFactory.getLogger(XXX.class);<br>LOGGER.info(“{}”, object);<br>注： log4j2性能提高了很多，配置更清晰化，slf4j + log4j2方案目前可以使用。</p></blockquote></li></ol></li></ol></li><li><p>LogBack<br>2020-04-06 11:44:42 添加:<br>Springboot默认集成了logBack, 即spring-boot-starter-logging包中集成了logBack的实现。<br>在application.yml中配置logging.file=xxx.log或logging.path=/var/log/xx.log即可生成日志文件，<br>但涉及到文件大小或日期控制，或不同环境不同的log配置时，就需要用到自定义的配置文件如<br>logback.xml或logback-spring.xml(推荐).<br>(可以通过如logging.config=classpath: logging-config.xml指定配置文件的名称，但这样做意义不大)</p><ol><li>依赖</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>resources下新建配置文件logback-spring.xml(只有这样才能使用springProfile标签)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;</span><br><span class="line">&lt;!--    &lt;contextName&gt;logback&lt;/contextName&gt;--&gt;</span><br><span class="line">    &lt;property name=&quot;log.path&quot; value=&quot;/home/tao/Documents/note/&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--日志格式控制 --&gt;</span><br><span class="line">    &lt;!-- %-50loggger&#123;50&#125; 中 -50 是格式化类名左对齐,右边空白, 这样类名和消息隔开,</span><br><span class="line">         利于查看. </span><br><span class="line">         50是最小长度, 如果写法为%20.30, 则控制了最大长度30, 它会截取字符串,</span><br><span class="line">         这会将类名截取掉.</span><br><span class="line">    我们用logger&#123;50&#125; 是控制类名缩写, 它软性控制了最大长度, 因为不会截取类名, 所以类名过长</span><br><span class="line">    时会超出限制, 所以这个最大值不能过小, 这里设置为50即可.</span><br><span class="line">     p: priority</span><br><span class="line">     t: thread</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;property name=&quot;pattern&quot; value=&quot;[APP][%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125;][%-5p][%t][%-50logger&#123;50&#125;]%m%n&quot;/&gt;</span><br><span class="line">    &lt;!--输出到控制台--&gt;</span><br><span class="line">    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">      &lt;encoder&gt;</span><br><span class="line">        &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt;</span><br><span class="line">        &lt;charset&gt;utf-8&lt;/charset&gt;</span><br><span class="line">      &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;springProfile name=&quot;dev&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;root level=&quot;info&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;console&quot;/&gt;</span><br><span class="line">      &lt;/root&gt;</span><br><span class="line">      &lt;!-- print sql with using dao logger --&gt;</span><br><span class="line">      &lt;logger name=&quot;com.ccb.backend.dao&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;console&quot;/&gt;</span><br><span class="line">      &lt;/logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/springProfile&gt;</span><br><span class="line"></span><br><span class="line">    &lt;springProfile name=&quot;test,prod&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--输出到文件--&gt;</span><br><span class="line">&lt;!--      &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;--&gt;</span><br><span class="line">&lt;!--        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;--&gt;</span><br><span class="line">&lt;!--          &lt;fileNamePattern&gt;$&#123;log.path&#125;/logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;--&gt;</span><br><span class="line">&lt;!--        &lt;/rollingPolicy&gt;--&gt;</span><br><span class="line">&lt;!--        &lt;encoder&gt;--&gt;</span><br><span class="line">&lt;!--          &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;--&gt;</span><br><span class="line">&lt;!--        &lt;/encoder&gt;--&gt;</span><br><span class="line">&lt;!--      &lt;/appender&gt;--&gt;</span><br><span class="line"></span><br><span class="line">      &lt;appender name=&quot;rolling&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">          &lt;!-- rollover daily --&gt;</span><br><span class="line">          &lt;fileNamePattern&gt;$&#123;log.path&#125;/%d&#123;yyyy-MM-dd&#125;.%i.txt&lt;/fileNamePattern&gt;</span><br><span class="line">          &lt;!-- each file should be at most 100MB, keep 60 days worth of history, but at most 20GB --&gt;</span><br><span class="line">          &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;</span><br><span class="line">          &lt;!-- 14 days--&gt;</span><br><span class="line">          &lt;maxHistory&gt;14&lt;/maxHistory&gt;</span><br><span class="line">          &lt;totalSizeCap&gt;10GB&lt;/totalSizeCap&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">          &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt;</span><br><span class="line">          &lt;charset&gt;utf-8&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">      &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">      &lt;root level=&quot;info&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;rolling&quot;/&gt;</span><br><span class="line">      &lt;/root&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- print sql with using dao logger --&gt;</span><br><span class="line">      &lt;logger name=&quot;com.ccb.backend.dao&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;rolling&quot;/&gt;</span><br><span class="line">      &lt;/logger&gt;</span><br><span class="line">    &lt;/springProfile&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>注: 经测试，当文件大小设置过小时，如5kb，文件大小切分不均匀，增大到20kb时文件大小就在<br>20kb时，文件大小就切分的比较好，大概在20-30kb间，最后一个文件大小是50kb, 由此可以看出<br>切分文件是异步过程。这里设置为100MB，后续观察实际使用情况。</p><p>another example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--scan:</span><br><span class="line">            当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</span><br><span class="line">scanPeriod:</span><br><span class="line">            设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。</span><br><span class="line">            默认的时间间隔为1分钟。</span><br><span class="line">debug:</span><br><span class="line">            当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</span><br><span class="line"></span><br><span class="line">configuration 子节点为 appender、logger、root</span><br><span class="line">--&gt;</span><br><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;</span><br><span class="line">    &lt;!--用于区分不同应用程序的记录--&gt;</span><br><span class="line">    &lt;contextName&gt;edu-cloud&lt;/contextName&gt;</span><br><span class="line">    &lt;!--日志文件所在目录，如果是tomcat，如下写法日志文件会在则为$&#123;TOMCAT_HOME&#125;/bin/logs/目录下--&gt;</span><br><span class="line">    &lt;property name=&quot;LOG_HOME&quot; value=&quot;logs&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--控制台--&gt;</span><br><span class="line">    &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger输出日志的</span><br><span class="line">            logger名 %msg：日志消息，%n是换行符 --&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n&lt;/pattern&gt;</span><br><span class="line">            &lt;!--解决乱码问题--&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--滚动文件--&gt;</span><br><span class="line">    &lt;appender name=&quot;infoFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!-- ThresholdFilter:临界值过滤器，过滤掉 TRACE 和 DEBUG 级别的日志 --&gt;</span><br><span class="line">        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;INFO&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;30&lt;/maxHistory&gt;&lt;!--保存最近30天的日志--&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--滚动文件--&gt;</span><br><span class="line">    &lt;appender name=&quot;errorFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">             &lt;!-- ThresholdFilter:临界值过滤器，过滤掉 TRACE 和 DEBUG 级别的日志 --&gt;</span><br><span class="line">        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;error&lt;/level&gt;</span><br><span class="line">        &lt;/filter&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;30&lt;/maxHistory&gt;&lt;!--保存最近30天的日志--&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--将日志输出到logstack--&gt;</span><br><span class="line">    &lt;!--&lt;appender name=&quot;logstash&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span><br><span class="line">        &lt;destination&gt;xx.xx.xx.xx:7002&lt;/destination&gt;</span><br><span class="line">        &lt;encoder class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;keepAliveDuration&gt;5 minutes&lt;/keepAliveDuration&gt;</span><br><span class="line">    &lt;/appender&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--这里如果是info，spring、mybatis等框架则不会输出：TRACE &lt; DEBUG &lt; INFO &lt;  WARN &lt; ERROR--&gt;</span><br><span class="line">    &lt;!--root是所有logger的祖先，均继承root，如果某一个自定义的logger没有指定level，就会寻找</span><br><span class="line">    父logger看有没有指定级别，直到找到root。--&gt;</span><br><span class="line">    &lt;root level=&quot;debug&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;stdout&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;infoFile&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;errorFile&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;logstash&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--为某个包单独配置logger</span><br><span class="line"></span><br><span class="line">    比如定时任务，写代码的包名为：com.seentao.task</span><br><span class="line">    步骤如下：</span><br><span class="line">    1、定义一个appender，取名为task（随意，只要下面logger引用就行了）</span><br><span class="line">    appender的配置按照需要即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    2、定义一个logger:</span><br><span class="line">    &lt;logger name=&quot;com.seentao.task&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">      &lt;appender-ref ref=&quot;task&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    注意：additivity必须设置为false，这样只会交给task这个appender，否则其他appender也会打印com.seentao.task</span><br><span class="line">    里的log信息。</span><br><span class="line"></span><br><span class="line">    3、这样，在com.seentao.task的logger就会是上面定义的logger了。</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(Class1.class);</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>java中使用<br>同slf4j</li></ol><h2 id="mybatis-mapper-xml"><a href="#mybatis-mapper-xml" class="headerlink" title="mybatis mapper.xml"></a>mybatis mapper.xml</h2><ol><li><p>select查询</p><ol><li>mapper.xml与mapper接口配合使用时，mapper.xml中的namespace必须为相应接口的全限定名，mybatis<br>通过这个关系才能找到对应mapper的实现xml(也正因为这样mapper接口才不需要实现类)</li><li>另外之前在mybatis-config.xml中是用<code>&lt;mapper resource=XXX&gt;</code>标签指定了具体的mapper.xml位置来实现映射，使用接口后可以使用<code>&lt;package name=XXX&gt;</code>来指定接口类所在的包。</li><li>mapper.xml中的id与mapper接口方法名也要一一对应。</li><li><p>mapper.xml中resultMap标签中的id和result标签中有javaType和jdbcType2个容易混淆的属性：</p><blockquote><p>javaType: 如果resultMap映射到的是一个javabean,id和result所指字段的java类型不用指明，<br>如果resultMap映射的是一个hashmap,需要用javaType来指明键的java类型。<br>jdbcType: 指定列对应的数据库类型，是JDBC的需要，仅对insert,update,delete可能为空的列<br>进行处理。<br>以上2个属性的区别还有待以后实战补充整理。</p></blockquote></li><li><p>查询结果可以用resultMap和resultType这两种方式来映射返回结果，其中resultType需要在<br>sql中指定别名实现与java属性的映射关系，可以设置mybatis属性mapUnderscoreToCamelCase=<br>true来统一实现下划线转驼峰命名，设置好以后就不需要给sql字段添加别名了。不过这样需要<br>字段命名都很规范才可以。</p></li><li><p>使用sqlsession.selectList来测试时mapper.xml所在包的位置也需要和mapper接口<br>所在包的路径一致，这是因为在mybatis-config中配置的是mapper接口的包路径，<br>mybatis按路径如com.mapper.UserMapper转化为com/mapper/UserMapper.xml，<br>mybatis找到该路径即进行解析该xml。<br>在其他项目中使用得到mapper.xml的包路径和mapper包路径不同，namespace相同项目也能跑<br>起来，具体原因后面看了原理再来探究。</p></li><li><p>mysql的BLOB类型java类中为byte[],需要在resultMap的result标签中指定jdbcType=BLOB,<br>java.util.Date类型可以指定jdbcType=TIMESTAMP或其他org.apache.ibatis.type.DATE,TIME.</p></li><li><p>可以用sqlSession.getMapper(UserMapper.class)来获取得到mapper接口进行测试。</p></li></ol></li><li><p>##<br><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190307_1.jpg" class="full-image"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mybatis note, Log4J, Log4J2, SLF4J,&lt;br&gt;
    
    </summary>
    
      <category term="Mybatis" scheme="http://www.taoblog.cn/categories/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="http://www.taoblog.cn/tags/Mybatis/"/>
    
      <category term="Log4J" scheme="http://www.taoblog.cn/tags/Log4J/"/>
    
      <category term="Log4J2" scheme="http://www.taoblog.cn/tags/Log4J2/"/>
    
      <category term="SLF4J" scheme="http://www.taoblog.cn/tags/SLF4J/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计学习笔记</title>
    <link href="http://www.taoblog.cn/post/262e0be1/"/>
    <id>http://www.taoblog.cn/post/262e0be1/</id>
    <published>2019-03-04T13:19:30.000Z</published>
    <updated>2019-03-06T15:11:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Database Design, Mysql<br><a id="more"></a></p><h2 id="数据库设计作用"><a href="#数据库设计作用" class="headerlink" title="数据库设计作用"></a>数据库设计作用</h2><ol><li>有效存储</li><li>高效查询</li></ol><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>   存储哪些数据，数据的时效性(是否需要分库分表或采取定时清理或迁移操作)<br>   实体之间的关系，实体属性和主键</p><h3 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h3><p>   将需求分析转化为ER图<br>   <strong>数据库设计范式</strong><br>   数据库设计标准，符合高标准范式的必定符合低标准的范式。<br>   有1NF, 2NF, 3NF, BCNF, 4NF, 5NF,一般符合BCNF就可以。</p><h4 id="操作异常和数据冗余"><a href="#操作异常和数据冗余" class="headerlink" title="操作异常和数据冗余"></a>操作异常和数据冗余</h4><p>   插入异常： 一个实体随另一个实体存在，无法单独插入数据为插入异常。<br>   更新异常：修改某个实体实例属性时需要更新多行数据为修改异常。<br>   删除异常: 删除某条数据时导致另一条数据信息丢失为删除异常。<br>   数据冗余: 相同数据在多个地方存在或表中某列可以由其他列计算得到。 </p><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>   数据库中的所有字段都是单一属性，不可再分的，即它是由基本数据类型构成的。<br>   即数据库中的表都是二维表，没有一个字段是复合对象，可以再拆分成多个字段来表示含义的。</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>   是否存在非主属性对于码的部分函数依赖。<br>   (所有单关键字段的表都符合2NF)</p><pre><code>1. K为属性或属性组，如果其他属性完全依赖于K,则K为码，可以有多个码。2. 任何一个码中的元素为主属性。3. 这里部分依赖即指非主属性可由码的部分属性确定下来。</code></pre><table><thead><tr><th>学号</th><th>姓名</th><th>系名</th><th>系主任</th><th>课名</th><th>分数</th></tr></thead><tbody><tr><td>001</td><td>吴涛涛</td><td>自动化</td><td>孙主任</td><td>高数</td><td>89</td></tr><tr><td>001</td><td>吴涛涛</td><td>自动化</td><td>孙主任</td><td>英语</td><td>99</td></tr><tr><td>002</td><td>王二</td><td>计算机</td><td>张主任</td><td>英语</td><td>79</td></tr></tbody></table><pre><code>1. 如果新建了一个系，还没有招收学生，就无法插入到这张表中，所以为插入异常。2. 如果我转到了计算机系，需要修改我所有的分数数据记录，为更新异常。3. 如果删除了一个系的所有学生分数记录，该系的信息无法查询到了，为删除异常。4. 学生的姓名，系名和系主任多次重复，数据冗余。</code></pre><p>   以上面例子为例, 一个学生只有一个学号,一个姓名，一个系名,一个系主任，Ta可以有多门课，<br>   一门课只有一个分数，所以可以看出其复合主键为学号加课名。</p><p>   学号决定了姓名，写成学号-&gt;姓名 </p><p>   学号和课名决定了分数，而集学号或课名都无法单独决定分数，所以学号+课名是对分数<br>   的<strong>完全依赖</strong>(x-&gt;y,如果任意一个x的真子集z，z不能决定y,则y完全依赖于x)。<br>   (学号，课名)F -&gt; 分数</p><p>   x p-&gt; y, y依赖于x,但不完全依赖于x,即部分依赖<br>   (学号，课名)P -&gt; 姓名</p><p>   找码过程：先看单个元素是否能确定其他字段，再两两组合看是否确定，三三组合直到所有字段为<br>   一个码,其中如果A是码，根据码的完全依赖标准，所有包含A的属性组都不是码了。<br>   通过分析可以得知，码只有一个(学号，课名)<br>   而部分依赖有</p><blockquote><p>(学号，课名) p-&gt; 姓名<br>(学号，课名) p-&gt; 系名<br>(学号，课名) p-&gt; 系主任</p></blockquote><p>   这里只有分数是完全依赖于这个码的。3个部分依赖中都是依赖于学号，所以可以把学号和其他依赖<br>   于它的字段一起拆出去作为一张表。<br>   可以分为</p><blockquote><p>选课表 学号 课名 分数<br>学生表 学号 姓名 系名 系主任</p></blockquote><p>   这样满足了NF2, 但是插入一个无学生的新系或删除某个系里所有学生信息后，都无法获取该系信息的<br>   问题。问题在于学号-&gt;系名，而系名-&gt;系主任，存在传递依赖，不符合NF3.</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>  3NF在2NF的基础上，消除了非主属性对于码的传递函数依赖。</p><p>  上个例子可以改进为</p><blockquote><p>选课表 学号 课名 分数<br>学生表 学号 姓名 系名<br>系表   系名 系主任</p></blockquote><p>   这样插入一个无学生的新系或删除某个系里所有学生信息就都不会丢失系信息了。</p><h4 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h4><p>   数据库中不存在主属性对于码的传递函数依赖部分函数依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. 某公司有若干个仓库；</span><br><span class="line">2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；</span><br><span class="line">3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。</span><br><span class="line">每种物品在每个仓库中都有对应的数量。</span><br><span class="line"></span><br><span class="line">已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量</span><br><span class="line">码：（管理员，物品名），（仓库名，物品名）</span><br><span class="line">主属性：仓库名、管理员、物品名</span><br><span class="line">非主属性：数量</span><br><span class="line">∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。</span><br><span class="line">∴ 此关系模式属于3NF。</span><br><span class="line"></span><br><span class="line">1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？</span><br><span class="line">——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。</span><br><span class="line">2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？</span><br><span class="line">——仓库本身与管理员的信息也被随之删除了。</span><br><span class="line">3. 如果某仓库更换了管理员，会带来什么问题？</span><br><span class="line">——这个仓库有几条物品存放记录，就要修改多少次管理员信息。</span><br><span class="line"></span><br><span class="line">从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，</span><br><span class="line">修改异常与删除异常的问题，仍然不是 ”好“ 的设计。</span><br><span class="line"></span><br><span class="line">造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。</span><br><span class="line">（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。</span><br><span class="line"></span><br><span class="line">解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</span><br><span class="line">&gt; 仓库（仓库名，管理员）</span><br><span class="line">&gt; 库存（仓库名，物品名，数量）</span><br><span class="line"></span><br><span class="line">这样，之前的插入异常，修改异常与删除异常的问题就被解决了。</span><br></pre></td></tr></table></figure><p>又在网上看到另一个类似的例子，但它说明了满足BCNF规范会产生的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">有这样一个配件管理表WPE(WNO,PNO,ENO,QNT),其中WNO表示仓库号，</span><br><span class="line">PNO表示配件号，ENO表示职工号，QNT表示数量。</span><br><span class="line"></span><br><span class="line">有以下约束要求：</span><br><span class="line"></span><br><span class="line">（1）       一个仓库有多名职工；</span><br><span class="line"></span><br><span class="line">（2）       一个职工仅在一个仓库工作；</span><br><span class="line"></span><br><span class="line">（3）       每个仓库里一种型号的配件由专人负责，但一个人可以管理几种配件；</span><br><span class="line"></span><br><span class="line">（4）       同一种型号的配件可以分放在几个仓库中。</span><br><span class="line"></span><br><span class="line">分析表中的函数依赖关系，可以得到：</span><br><span class="line"></span><br><span class="line">（1）       ENO-&gt;WNO;</span><br><span class="line"></span><br><span class="line">（2）       （WNO，PNO）-&gt;QNT</span><br><span class="line"></span><br><span class="line">（3）       （WNO，PNO）-&gt;ENO</span><br><span class="line"></span><br><span class="line">（4）       （ENO，PNO）-&gt;QNT</span><br><span class="line"></span><br><span class="line">可以看到，候选键有：（ENO,PNO）;(WNO,PNO)。所以，ENO,PNO,WNO均为主属性，QNT为非主属性。显然，非主属性是直接依赖于候选键的。所以此表满足第三范式。</span><br><span class="line"></span><br><span class="line">而我们观察一下主属性：（WNO,PNO）-&gt;ENO;ENO-&gt;WNO。显然WNO对于候选键（WNO,PNO）存在传递依赖，</span><br><span class="line">所以不符合BCNF.</span><br><span class="line"></span><br><span class="line">解决这个问题的办法是分拆为两个表：</span><br><span class="line"></span><br><span class="line">管理表EP（ENO，PNO，QNT）；</span><br><span class="line">工作表EW（ENO，WNO）。</span><br><span class="line"></span><br><span class="line">但这样做会导致函数依赖（WNO,PNO）-&gt;ENO丢失。</span><br><span class="line"></span><br><span class="line">4． 应用</span><br><span class="line"></span><br><span class="line">虽然，不满足BCNF，也会导致一些冗余和一致性的问题。</span><br><span class="line">但是，将表分解成满足BCNF的表又可能丢失一些函数依赖。</span><br><span class="line">所以，一般情况下不会强制要求关系表要满足BCNF。</span><br></pre></td></tr></table></figure></p><h4 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h4><p>指在满足3NF的情况下，表中不能包含一个实体的2个或多个互相独立的多值因子。</p><p>如有一个telephone表(用户号customerId, 固定电话号phone,移动电话号cell),phone和cell相互独立，<br>主键是用户号，没有非主属性的传递依赖,符合3NF,也没有部分依赖，符合2NF。</p><p>如果一个用户有多个固定电话和移动电话，它就违反了4NF,因为如果用户取消了第一个固定电话和<br>第2个移动电话，怎么维护数据，这2行是否要合并等等。</p><p>可以设计一个新表newTelephone(customerId, number, phoneType)。</p><h4 id="5NF"><a href="#5NF" class="headerlink" title="5NF"></a>5NF</h4><p>4NF处理相互独立的多值情况，5NF处理相互依赖的多值情况。</p><p>如销售信息表Sales(salesperson, vendor, product)在某些情况下有冗余，可以分解为</p><blockquote><p>person_vendor表(salesperson, vendor)<br>person_product表(salesperson, product)<br>vendor_product表(vendor, product)</p></blockquote><h4 id="范式总结"><a href="#范式总结" class="headerlink" title="范式总结"></a>范式总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line"></span><br><span class="line">   总之，规范化的过程就是在数据库表设计时移除数据冗余的过程。</span><br><span class="line">   随着规范化的进行，数据冗余越来越少，但数据库的效率也越来越低。</span><br><span class="line">   这就要求你在数据库设计中，能结合实际应用的性能要求，规范到合适的范式。</span><br><span class="line">   一般情况下，如何性能允许的话，都要求规范到第三范式的。</span><br></pre></td></tr></table></figure><h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><ol><li>选择数据库管理系统。</li><li>数据库，表及字段的命名规范。</li><li>根据DBMS系统选择合适的字段类型。 </li><li>反范式化设计(如为了效率的提升，进行一些数据冗余处理)</li></ol><h4 id="mysql存储引擎"><a href="#mysql存储引擎" class="headerlink" title="mysql存储引擎"></a>mysql存储引擎</h4><table><thead><tr><th>存储引擎</th><th>事物</th><th>锁粒度</th><th>应用</th><th>忌用</th></tr></thead><tbody><tr><td>MylSAM</td><td>不支持</td><td>并发插入表级锁</td><td>select,Insert</td><td>频繁读写</td></tr><tr><td>MRG_MYISAM</td><td>不支持</td><td>并发插入表级锁</td><td>分段归档，数据仓库</td><td>全局查找过多</td></tr><tr><td>Innodb(5.5后)</td><td>支持</td><td>行级锁</td><td>事务处理</td><td>无</td></tr><tr><td>Archive</td><td>不支持</td><td>行级锁</td><td>日志记录，只支持insert,select</td><td>需要更新，删除,随机读取</td></tr><tr><td>Ndb cluster</td><td>支持</td><td>行级锁</td><td>高可用性</td><td>大部分应用</td></tr></tbody></table><h4 id="表及字段命名规范"><a href="#表及字段命名规范" class="headerlink" title="表及字段命名规范"></a>表及字段命名规范</h4><ol><li>可读性原则(有些DBMS大小写敏感)</li><li>表意性原则</li><li>长名原则</li></ol><h4 id="字段类型的选择原则"><a href="#字段类型的选择原则" class="headerlink" title="字段类型的选择原则"></a>字段类型的选择原则</h4><p><strong>优先数字类型，其次日期类型，最后同类型下，选择存储空间小的类型。</strong></p><p>原因:</p><ol><li>数据进行比较时(查询，join及排序),字符比数字慢。</li><li>数据库是按页处理的，列的长度越小，页数越少，IO开销越小，从而性能越高。</li></ol><h4 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h4><ol><li>如果数据长度基本一致，可以选择char.</li><li>如果列最大数据长度小于50byte,可以考虑char.(如果很少用，为减少空间也可以用varchar)</li><li>大于50byte的数据一般为varchar。<h4 id="decimal和float"><a href="#decimal和float" class="headerlink" title="decimal和float"></a>decimal和float</h4></li><li>decimal用于存储精确数据，float用于存储非精确数据。</li><li>float存储空间开销小，非精确数据优先float.<h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4></li><li>int存储时间<br>存储消耗比datetime小，但使用时需要转换，而且因为有2^32的最大值限制，只能存到2038.1.19</li><li>时间粒度 y,m,d 当不需要那么精确时可以选择年月日字段类型。<h4 id="选择主键"><a href="#选择主键" class="headerlink" title="选择主键"></a>选择主键</h4></li><li>区分业务主键和数据库主键(如果没有主键，innodb会生成6个字节的隐含主键)</li><li>主键是否要顺序增长，</li><li>主键字段类型占有空间少<h4 id="避免使用外键"><a href="#避免使用外键" class="headerlink" title="避免使用外键"></a>避免使用外键</h4></li><li>降低数据导入效率（导入时会检查是否满足外键约束）</li><li>增加维护成本</li><li>关联列上可以增加索引<h4 id="避免使用触发器"><a href="#避免使用触发器" class="headerlink" title="避免使用触发器"></a>避免使用触发器</h4></li><li>降低数据导入效率</li><li>可能会出现数据异常</li><li>业务逻辑变的复杂<h4 id="不预留字段"><a href="#不预留字段" class="headerlink" title="不预留字段"></a>不预留字段</h4></li><li>无法知道预留字段类型</li><li>无法知道存储内容</li><li>维护成本和新建字段成本相同</li><li>严禁使用预留字段<h4 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h4>用空间换时间</li><li>减少表的关联个数</li><li>增加读取效率</li><li>反范式化需要适度</li></ol><h3 id="维护和优化"><a href="#维护和优化" class="headerlink" title="维护和优化"></a>维护和优化</h3><ol><li><p>维护数据字典</p><ol><li>用第三方工具来维护</li><li>本身的备注字段来维护(comment)</li><li>mysql可以从information_schemas.TABLES和information_schemas.COLUMNS来联合查询出表和<br>列的备注信息</li></ol></li><li><p>维护索引<br>选择合适列建立索引</p><ol><li>where, group by, order by中出现的列</li><li>可选择性高的列放到索引前面</li><li>索引中不要包括太长的数据类型</li><li>索引不是越多越好</li><li>定期维护索引碎片</li><li>sql中不要使用强制索引关键字</li></ol></li><li><p>维护表结构</p><ol><li><p>使用在线表结构变更工具<br>mysql 5.5前使用工具pt-online-schema-change,它通过生成临时表来进行变更，如果原表存在触发<br>器，该工具无法生成新的触发器从而无法使用。<br>mysql 5.6后本身支持在线表结构变更。</p></li><li><p>同时维护数据字典</p></li><li><p>控制表的宽度和大小</p></li><li><p>数据库适合批量操作，逐条操作适合在程序中操作。</p></li><li><p>禁止使用select * 查询</p></li><li><p>控制用户使用自定义函数</p></li><li><p>不要使用数据库中的全文索引,可以使用第三方的搜索引擎。</p></li></ol></li><li><p>适当时候需要水平拆分或垂直拆分<br>水平拆分是数据的拆分，可以按主键取模的方式拆分，查询和插入时也进行取模后再操作，垂直拆分<br>为列的拆分。<br>垂直拆分:</p><ol><li>经常一起查询的列放到一起。</li><li>text,blob等大字段拆分出到附加表中。</li></ol></li></ol><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190304_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Database Design, Mysql&lt;br&gt;
    
    </summary>
    
      <category term="Database" scheme="http://www.taoblog.cn/categories/Database/"/>
    
    
      <category term="Mysql" scheme="http://www.taoblog.cn/tags/Mysql/"/>
    
      <category term="DataBase" scheme="http://www.taoblog.cn/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ Idea 简明笔记</title>
    <link href="http://www.taoblog.cn/post/481236cd/"/>
    <id>http://www.taoblog.cn/post/481236cd/</id>
    <published>2019-03-01T02:21:17.000Z</published>
    <updated>2020-11-18T09:40:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>IntelliJ Idea Note<br><a id="more"></a><br><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/" target="_blank" rel="noopener">Idea教程https://github.com/judasn/IntelliJ-IDEA-Tutorial/</a></p><p>操作系统: win7 64位<br>Idea版本: 2018.3.5 (2019.1在beta中)</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_2.jpg" alt="20190301_2"><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_3.jpg" alt="20190301_3"><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_4.jpg" alt="20190301_4"><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_5.jpg" alt="20190301_5"><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_6.jpg" alt="20190301_6"><br>注册激活码，如果失效去这个网站获取<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_7.jpg" alt="20190301_7"></p><h2 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h2><ol><li>新建一个文件夹，可以命名为ideaWorkspace(已经有父子模块项目关系的可以直接open即可)</li><li>将需要导入的项目文件夹拷贝到里面</li><li>open该工作空间文件夹</li><li>设置成maven项目<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_9.jpg" alt="20190301_9"><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_10.jpg" alt="20190301_10"><br>到此项目就算导入完成了。</li></ol><p>Idea中没有workspace的概念，它顶级目录叫Project,次级目录是Module,每个project都有自己的<br>.idea文件夹。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><ol><li><p>设置jdk<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_11.jpg" alt="20190301_11"><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_12.jpg" alt="20190301_12"><br>到这里就可以直接运行项目了。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_13.jpg" alt="20190301_13"></p></li><li><p>修改字体大小<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_14.jpg" alt="20190301_14"></p></li><li><p>修改文件编码<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_15.jpg" alt="20190301_15"><br>注：如果Tomcat 控制台输出乱码，并且控制台字体设置的字体包含中文，可以在 Tomcat 的 VM<br>参数上加上：-Dfile.encoding=UTF-8<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_16.jpg" alt="20190301_16"></p></li><li><p>清楚缓存和索引<br>Idea利用缓存和索引来加快搜索查询的速度，但有时也会出现问题，这时可以清除缓存来解决问题：<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_17.jpg" alt="20190301_17"><br>一般选择第一个就可以，清除并重启，这里实际上就是删除了system文件夹，可以手动删除，重启<br>Idea它会自动创建新的system文件夹，system路径位于自己的用户目录下：</p><blockquote><p>/c/Users/LYPC/.IntelliJIdea2018.3/system</p></blockquote></li><li><p>自动编译<br>因为自动编译比较耗费资源，所以idea默认没有开启自动编译，可以手动设置：<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_18.jpg" alt="20190301_18"><br>注意：这里的自动编译不是保存后自动编译，而是在编辑器里输入代码的时候自动编译，<br>所以比较耗费资源，可以用快捷键<code>ctrl + F9</code>来进行项目编译。</p></li></ol><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>idea默认快捷键查看及修改地址：<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_8.jpg" alt="20190301_8"><br>在设置前，应注意快捷键冲突，关掉搜狗输入法等的快捷键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">windows版：</span><br><span class="line"></span><br><span class="line">搜索：</span><br><span class="line">ctrl + shift + n   查找文件Files  相当于eclipse ctrl + shift + r 可改为ctrl+shift+o</span><br><span class="line">ctrl + shift + f   查找整个项目或指定目录内文件,相当于eclipse ctrl + h</span><br><span class="line">ctrl + e  最近打开的文件列表-&gt;列表大小可调-&gt;在settings-&gt;editor-&gt;general-&gt;limits-&gt;recent files limit</span><br><span class="line">ctrl + shift + e   最近修改文件列表</span><br><span class="line">ctrl + shift + v   拷贝历史记录板</span><br><span class="line">ctrl + F12   显示文件结构，相当于eclipse ctrl + o</span><br><span class="line">ctrl + f  当前文件搜索</span><br><span class="line"></span><br><span class="line">窗口处理：</span><br><span class="line">ctrl + alt + s     打开idea setting 设置</span><br><span class="line">alt + 1            显示project视图</span><br><span class="line">alt + 2      # 收藏夹</span><br><span class="line">ctrl + F4          关闭当前编辑文件 </span><br><span class="line">ctrl + shift + F12 最大化编辑器</span><br><span class="line"></span><br><span class="line">tab可以多行显示或只显示一个tab,在settings-&gt;editor-&gt;General-&gt;Editor tabs-&gt;placement</span><br><span class="line"></span><br><span class="line">光标选择：</span><br><span class="line">ctrl + w  智能选择代码块</span><br><span class="line">ctrl + shift + w   与ctrl+w配合使用，是递进取消选择单词</span><br><span class="line">ctrl + alt + 左   退回上一个操作地方  可以改成alt + [</span><br><span class="line">ctrl + alt + 右   前进到上一个操作地方  可以改成alt + ]</span><br><span class="line">ctrl + shift + backspace   退回上次修改的地方</span><br><span class="line">F2  跳转到下一个错误或警告位置</span><br><span class="line">shift + F2   上一个错误</span><br><span class="line">ctrl + b   navigate-declaration  类的定义或变量的使用处显示</span><br><span class="line">ctrl + alt + b   navigate-implementations 接口或抽象方法实现</span><br><span class="line">ctrl + u    super method  父类方法</span><br><span class="line"></span><br><span class="line">编辑：</span><br><span class="line">ctrl + z,c,x,/  功能不变: 搜索，撤销，复制，剪切,粘贴, 注释</span><br><span class="line">ctrl + shift + z  恢复撤销，相当于前进</span><br><span class="line">ctrl + r  替换</span><br><span class="line">ctrl + y  删除光标所在行 或 选中的行</span><br><span class="line">ctrl + d  复制当前行并粘贴到下一行 或 复制选中内容并粘贴到光标后,可以改成粘贴到下一行而不是</span><br><span class="line">            光标后，修改为duplicate entire lines</span><br><span class="line">ctrl + alt + l  格式化代码，可以对当前文件或整个包目录使用</span><br><span class="line">ctrl + alt + t  对选中代码弹出环绕层，有if/else, try/catch等</span><br><span class="line">ctrl + shift + /   代码块注释</span><br><span class="line">ctrl + alt + o  优化import的包</span><br><span class="line">alt + shift + 上   当前行向上移动一行</span><br><span class="line">alt + shift + 下   当前行向下移动一行</span><br><span class="line"></span><br><span class="line">代码提示：</span><br><span class="line">ctrl + space  这个windows系统上时切换输入法，可修改为ctrl + ; 表示基本代码补全</span><br><span class="line">ctrl + shift + space   智能代码补全 可改为ctrl + shift + ;</span><br><span class="line">ctrl + shift + enter   代码自动收尾，可生成if语句等</span><br><span class="line">alt + enter   智能辅助，跟据位置不同提示结果不同，可用于生成get/set方法，生成接口或实现类，</span><br><span class="line">              还可以进行重构</span><br><span class="line">alt + insert  同eclipse,生成set/get,constructor,toString()等</span><br><span class="line"></span><br><span class="line">postfix code completion:  for,nn,null,var #settings-&gt;editor-&gt;general-&gt;postfix completion</span><br><span class="line"></span><br><span class="line">重构：</span><br><span class="line">shift + F6       重构: 重新命名</span><br><span class="line">ctrl + shift + r   替换内容 整个项目或指定目录</span><br><span class="line">ctrl + alt + m   重构: 提取方法</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">ctrl + F9       make project编译项目</span><br><span class="line">ctrl + shift + F9  重新编译 </span><br><span class="line">alt + shift + f    加入到收藏夹中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mac 版：</span><br><span class="line">option-&gt;alt</span><br><span class="line"></span><br><span class="line">搜索：</span><br><span class="line">command + shift + o  #  navigate File... </span><br><span class="line">command + shift + f   # find in path    </span><br><span class="line">command + e          #   recent files   </span><br><span class="line">command + shift + e   # recently changed files </span><br><span class="line">command + shift + v   # paste from history </span><br><span class="line">command + F12        #   file structure   </span><br><span class="line">command + f          #   edit: Find find </span><br><span class="line"></span><br><span class="line">窗口处理：</span><br><span class="line">command + ,      # file setting      $$ ctrl-alt-s</span><br><span class="line">command + 1      # tool windows Project  $$ alt-1</span><br><span class="line">command + 2      # favourite window   $$ alt-2</span><br><span class="line">command + w      # editor tabs close  $$ ctrl-F4 window-w</span><br><span class="line">command + shift + F12 # hide all tool windows</span><br><span class="line"></span><br><span class="line">光标选择：</span><br><span class="line">alt + up          #   extend selection  $$ ctrl-w</span><br><span class="line">alt + down   # shrink selection        $$ ctrl-shift-w</span><br><span class="line">command + [     # navigation back      $$ alt-[</span><br><span class="line">command + ]     # navigation forward   $$ alt-]</span><br><span class="line">command + shift + backspace # last edit location</span><br><span class="line">F2  # next highlighted error</span><br><span class="line"></span><br><span class="line">编辑：</span><br><span class="line">command + z,c,x,/    #   find,undo,copy,cut,comment</span><br><span class="line">command + shift + z  #   redo</span><br><span class="line">command + r          #   replace</span><br><span class="line">command + backspace  #   delete line  $$ ctrl-y</span><br><span class="line">command + d          #   duplicate lines</span><br><span class="line">command + alt + l  # reformat code</span><br><span class="line">command + alt + t  # code surround with</span><br><span class="line">ctrl + shift + /     # comment with block comment %同windows command+shift+/有help同时出现</span><br><span class="line">ctrl + alt + o     # optimize imports             %同windows</span><br><span class="line">alt + shift + up  # code move line up             %同windows</span><br><span class="line">alt + shift + down  # code move line down         %同windows</span><br><span class="line"></span><br><span class="line">代码提示：</span><br><span class="line">ctrl + ;     # basic code complete           %同windows</span><br><span class="line">ctrl + shift + ;  # smart code complete      %同windows</span><br><span class="line">command + shift + enter  # complete current statement</span><br><span class="line">alt + enter     # show intention actions      %同windows</span><br><span class="line">ctrl + enter     # code generate             $$ alt-insert</span><br><span class="line"></span><br><span class="line">重构：</span><br><span class="line">shift + F6           # refactor rename    %同windows</span><br><span class="line">command + shift + r   # replace in path</span><br><span class="line">command + alt + m  # refactor extract method</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">command + F9         #   build project</span><br><span class="line">command + shift + F9  # rebuild </span><br><span class="line">alt + shift + f    # other add to favourites   %同windows</span><br></pre></td></tr></table></figure></p><p>注：如习惯vim操作，可以下载插件IdeaVim<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_19.jpg" alt="20190301_19"><br>安装后重启，设置开关vim模式快捷键,默认ctrl+alt+v,改成F1,同时把context help的remove掉。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_20.jpg" alt="20190301_20"><br>vim默认寄存器和系统剪贴板共享:<br>在c:\Users\用户名\下新建文件_ideavimrc文件(mac是~目录.ideavimrc):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">set clipboard+=unnamed</span><br><span class="line">let mapleader = &quot;,&quot;</span><br><span class="line">set backspace=eol,start,indent</span><br><span class="line">set whichwrap+=&lt;,&gt;,h,l</span><br><span class="line">set ignorecase</span><br><span class="line">set smartcase</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch </span><br><span class="line">set showmatch </span><br><span class="line">set background=dark</span><br><span class="line">set encoding=utf8</span><br><span class="line">set nobackup</span><br><span class="line">set nowb</span><br><span class="line">set noswapfile</span><br><span class="line">set smarttab</span><br><span class="line">map &lt;C-j&gt; &lt;C-W&gt;j</span><br><span class="line">map &lt;C-k&gt; &lt;C-W&gt;k</span><br><span class="line">map &lt;C-h&gt; &lt;C-W&gt;h</span><br><span class="line">map &lt;C-l&gt; &lt;C-W&gt;l</span><br><span class="line">noremap &lt;leader&gt;v &quot;0p</span><br><span class="line">noremap &lt;leader&gt;V &quot;0P</span><br><span class="line">noremap &lt;leader&gt;ay &quot;ay</span><br><span class="line">noremap &lt;leader&gt;ap &quot;ap</span><br><span class="line">noremap &lt;leader&gt;by &quot;by</span><br><span class="line">noremap &lt;leader&gt;bp &quot;bp</span><br><span class="line">noremap &lt;leader&gt;cy &quot;cy</span><br><span class="line">noremap &lt;leader&gt;cp &quot;cp</span><br><span class="line">inoremap ( ()&lt;Esc&gt;i</span><br><span class="line">inoremap [ []&lt;Esc&gt;i</span><br><span class="line">inoremap &#123; &#123;&#125;&lt;Esc&gt;i</span><br><span class="line">inoremap &quot; &quot;&quot;&lt;Esc&gt;i</span><br><span class="line">imap ,, &lt;Esc&gt;la</span><br><span class="line">noremap &lt;leader&gt;z G33o&lt;Esc&gt;H</span><br></pre></td></tr></table></figure></p><p>热部署插件JRebel<br>修改java文件后可以不用重启，重新编译后即可生效，xml等配置文件仍然需要重启项目。<br>注：将resources下文件纳入jrebel监管范围，从而避免重启项目，<br>生成的rebel.xml文件中可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;classpath&gt;&lt;dir name=&quot;xxx&quot;&gt;&lt;/dir&gt;&lt;/classpath&gt;</span><br><span class="line">改为</span><br><span class="line">&lt;classpath&gt;</span><br><span class="line">&lt;dirset dir=&quot;/path_to_project_root/&quot;&gt;</span><br><span class="line">   &lt;include name=&quot;**/target/classes&quot;/&gt;</span><br><span class="line">   &lt;include name=&quot;**/src/main/resources&quot;/&gt;</span><br><span class="line">&lt;/dirset&gt; </span><br><span class="line">&lt;/classpath&gt;</span><br></pre></td></tr></table></figure></p><p>编辑器可视区域快速跳转神器AceJump<br>该插件提供了按行和按单词跳转功能,但是没什么太大作用，<br>最主要的功能还是自身的active acejump mode功能，可设置快捷键为ctrl + j</p><p>转换大小写插件String manipulation 可设置快捷键为alt + s</p><p>console日志警告或错误信息高亮颜色显示插件grep console<br>设置warn和error的前景色和背景色即可。</p><p>git提交commit模板idea插件git commit template</p><p>代码区小地图插件CodeGlance</p><h2 id="小设置"><a href="#小设置" class="headerlink" title="小设置"></a>小设置</h2><p>scroll from source<br>设置自动导包: settings-&gt;editor-&gt;general-&gt;auto import-&gt;check 2<br>代码提示忽略大小写：settings-&gt;editor-&gt;general-&gt;code completion-&gt;match case uncheck<br>显示内存使用情况：settings-&gt;apperance-&gt;window options-&gt;show memory indication<br>inject language  json, xpath, regex</p><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p>新建项目没有new java class选项？</p><blockquote><p>idea不同目录右键下有一个<code>mark directory as</code> 的功能，对应了maven通常项目结构,<br>有sources,tests,resources,test resources,excluded等不同的项目，将需要的包进行设定<br>即可。</p></blockquote><p>光标处和相同变量颜色如何设置？</p><blockquote><p>settings -&gt; editor -&gt; color scheme -&gt; general中<br>code identifier under caret 相同变量名处<br>code identifier under caret(write) 光标所在处  # 可以设置成黄底黑字<br>editor caret -&gt; 光标颜色 # 红色<br>editor caret row -&gt; 光标所在行 # 5D5973 或其他较深的颜色,区别黑色就可<br>editor selection background -&gt; 选中的文本颜色 绿底<br>editor selection foreground -&gt; 选中的文本颜色 黑字</p></blockquote><p>自动生成的注释如何不在开头？</p><blockquote><p>settings -&gt; editor -&gt; code style -&gt; java -&gt; code generation -&gt; comment code uncheck 2</p></blockquote><p>每行最大字数的限制？</p><blockquote><p>settings -&gt; editor -&gt; code style首页 hard wrap, visual guides,建议100</p></blockquote><h2 id="External-Tools"><a href="#External-Tools" class="headerlink" title="External Tools"></a>External Tools</h2><p>因为ideaVim插件毕竟不是真正的vim，所以有些vim的功能支持不了，或者不全，<br>今天在网上发现了idea还支持将vim作为外部工具使用，即在vim中打开现在正在编辑的文件，<br>并将改动同步回idea中。<br>windows上使用gvim来实现，mac上可以使用iterm2(to be continued)</p><ol><li>下载gvim，直接官网上下载,版本为8.1</li><li>安装</li><li>打开发现菜单都是乱码，网上说修改配置文件<code>_vimrc</code>,但是修改后并没有用，于是用另外一种<br>方法：直接删除vim/vim81/lang包下所有文件，菜单按钮全部回复到默认英文。<br>(后来发现是安装包的问题….另外下的一个包是好的)</li><li><p>设置默认的配色和字体,见下面的完整配置</p></li><li><p>在idea中配置gvim<br>settings - external tool - + - 配置</p><blockquote><p>program: vim/vim81/gvim.exe<br>arguments: +$LineNumber$ $FilePath$<br>其他默认，去掉advanced options - open console</p></blockquote></li><li><p><code>_vimrc</code>完整配置如下，需要新建环境变量VIM为E:\Vim来安装Vundle,</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">let mapleader = &quot;,&quot;</span><br><span class="line"></span><br><span class="line">set encoding=utf-8</span><br><span class="line">set fileencodings=utf-8,chinese,latin-1</span><br><span class="line">if has(&quot;win32&quot;)</span><br><span class="line">set fileencoding=chinese</span><br><span class="line">else</span><br><span class="line">set fileencoding=utf-8</span><br><span class="line">endif</span><br><span class="line">&quot;解决菜单乱码</span><br><span class="line">source $VIMRUNTIME/delmenu.vim</span><br><span class="line">source $VIMRUNTIME/menu.vim</span><br><span class="line">&quot;解决consle输出乱码</span><br><span class="line">language messages zh_CN.utf-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source $VIMRUNTIME/vimrc_example.vim</span><br><span class="line"></span><br><span class="line">set diffexpr=MyDiff()</span><br><span class="line">function MyDiff()</span><br><span class="line">  let opt = &apos;-a --binary &apos;</span><br><span class="line">  if &amp;diffopt =~ &apos;icase&apos; | let opt = opt . &apos;-i &apos; | endif</span><br><span class="line">  if &amp;diffopt =~ &apos;iwhite&apos; | let opt = opt . &apos;-b &apos; | endif</span><br><span class="line">  let arg1 = v:fname_in</span><br><span class="line">  if arg1 =~ &apos; &apos; | let arg1 = &apos;&quot;&apos; . arg1 . &apos;&quot;&apos; | endif</span><br><span class="line">  let arg1 = substitute(arg1, &apos;!&apos;, &apos;\!&apos;, &apos;g&apos;)</span><br><span class="line">  let arg2 = v:fname_new</span><br><span class="line">  if arg2 =~ &apos; &apos; | let arg2 = &apos;&quot;&apos; . arg2 . &apos;&quot;&apos; | endif</span><br><span class="line">  let arg2 = substitute(arg2, &apos;!&apos;, &apos;\!&apos;, &apos;g&apos;)</span><br><span class="line">  let arg3 = v:fname_out</span><br><span class="line">  if arg3 =~ &apos; &apos; | let arg3 = &apos;&quot;&apos; . arg3 . &apos;&quot;&apos; | endif</span><br><span class="line">  let arg3 = substitute(arg3, &apos;!&apos;, &apos;\!&apos;, &apos;g&apos;)</span><br><span class="line">  if $VIMRUNTIME =~ &apos; &apos;</span><br><span class="line">    if &amp;sh =~ &apos;\&lt;cmd&apos;</span><br><span class="line">      if empty(&amp;shellxquote)</span><br><span class="line">        let l:shxq_sav = &apos;&apos;</span><br><span class="line">        set shellxquote&amp;</span><br><span class="line">      endif</span><br><span class="line">      let cmd = &apos;&quot;&apos; . $VIMRUNTIME . &apos;\diff&quot;&apos;</span><br><span class="line">    else</span><br><span class="line">      let cmd = substitute($VIMRUNTIME, &apos; &apos;, &apos;&quot; &apos;, &apos;&apos;) . &apos;\diff&quot;&apos;</span><br><span class="line">    endif</span><br><span class="line">  else</span><br><span class="line">    let cmd = $VIMRUNTIME . &apos;\diff&apos;</span><br><span class="line">  endif</span><br><span class="line">  let cmd = substitute(cmd, &apos;!&apos;, &apos;\!&apos;, &apos;g&apos;)</span><br><span class="line">  silent execute &apos;!&apos; . cmd . &apos; &apos; . opt . arg1 . &apos; &apos; . arg2 . &apos; &gt; &apos; . arg3</span><br><span class="line">  if exists(&apos;l:shxq_sav&apos;)</span><br><span class="line">    let &amp;shellxquote=l:shxq_sav</span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">set nocompatible              &quot; be iMproved, required</span><br><span class="line">filetype off                  &quot; required</span><br><span class="line"></span><br><span class="line">&quot; set the runtime path to include Vundle and initialize</span><br><span class="line">&quot;set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">&quot;call vundle#begin()</span><br><span class="line">set rtp+=$VIM/vimfiles/bundle/Vundle.vim/</span><br><span class="line">call vundle#begin(&apos;$VIM/vimfiles/bundle/&apos;)</span><br><span class="line">&quot; alternatively, pass a path where Vundle should install plugins</span><br><span class="line">&quot;call vundle#begin(&apos;~/some/path/here&apos;)</span><br><span class="line"></span><br><span class="line">&quot; let Vundle manage Vundle, required</span><br><span class="line">Plugin &apos;VundleVim/Vundle.vim&apos;</span><br><span class="line"></span><br><span class="line">&quot; The following are examples of different formats supported.</span><br><span class="line">&quot; Keep Plugin commands between vundle#begin/end.</span><br><span class="line">&quot; plugin on GitHub repo</span><br><span class="line">&quot;Plugin &apos;tpope/vim-fugitive&apos;</span><br><span class="line">&quot; plugin from http://vim-scripts.org/vim/scripts.html</span><br><span class="line">&quot; Plugin &apos;L9&apos;</span><br><span class="line">&quot; Git plugin not hosted on GitHub</span><br><span class="line">&quot;&quot;Plugin &apos;git://git.wincent.com/command-t.git&apos;</span><br><span class="line">&quot; git repos on your local machine (i.e. when working on your own plugin)</span><br><span class="line">&quot;&quot;Plugin &apos;file:///home/gmarik/path/to/plugin&apos;</span><br><span class="line">&quot; The sparkup vim script is in a subdirectory of this repo called vim.</span><br><span class="line">&quot; Pass the path to set the runtimepath properly.</span><br><span class="line">&quot;&quot;Plugin &apos;rstacruz/sparkup&apos;, &#123;&apos;rtp&apos;: &apos;vim/&apos;&#125;</span><br><span class="line">&quot; Install L9 and avoid a Naming conflict if you&apos;ve already installed a</span><br><span class="line">&quot; different version somewhere else.</span><br><span class="line">&quot; Plugin &apos;ascenator/L9&apos;, &#123;&apos;name&apos;: &apos;newL9&apos;&#125;</span><br><span class="line">Plugin &apos;scrooloose/nerdtree&apos;</span><br><span class="line">Plugin &apos;terryma/vim-multiple-cursors&apos;</span><br><span class="line">Plugin &apos;kien/ctrlp.vim&apos;</span><br><span class="line">Plugin &apos;tpope/vim-surround&apos;</span><br><span class="line"></span><br><span class="line">&quot; All of your Plugins must be added before the following line</span><br><span class="line">call vundle#end()            &quot; required</span><br><span class="line">filetype plugin indent on    &quot; required</span><br><span class="line">&quot; To ignore plugin indent changes, instead use:</span><br><span class="line">&quot;filetype plugin on</span><br><span class="line">&quot;</span><br><span class="line">&quot; Brief help</span><br><span class="line">&quot; :PluginList       - lists configured plugins</span><br><span class="line">&quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span><br><span class="line">&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache</span><br><span class="line">&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span><br><span class="line">&quot;</span><br><span class="line">&quot; see :h vundle for more details or wiki for FAQ</span><br><span class="line">&quot; Put your non-Plugin stuff after this line</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; =&gt; CTRL-P</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">let g:ctrlp_working_path_mode = 0</span><br><span class="line"></span><br><span class="line">let g:ctrlp_map = &apos;&lt;c-f&gt;&apos;</span><br><span class="line">map &lt;leader&gt;p :CtrlP&lt;cr&gt;</span><br><span class="line">map &lt;c-b&gt; :CtrlPBuffer&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">let g:ctrlp_max_height = 20</span><br><span class="line">let g:ctrlp_custom_ignore = &apos;node_modules\|^\.DS_Store\|^\.git\|^\.coffee&apos;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; =&gt; Nerd Tree</span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">let g:NERDTreeWinPos = &quot;left&quot;</span><br><span class="line">let NERDTreeShowHidden=0</span><br><span class="line">let NERDTreeIgnore = [&apos;\.pyc$&apos;, &apos;__pycache__&apos;]</span><br><span class="line">let g:NERDTreeWinSize=35</span><br><span class="line">map &lt;leader&gt;nn :NERDTreeToggle&lt;cr&gt;</span><br><span class="line">map &lt;leader&gt;nb :NERDTreeFromBookmark&lt;Space&gt;</span><br><span class="line">map &lt;leader&gt;nf :NERDTreeFind&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; =&gt; vim-multiple-cursors</span><br><span class="line">&quot; </span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">let g:multi_cursor_next_key=&quot;\&lt;C-s&gt;&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">&quot; =&gt; surround.vim config</span><br><span class="line">&quot; Annotate strings with gettext </span><br><span class="line">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">vmap Si S(i_&lt;esc&gt;f)</span><br><span class="line">au FileType mako vmap Si S&quot;i$&#123; _(&lt;esc&gt;2f&quot;a) &#125;&lt;esc&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;设置gvim隐藏菜单栏，工具栏，滚动条</span><br><span class="line">set guifont=Source\ Code\ Pro\ for\ Powerline:h11</span><br><span class="line">colorscheme darkblue</span><br><span class="line">set guioptions-=m  &quot;remove menu bar</span><br><span class="line">set guioptions-=T  &quot;remove toolbar</span><br><span class="line">set guioptions-=r  &quot;remove right-hand scroll bar</span><br><span class="line">set guioptions-=L  &quot;remove left-hand scroll bar</span><br><span class="line"></span><br><span class="line">set clipboard+=unnamed</span><br><span class="line">set ignorecase</span><br><span class="line">set smartcase</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch </span><br><span class="line">set showmatch </span><br><span class="line">set nobackup</span><br><span class="line">set nowb</span><br><span class="line">set noswapfile</span><br><span class="line">set noundofile</span><br><span class="line">set smarttab</span><br><span class="line">map &lt;C-j&gt; &lt;C-W&gt;j</span><br><span class="line">map &lt;C-k&gt; &lt;C-W&gt;k</span><br><span class="line">map &lt;C-h&gt; &lt;C-W&gt;h</span><br><span class="line">map &lt;C-l&gt; &lt;C-W&gt;l</span><br><span class="line">noremap &lt;Leader&gt;v &quot;0p</span><br><span class="line">noremap &lt;Leader&gt;V &quot;0P</span><br><span class="line">noremap &lt;Leader&gt;ay &quot;ay</span><br><span class="line">noremap &lt;Leader&gt;ap &quot;ap</span><br><span class="line">noremap &lt;Leader&gt;by &quot;by</span><br><span class="line">noremap &lt;Leader&gt;bp &quot;bp</span><br><span class="line">noremap &lt;Leader&gt;cy &quot;cy</span><br><span class="line">noremap &lt;Leader&gt;cp &quot;cp</span><br><span class="line">inoremap ( ()&lt;Esc&gt;i</span><br><span class="line">inoremap [ []&lt;Esc&gt;i</span><br><span class="line">inoremap &#123; &#123;&#125;&lt;Esc&gt;i</span><br><span class="line">inoremap &quot; &quot;&quot;&lt;Esc&gt;i</span><br><span class="line">imap ,, &lt;Esc&gt;la</span><br></pre></td></tr></table></figure><p>注: 回到公司电脑上重新安装gvim8,装在E:\Vim下,修改_vimrc怎么都不生效，又搞了很久做了<br>以下两步终于生效了：</p><ol><li>添加用户变量VIM为E:\Vim,VIMRUNTIME为D:\Vim\vim81</li><li>将_vimrc放到用户目录下，我的为C:\Users\LYPC\下，生效了！！！<br>另：重新安装gvim8发现Vim包下没有了vimfiles文件夹，只好手动复制进去。</li></ol><p>再注：gvim可以正常使用了，但我真正想使用的是可以任意定位到一个项目下，方便的使用nerdtree来<br>查看项目代码。从这一点来看还是需要结合babun来实现快速打开项目,或者可以打开vim时自动打开<br>nerdTree,下面来讲这2种方法：</p><ol><li><p>用babun打开gvim,在网上找到大神写的一个gvim别名，对环境变量的控制做的很好，结合我自己<br>的$VIM变量配置，结果如下，可以正常使用插件nerdtree, ctrlp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gvim() &#123;</span><br><span class="line">   OLD_HOME=$HOME</span><br><span class="line">   OLD_VIMRUNTIME=$VIMRUNTIME</span><br><span class="line">   OLD_VIM=$VIM</span><br><span class="line">   export HOME=/cygdrive/c/Users/LYPC/</span><br><span class="line">   export VIMRUNTIME=&quot;E:\Vim\vim81&quot;</span><br><span class="line">   export VIM=&quot;E:\Vim&quot;</span><br><span class="line">   TARGET=$(cygpath -w $1)   </span><br><span class="line">   (/cygdrive/e/Vim/vim81/gvim.exe $TARGET &amp;)</span><br><span class="line">   export HOME=$OLD_HOME</span><br><span class="line">   export VIMRUNTIME=$OLD_VIMRUNTIME</span><br><span class="line">   export VIM=$OLD_VIM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动gvim时自动打开指定位置的nerdTree, 这里指我的项目集中地code<br>在<code>_vimrc</code>中添加配置:</p><blockquote><p>autocmd StdinReadPre <em> let s:std_in=1<br>autocmd VimEnter </em> if argc() == 0 &amp;&amp; !exists(“s:std_in”) | NERDTree | endif</p></blockquote></li></ol><p>这样在babun中用code定位到code目录，用命令<code>gvim</code>即可打开带有nerdTree的gvim窗口了</p><ol start="3"><li><p>像之前说的一样，babun里面包装了cygwin, 而vundle对cygwin里的安装现在官方不<br>给予支持，它只提供了windows里gvim的支持，所以我上面通过别名的方式来调用windows<br>里面的gvim.exe程序，这样通过gvim里的vundle来实现插件管理，这样曲线救国也能实现<br>目的，同时babun里自带的vim也能使用，这种方式对于有多个插件来说比较好，但目前我<br>需要的只是nerdTree一个插件，所以今天又发现可以手工把这个插件安装到vim里面:</p><ol><li>cd ~/.vim</li><li>mkdir bundle</li><li>cd bundle</li><li>git clone <a href="https://github.com/scrooloose/nerdtree.git" target="_blank" rel="noopener">https://github.com/scrooloose/nerdtree.git</a> nerdtree</li><li>在.vimrc中添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set runtimepath+=~/.vim/bundle/nerdtree</span><br><span class="line">let g:NERDTreeWinPos = &quot;left&quot;</span><br><span class="line">let NERDTreeShowHidden=0</span><br><span class="line">let NERDTreeIgnore = [&apos;\.pyc$&apos;, &apos;__pycache__&apos;]</span><br><span class="line">let g:NERDTreeWinSize=35</span><br><span class="line">map &lt;leader&gt;nn :NERDTreeToggle&lt;cr&gt;</span><br><span class="line">map &lt;leader&gt;nb :NERDTreeFromBookmark&lt;Space&gt;</span><br><span class="line">map &lt;leader&gt;nf :NERDTreeFind&lt;cr&gt;</span><br><span class="line">autocmd StdinReadPre * let s:std_in=1</span><br><span class="line">autocmd VimEnter * if argc() == 0 &amp;&amp; !exists(&quot;s:std_in&quot;) | NERDTree | endif</span><br></pre></td></tr></table></figure></li></ol><p>注：先命令行cd到相要的目录，直接vim打开，或者先打开，再,nf来打开nerdTree,<br>有<code>&lt;c-h&gt;,&lt;c-l&gt;</code>来快速切换nerdtree和编辑窗口.<br>退出时用:qa来一起关闭nerdtree和编辑器。<br>同理安装ctrlp插件后ctrlp插件报错，nerdtree正常使用，网上说是依赖问题，还是<br>需要插件管理软件，所以还是先用nerdtree吧，文件搜索可以放在命令行里find寻找。</p></li></ol><ol start="7"><li>目前暂时发现的ideaVim插件不能实现的功能有:<ol><li>visual block paste, idea中需要配合idea自带的列模式才能实现，没有原生的vim好用。</li><li>to be continued</li></ol></li></ol><h2 id="使用idea操作mysql数据库"><a href="#使用idea操作mysql数据库" class="headerlink" title="使用idea操作mysql数据库"></a>使用idea操作mysql数据库</h2><p>idea提供了console控制台进行sql语句的操作，相当于命令行一样，同样可以使用ideaVim插件和其他<br>快捷键来编写和执行命令，所以后来我基本放弃了navicat的使用，而且有次使用32位的navicat也出现<br>了问题，idea成功的进行了操作。<br>常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show grants;</span><br><span class="line">show processlist;</span><br><span class="line">select create table tablename;</span><br><span class="line">show full columns from tablename;</span><br><span class="line">delete t from tablename t where t.id = &apos;1&apos;;</span><br></pre></td></tr></table></figure></p><p>导入数据到表中：右键选择表，import data from files… 支持csv(comma-separated values)文件<br>tsv(tab-separated values)文件。</p><p>导出表结构：<br>用mysql自带的bin工具mysqldump.exe,有多个命令参数，<br>其中勾选第一个multiple rows insert后，只会生成一条insert语句，可以全部都不选。</p><p>只导出数据时，选择表右键有dump data to file选项。</p><h2 id="小问题-1"><a href="#小问题-1" class="headerlink" title="小问题"></a>小问题</h2><p>idea记住git密码,在项目目录下执行</p><blockquote><p>git config –global credential.helper store</p></blockquote><p>2019-08-27 10:08:32 添加:<br>编程时经常需要重命名变量名，idea下的快捷键是Shift + F6, 按下之后idea给出可选提示，不过这时<br>使用ideaVim插件时无法直接编辑，经网上搜索需要先进入编辑模式，这时候idea模式替换了vim模式，<br>再直接输入新的变量值可以发现整个变量名被清空了。该问题属于idea和ideaVim插件的模式替换问题。<br>命令顺序为<code>Shift + F6  -&gt; i or s -&gt; type new name -&gt; enter</code>.</p><p>提取变量时先将ctrl + w快捷键设置为idea的extend selection智能选择功能(vim中这个快捷键没什么用)，<br>然后使用idea的快捷键ctrl + alt + v提取为本地变量。<br>命令顺序为<code>ctrl + w  -&gt; ctrl + alt + v -&gt; i or s-&gt; type new name -&gt; enter</code>.</p><p>总结: 由以上2个功能来看，当使用idea快捷键后编辑器选中了某个值并给出提示时(包括alt + enter<br>智能提示的结果, alt + j 选取相同变量的结果), 进入插入模式后再进行输入即可替换选中值。<br>注意这里的实现是必须清空，无法在提示内容上追加，直接按a是只修改当前值。<br>在不是手动输入，而是复制粘贴的情况下，因为使用编辑模式进入了idea模式，这时无法使用vim的p<br>进行粘贴，应当使用通用的shift + insert进行粘贴。</p><p>另: ctrl + w正式名称为structural selection, 属于idea快捷键，但它选中的内容在vim 普通模式下<br>还无法获得，需要先进入可视模式, 再使用ctrl + w进行选择后vim就可以获得选取的内容了，使用p<br>可以正常复制。(该bug再未来ideaVim中将会修复)</p><p>2019-09-10 16:21:34 加<br>Idea的alt + J快捷键在可视模式下进行操作会出现问题，而IdeaVim插件内置了一个原生的vim插件<br>vim-multiple-cursors, 默认快捷键是alt + n, 还支持取消选中(alt + p)，跳过选中功能(alt + x).<br>选中以后经测试直接a, i, A, I都无法使用(无反应或不是对选中值操作), 可用的只有c和s键，所以<br>若需要修改时需要先复制原内容，进行编辑模式后就是真正的多光标操作，vim的dw, vws等全都支持。<br>所以需要重构时应使用alt + n + c/s， 而不是用alt + j, 后者有很多问题。<br>又注: 单个变量应使用alt + n, 但对于整句的情况，multi-cursor出现无法选择全部的情况，而<br>ctrl + J可以，所以还是应根据场景结合使用这两者。</p><h2 id="ubantu上通过snap安装idea"><a href="#ubantu上通过snap安装idea" class="headerlink" title="ubantu上通过snap安装idea"></a>ubantu上通过snap安装idea</h2><p>在idea官网的安装教程上突然发现ubantu上可以通过一个叫”snap”的东西安装，还支持自动更新操作。<br>查看过大致资料后发现snap的目标是建立一个可以在所有不同版本的linux系统中通用的应用管理工具，<br>在ubantu, fedora, minx等不同linux流派中都能使用的包管理工具。它不能取代deb, 更多的是在应用<br>层为用户提供统一的服务，简化了安装过程，同时开发者也可以不用再针对不同平台开发不同的特定平台<br>的应用版本。</p><p>下面是使用snap安装idea的过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">snap find &quot;intelliJ idea&quot;</span><br><span class="line">snap info intellij-idea-ultimate</span><br><span class="line">sudo snap install intellij-idea-ultimate --classic</span><br><span class="line">设置代理</span><br><span class="line">sudo snap set system proxy.http=&quot;http://addr:port&quot;</span><br><span class="line">sudo snap set system proxy.https=&quot;http://addr:port&quot;</span><br></pre></td></tr></table></figure></p><p>经过测试使用，即时挂上代理，速度也非常慢，所以无法使用(网上搜索到这是snap store本身的问题),<br>还是下载后安装单个版本吧。</p><h2 id="IntelliJ-Idea在xmonad中显示问题"><a href="#IntelliJ-Idea在xmonad中显示问题" class="headerlink" title="IntelliJ Idea在xmonad中显示问题"></a>IntelliJ Idea在xmonad中显示问题</h2><p>安装ToolTip博客中的步骤安装好jdk和Maven后，启动idea时窗口无法正常显示，开始一直以为是Idea<br>本身的问题，后来在ubuntu中发现可以正常打开，经网上查找原来是xmonad不在jdk的gui展示列表中，<br>(很多新的窗口管理工具jdk都不支持), 在mac上使用xmonad.hs中修改的setWMName  “LG3D”可以正常<br>打开，但thinkpad上就不行，后来在xmonad faq中发现最方便的方法是添加环境变量，thinkpad也能正常<br>打开Idea窗口了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If you are using openjdk6 &gt;= 1.6.1, the cleanest way to work around the hardcoded </span><br><span class="line">list is to warn the vm that xmonad is non-reparenting by exporting the appropriate </span><br><span class="line">environment variable:</span><br><span class="line"></span><br><span class="line">_JAVA_AWT_WM_NONREPARENTING=1</span><br><span class="line">// 经本人测试， jdk 8也有效</span><br></pre></td></tr></table></figure></p><h2 id="IntelliJ-idea新项目运行时警告编译的jdk版本问题"><a href="#IntelliJ-idea新项目运行时警告编译的jdk版本问题" class="headerlink" title="IntelliJ idea新项目运行时警告编译的jdk版本问题"></a>IntelliJ idea新项目运行时警告编译的jdk版本问题</h2><p>新建项目时默认是jdk5，会给出提示，即时在project module setting里面设置为jdk8，重启后又会<br>恢复原值，最根本的解决方法是在maven中指定具体的jdk版本，默认设置为jdk8时可以进行如下设置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">  &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt;</span><br><span class="line">  &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></p><h2 id="IntelliJ智能提示方向键重新映射"><a href="#IntelliJ智能提示方向键重新映射" class="headerlink" title="IntelliJ智能提示方向键重新映射"></a>IntelliJ智能提示方向键重新映射</h2><p>Idea的核心操作是键盘流,配合ideaVim插件非常好用, 在实际使用时, 在idea智能提示弹框出现时,<br>有时目标就是第二个或以下时(第一个直接回车), 如果要选中它, 这时可以多敲几个特定字符将它<br>筛选出来, 但实际上比较繁琐(相对于使用方向键而言, 直接多按2,3下简单直接), 但由于方向键<br>位置的天然劣势, 所以以下提出使用 alt + j/k 来映射到 up/down 方向键.<br>这本身是一个非常简单的映射, 因为它只特定针对idea进行设置, 用于编写代码开发时使用, 我目前是<br>在windows下开发, 所以使用autoHotKey进行修改, 这里附上相应配置文件.</p><p>放在开始的启动目录下, 开机自动执行:<br><code>C:\Users\wutao\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\startUp.ahk</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#Persistent</span><br><span class="line">SetTimer, PressTheKey, 5000</span><br><span class="line">SetTimer, PressTwoKey, 10000</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">PressTheKey:</span><br><span class="line">Send, &#123;ScrollLock&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">PressTwoKey:</span><br><span class="line">Send, &#123;NumLock&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">SetCapsLockState, alwaysoff</span><br><span class="line">Capslock::</span><br><span class="line">Send, &#123;Esc&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">!k::Send, &#123;UP&#125;</span><br><span class="line">!j::Send, &#123;DOWN&#125;</span><br><span class="line"></span><br><span class="line">F12::run, D:\wtt\cmder\Cmder.exe</span><br><span class="line">#c::run, C:\Windows\System32\cmd.exe</span><br></pre></td></tr></table></figure><p>ps: 前面的自动点击scrollLock, numLock键是防止自动锁屏, 下面是将capslock映射为esc键.<br>然后是就是alt+j/k变为方向键, 最后是快速启动终端和命令行.</p><p>pps: 发现我可以直接修改idea的keymap, 不需要使用ahk.目前没有其他地方需要使用alt+j/k代替<br>方向键. 不过这样修改键盘的底层映射适用于那些没有方向键的超小键盘,如66键的键盘—不过<br>太贵了, 本人上次发烧买的filco还可以用很久很久….</p><p>ppps: idea下一个方法的快捷键是alt+down, 由于我上面使用alt+j/k代替了方向键, 所以这个快捷键<br>按不出来, 所以将不用的inline refactor method的快捷键ctrl + alt + n 追加到 next method<br>快捷键中.(本来想使用alt + n, 但ideaVim的multipleCursors扩展插件使用了它, 所以无法使用)</p><p>ps: 将alt + h/l同样映射为left and right, 但实际使用时和idea本身的菜单快捷键冲突, 如<br>alt + v/h会打开View/Help菜单, 网上搜索可以在settings-&gt; appearance -&gt; disable mnemonics<br>in menu即可.</p><p>ps: 这样映射本来是想用在ideaVim的命令行模式中, 但发现idea的keyMap中映射alt + h/l对<br>ideaVim的命令行模式不生效. 所以还是要从vimrc的配置入手.具体vimrc配置请查看VimNote.</p><p>ps: 经过考虑, 决定统一使用ctrl键代替alt键进行方向键映射, 这样保持一致.<br>这样的话, 需要进行如下修改:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 将前面的ahk的键位配置注释掉(前面加分号)</span><br><span class="line">2.  前面的next method可以由默认的alt + down改为ctrl + alt + n, </span><br><span class="line">因为ctrl + alt + j是激活aceJump快捷键;</span><br><span class="line">3. next occurrence可以改回默认的alt + j; </span><br><span class="line">4. commit 默认的ctrl + k由于只有在vcs窗口生效, 所以不需要修改.</span><br><span class="line">5. ctrl + j/k 分别在keymap中映射为down/up.</span><br><span class="line">6. 修改.ideavimrc添加cnoremap注释:</span><br><span class="line">   cnoremap &lt;C-h&gt; &lt;left&gt;</span><br><span class="line">   cnoremap &lt;C-l&gt; &lt;right&gt;</span><br><span class="line">   cnoremap &lt;C-j&gt; &lt;down&gt;</span><br><span class="line">   cnoremap &lt;C-k&gt; &lt;up&gt;</span><br></pre></td></tr></table></figure></p><p>final ps: 经测试发现以上cnoremap无效,而且与split view的carl + j/k冲突, 所以还是得<br>用alt键进行统一.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">最终键位总结如下:</span><br><span class="line">1.  前面的next method可以由默认的alt + down改为ctrl + alt + n, </span><br><span class="line">因为ctrl + alt + j是激活aceJump快捷键;</span><br><span class="line">2. add selection for next occurrence可以改为alt + o; </span><br><span class="line">3. 因为即使像正常的vim里配置, ideaVim plugin也无法使用alt映射, 所以还是只能使用ahk进行</span><br><span class="line">底层键盘映射:</span><br><span class="line">Capslock::Esc</span><br><span class="line">&lt;!k::Up</span><br><span class="line">&lt;!j::Down</span><br><span class="line">&lt;!h::Left</span><br><span class="line">&lt;!l::Right</span><br><span class="line">这样做的话也就不用disable idea菜单了, 因为idea不可能收到alt + h键了, 它只能得到left键. </span><br><span class="line">keymap中也不用配置up/down键了.</span><br></pre></td></tr></table></figure></p><p>结论: 用于ideaVim plugin的功能限制, vim command mode 不可能和真正的vim相同, 所以normal vim<br>可以正常使用的ctrl + h在ideaVim中无法使用, 最终解决办法就是使用ahk修改底层键位映射.<br>这样normal vim统一使用ctrl键, idea统一使用alt键(在windows的ahk作用下).</p><p>注: 经实际测试经过以上ahk配置后, 正常的vim的command mode可以正常使用alt + h产生left效果,<br>但idea中显示为alt + left效果, ideaVimPlugin还是无法抛弃方向键. 所以最终方案是不配置ahk,<br>外部vim同以上使用ctrl键映射为上下方向键, idea内部使用keyMap映射alt键为上下方向, ideaVim<br>plugin command mode还是只能使用原生方向键, 除非不用ideaVim plugin, 使用external tool使用<br>真正的vim, 但明显这样做得不偿失.<br>又注: 因为上述的键不一致, 我又跑去尝试了vsCode和它的vim插件, 虽然打开速度快很多, 但可以看<br>到vsCode支持Java的插件是和eclipse一致的, 而且vim command mode也不支持, 所以我又把它卸载了.<br>最终想到的解决方案是同时打开cmder窗口和idea窗口, 在cmder中使用vim编辑, 在idea中运行, 这样<br>鱼和熊掌可以兼得!完美解决!<br>这样的话, 就涉及到一个修改结果同步的问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. vim -&gt; idea</span><br><span class="line">当在vim中编辑完使用,w写入时, idea会自动刷新, 非常智能, 毕竟是专业的ide.</span><br><span class="line">2. idea -&gt; vim</span><br><span class="line">这一步需要配置下, 所以需要刷新vim buffer, 使用</span><br><span class="line">nmap &lt;leader&gt;r :e&lt;cr&gt;</span><br></pre></td></tr></table></figure></p><p>注: 经实测发现, 通过ahk配置capslock::Esc的方式或是以下代码段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SetCapsLockState, alwaysoff</span><br><span class="line">Capslock::</span><br><span class="line">Send, &#123;Esc&#125;</span><br><span class="line">Return</span><br></pre></td></tr></table></figure></p><p>都存在不稳定的问题, 最后还是采用软件KeyTweak, 只需要配置以下一条即可, 不需要额外配置大写键<br>功能:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key #30 remapped to &quot;Esc&quot;(default=&apos;Capslock&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="插件string-manipulation"><a href="#插件string-manipulation" class="headerlink" title="插件string manipulation"></a>插件string manipulation</h2><p>很早以前就装了这个插件,但并没有真正使用它, 无意中发现它非常好用!<br>java变量名通常有以下2种形式:</p><ol><li>camel case 常见的驼峰式 首字母小写, 后面的独立单词首字母大写<br>pascal case 和驼峰相同, 不过好像pascal case首字母大写</li><li>数据表字段的 snake case<br>如 <code>user_tpl_name</code><br>写mybatis的mapper时需要同时用到这两种形式, 这时string manipulation就非常好用了.<br>默认快捷键alt + m, switch case中选择snake case -&gt; camel case即可.</li></ol><h2 id="live-template实用"><a href="#live-template实用" class="headerlink" title="live template实用"></a>live template实用</h2><p>idea的live template以前一直知道,到并没有怎么使用, 但无意中看到江南一点雨的视频,其中展示了<br>使用它非常实用的技巧, 就像上面的string manipulation一样.这里记录下.<br>主要就是这句, 人人都可以看到的日志对象: (这里使用slf4j + log4j2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">// 定义loggger对象</span><br><span class="line">private static final logger LOGGER = LoggerFactory.getLogger(xxx.class);</span><br></pre></td></tr></table></figure></p><p>这句如果手写因为类名不同非常麻烦, 可以用idea live template帮忙自动生成.<br>settings -&gt; editor -&gt; live template -&gt; +<br>abbreviation: log  越短越好<br>description: 日志<br>template text:</p><p>private static final logger LOGGER = LoggerFactory.getLogger($className$.class);</p><p>这里输入自定义的$className$后, 右边的edit variable变成可点击状态, 可以给自己定义的变量<br>指明表达式,默认值等,直接选择className即可.(里面有很多选项,但感觉实用的不多)<br>如果勾选了use static import if possible, 那么LoggerFactory会变成静态导入, 生成语句中<br>LoggerFactory会省略, 感觉不太好, 还是不要勾选.<br>ok! 类里面输入log + tab就ok了!</p><h2 id="idea中dao层注入-Autowired报错"><a href="#idea中dao层注入-Autowired报错" class="headerlink" title="idea中dao层注入@Autowired报错"></a>idea中dao层注入@Autowired报错</h2><p>这个问题以前是修改settings里面的inspection级别,但感觉不太好,<br>可以在dao层上使用@Repository注解即可解决.</p><h2 id="ideaVim-plugin-close-split-window"><a href="#ideaVim-plugin-close-split-window" class="headerlink" title="ideaVim plugin close split window"></a>ideaVim plugin close split window</h2><p>ideaVim plugin中使用:sp或:vs打开一个新窗口, 但:q不能退出, 使用ctrl+w,c可以关闭.<br>但这样idea的智能选择ctrl + w就冲突了，可以将它修改为ctrl + s.<br>idea默认自动保存，这样其实会影响性能，并且在开发前端时，自动保存触发了webpack-dev-server<br>不必要的热部署，所以可以将自动保存去除。<br>在settings - appearance &amp; behavior - systemSettings - synchronization中<br>去除勾选 synchronize files on frame or editor tab activation (激活idea或切换tab时保存)<br>去除勾选 save files on frame deactivation   (切换应用时保存)<br>勾选save files automatically if application is idle for 30 sec (这一步主要是保险起见)<br>修改save all快捷键为ctrl + shift +s. (通过增加保存的按键难度，这样也避免了多按s的问题，<br>这样保存时先按住ctrl + shift, 按下s后松开，再松开2个修饰键，避免了多按s的错误)</p><p>这样智能选择就是ctrl + s, 保存是ctrl + shift + s, close vim split window是ctrl+w, c<br>close other vim windows是ctrl+w,o</p><p>全部关闭后不要使用ctrl + shift + backspace回到上次修改的地方，这样还需要鼠标点击激活，<br>应使用ctrl + tab切换回上次编辑的tab页。<br>jump to last tool window之前我设置的是F10，发现改为波浪线~backreferece键更方便，<br>主要是用于package Manager和editor之间切换，适用于开发时需要大量新建文件夹和文件的时候。<br>使用~和escape进行窗口切换，使用alt+j/k或直接输入英文在package manager中进行选择.<br>注：以上配置中，反引号就无法打印出来了，如mysql的字段，前台的es6模板字符串解析都需要用到<br>这个符号，所以idea中应设置为alt + 反引号.这样更顺手。</p><h2 id="private-String"><a href="#private-String" class="headerlink" title="private String"></a>private String</h2><p>也许是我太初级了，但是java写这个privte String时，idea对String要全部打完才会显示出来，它<br>默认最先提示strictp…., 今天终于不能忍，自定义了一个live template, pst + tab即可显示出来，<br>文本为<code>private String $input$;</code>, 这里的变量只是一个占位符，不用定义它。<br>也找了一下后缀表达式补全(postfix completion), 但没有定义成功，就用live template吧。<br>网上有自定义的后缀补全插件(试用了一下，自定义没有成功, 还是先用live template吧)。</p><h2 id="mac重装idea无法启动问题解决"><a href="#mac重装idea无法启动问题解决" class="headerlink" title="mac重装idea无法启动问题解决"></a>mac重装idea无法启动问题解决</h2><p>这里需要删除mac中的.intelliJ20xx用户配置目录，位于/Usres/xxx/资源库/Preferences/intelliJ20xx<br>目录中, 删除即可。</p><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><p>在pom.xml中添加lombok依赖后, 可以使用常见的@Data, @Log, 这时如果不添加插件, 编写代码时调用<br>set, get方法没有提示!无法编码, install lombok plugin后, idea会提示是否启用<br>annotation processor(这是lombok的关键技术), 启用后即可正常使用了.<br>注: @Log 查看源码使用的是java.util.logging.Logger, 使用slf4j时应使用@Slf4j注解。 </p><h2 id="idea-git-diff-and-merge-color"><a href="#idea-git-diff-and-merge-color" class="headerlink" title="idea git diff and merge color"></a>idea git diff and merge color</h2><p>idea color theme好用的是gapStyle color, 但它自带的git diff/merge color背景色不清晰, 没有<br>github那种删除背景色是红色, 新增背景色是绿色, 一目了然, 这点可以在idea - settings</p><ul><li>editor - color scheme - diff &amp; merge中设置, 只修改important即可. 亮度调为150-160之间.</li></ul><h2 id="idea-tomcat-visit-uploaded-files-configuration"><a href="#idea-tomcat-visit-uploaded-files-configuration" class="headerlink" title="idea tomcat visit uploaded files configuration"></a>idea tomcat visit uploaded files configuration</h2><p>local tomcat store uploaded files in local computer, its path is like H://GisFiles/,<br>so we need to config it in tomcat. it is called virtual directory in tomcat, and it also<br>applys for war file.Here we use it to visit uploaded files.<br>There are two ways to config it.</p><ol><li>modify the ${tomcatInstance}/conf/server.xml, add<br><code>&lt;Context path=&quot;&quot; docBase=&quot;H:/GisFile/&quot;&gt;&lt;/Context&gt;</code> in Host tag</li><li><p>add a gisFile.xml in ${tomcatInstance}/conf/Catalina/localhost, content same as above<br>one.<br>Idea’s tomcat instance configuration is like<br><code>C:\Users\wutao\AppData\Local\JetBrains\IntelliJIdea2020.2\tomcat\Unnamed_xxxx</code>, we can<br>see it when the tomcat start up, but we do not need to manually modify its files, idea<br>make it easy to add virtual path:<br><strong>In tomcat configuration’s deployment, add plus icon, and we can add the uploaded files<br>or war file location, use the default Application context, and it is done!</strong></p><p>2020-11-18 17:31:51 added:<br>by default, tomcat autodeploy in conf/server.xml is true, so after testing,<br>when I modify the java file and use command<br><code>mvn clean compile war:exploded</code> to repackage the war, the server will report error first<br>and then autodeploy and make the changes take effect.<br>Here we must clean or remove the target directory first, otherwise the tomcat will not<br>redeploy. This is the command line hotDeploy code.<br>On the other hand, in idea tomcat, after changing code,just save the changes and rebuild<br>the code, the idea has a function called hotswap in settings -&gt; build, execution, deployment<br>-&gt; debugger -&gt; hotSwap, it will make the changes classes to exploded war file and make<br>tomcat recognize it. Quite convenient.</p><p>PS: use the tomcatBaseDir/bin/catalina.sh run in command line will see the real-time output<br>of tomcat, no need to tail -f logs/catalina.out anymore.</p></li></ol><h2 id="old-lib-jars-project-change-to-use-maven"><a href="#old-lib-jars-project-change-to-use-maven" class="headerlink" title="old lib jars project change to use maven"></a>old lib jars project change to use maven</h2><p>Recently I work in a new company and its project use old lib jars without maven, I feel<br>it cubersome to add new jars, so I decided to make it a maven project.</p><ol><li>in idea select the project root project and choose add framework support and select<br>maven.</li><li>mannually add pom.xml files, with parent and child modules.</li><li>view -&gt; tool windows -&gt; maven, and add these new pom files.</li><li>use this script below to import local lib jar file be recognized by maven:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.wtt&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;AAA&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;system&lt;/scope&gt;</span><br><span class="line">    &lt;systemPath&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib/aliyun-java-sdk-core-4.4.2.jar</span><br><span class="line">    &lt;/systemPath&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>because we have many jar files in lib directory, so we need to use perl to replace the<br>artifactId AAA to incremental numbers, check my vimnote post to see the one-line script.<br>And when we set up the project file structure as maven demanded, like<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/main</span><br><span class="line">src/main/java</span><br><span class="line">src/main/resources</span><br><span class="line">src/main/webapp</span><br><span class="line">src/test</span><br><span class="line">src/test/java</span><br><span class="line">src/test/resources</span><br><span class="line">target</span><br><span class="line">pom.xml</span><br></pre></td></tr></table></figure></p><p>ps: the default maven compile path is target/classes and target/test-classes.</p><p>when the structure is done, then the idea will generate a perfectly war and war-exploded<br>artifact for us, do not need to mannually create one like what I have done before. We can<br>use this artifact to deploy in tomcat and it will work good. After test, the tomcat before<br>launch just need to use build artifact option only, do not need to build in advance.</p><p>However, we can also use maven to help us to package our needed war files, add the<br>maven-war-plugin as below:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">       &lt;finalName&gt;warName&lt;/finalName&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">           &lt;/plugin&gt;</span><br><span class="line">       &lt;/plugins&gt;</span><br><span class="line">   &lt;/build&gt;</span><br></pre></td></tr></table></figure></p><p>after we install maven-war-plugin, as maven has three life phases: clean default site, we<br>can just one option (like artifact): run maven goal –&gt; clean compile war:exploded<br>compile will compile test java files, we can make sure test classes compiles also good,<br>so we can use maven goal –&gt; clean test-compile war:exploded to make sure our test classes<br>are also good. After setting this, tomcat is good to go! </p><p>And you can use command line to<br>package your project war file now without opening idea if you install maven in command<br>line and set up the corresponding maven environment, just add the maven home bin to system<br>path is enough, after jdk is installed.</p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/20190301_1.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IntelliJ Idea Note&lt;br&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://www.taoblog.cn/categories/Tool/"/>
    
    
      <category term="IntelliJ Idea" scheme="http://www.taoblog.cn/tags/IntelliJ-Idea/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 8.0安装步骤</title>
    <link href="http://www.taoblog.cn/post/23d20f56/"/>
    <id>http://www.taoblog.cn/post/23d20f56/</id>
    <published>2019-02-27T05:41:35.000Z</published>
    <updated>2019-09-20T15:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql 8.0<br><a id="more"></a></p><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><p><strong>windows 64位操作系统</strong><br><strong>mysql 8.0.15</strong><br><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">mysql cummunity 8.0.15官网下载</a><br>官网下载需要登录oracle账户，注册一个就行。</p><h2 id="解压到自定义目录"><a href="#解压到自定义目录" class="headerlink" title="解压到自定义目录"></a>解压到自定义目录</h2><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>我的是配为<code>E:\Mysql\mysql-8.0.15-winx64\bin</code>,可以看到和java一样，bin目录下有很多mysql命令。</p><h2 id="自定义mysql配置文件-option-file"><a href="#自定义mysql配置文件-option-file" class="headerlink" title="自定义mysql配置文件(option file)"></a>自定义mysql配置文件(option file)</h2><p>这一步是mysql 8.0 documentation里提供的，地址为<a href="https://dev.mysql.com/doc/refman/8.0/en/option-files.html" target="_blank" rel="noopener">mysql 8.0 using option file</a><br>在mysql安装根目录下新建文本文件命名为my.ini,内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># set basedir to your installation path</span><br><span class="line">basedir=E:\\Mysql\\mysql-8.0.15-winx64</span><br><span class="line"># set datadir to the location of your data directory</span><br><span class="line">datadir=E:\\MysqlData</span><br></pre></td></tr></table></figure></p><h2 id="初始化data文件夹"><a href="#初始化data文件夹" class="headerlink" title="初始化data文件夹"></a>初始化data文件夹</h2><p>用管理员登录cmd窗口，输入<br><code>mysqld --initialize-insecure --console</code></p><h2 id="安装mysql服务"><a href="#安装mysql服务" class="headerlink" title="安装mysql服务"></a>安装mysql服务</h2><p><code>mysqld -install</code></p><h2 id="运行mysql服务"><a href="#运行mysql服务" class="headerlink" title="运行mysql服务"></a>运行mysql服务</h2><p><code>net start mysql</code><br>这一步命令行提示服务无法启动，不过通过开始-服务里看到服务已经起好了。</p><h2 id="登录mysql账户"><a href="#登录mysql账户" class="headerlink" title="登录mysql账户"></a>登录mysql账户</h2><p><code>mysql -u root -p</code><br>直接回车即可。</p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p><code>alter user &#39;root&#39;@&#39;localhost&#39;IDENTIFIED BY &#39;root&#39;;</code><br><code>exit</code>退出重登即可。</p><h2 id="安装Navicat"><a href="#安装Navicat" class="headerlink" title="安装Navicat"></a>安装Navicat</h2><p>网上下好安装包并破解后，运行测试连接报错：</p><blockquote><p>error 2059: Authentication plugin ‘caching_sha2_password’ cannot be loaded</p></blockquote><p>原来mysql 8修改了加密规则，可以执行以下命令</p><blockquote><p>ALTER USER ‘yourusername‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘youpassword’;</p></blockquote><p>连接成功！</p><h2 id="java连接mysql-8-0"><a href="#java连接mysql-8-0" class="headerlink" title="java连接mysql 8.0"></a>java连接mysql 8.0</h2><p>从网上博客得知：<br>通过jdbc连接的报错信息可以看出：</p><blockquote><p>mysql8.0和之前版本的区别，首先驱动换了，不是com.mysql.jdbc.Driver而是<br>‘com.mysql.cj.jdbc.Driver’,此外mysql8.0是不需要建立ssl连接的，你需要显示关闭。<br>最后你需要设置CST。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">//  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test_demo?</span><br><span class="line">    useSSL=false&amp;serverTimezone=UTC&quot;,&quot;root&quot;,&quot;password&quot;);</span><br><span class="line">//  conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test_demo&quot;,&quot;root&quot;,&quot;password&quot;);</span><br></pre></td></tr></table></figure><h2 id="mysql建立用户及赋予权限命令记录-mysql-5-7-0上记录使用"><a href="#mysql建立用户及赋予权限命令记录-mysql-5-7-0上记录使用" class="headerlink" title="mysql建立用户及赋予权限命令记录(mysql 5.7.0上记录使用)"></a>mysql建立用户及赋予权限命令记录(mysql 5.7.0上记录使用)</h2><p>工作上用到mysql，需要自己建立用户和建表，并且让同事可以连我本地的mysql服务，这里简单记录<br>下命令.</p><ol><li>建立用户<br>使用root用户登录后，新建用户<blockquote><p>create user ‘pra‘@’%’ identified by ‘pra’;</p></blockquote></li></ol><p>这里%表示该用户可以从任意远程主机登录。</p><ol start="2"><li>授权<blockquote><p>grant all on pradb.* to ‘pra‘@’%’;</p></blockquote></li></ol><p>格式为<code>grant privileges on database.tablename to &#39;user&#39;@&#39;host&#39;;</code><br>如果想让pra用户可以授权，后面加上<code>with grant option</code>。</p><ol start="3"><li><p>撤销用户权限</p><blockquote><p>revoke all on pradb.* from ‘pra‘@’%’;</p></blockquote></li><li><p>查看权限</p><blockquote><p>show grants;  # 查看当前用户权限<br>show grants for ‘pra‘@’%’; # 查看其它用户如pra@%的权限</p></blockquote></li></ol><h2 id="mysql大小写问题"><a href="#mysql大小写问题" class="headerlink" title="mysql大小写问题"></a>mysql大小写问题</h2><p>今天工作中发现了mysql大小写的问题，本地windows系统大小写不敏感，测试服务器上linux系统大写<br>写敏感，在my.ini中有变量<code>lower_case_table_names</code>的值来控制，<br>不同系统默认值不一样，其值解释如下：</p><blockquote><p>lower_case_table_names=0  unix系统默认值，大小写敏感，在windows上设置会导致index corruption<br>lower_case_table_names=1  windows默认值，大小写不敏感<br>lower_case_table_names=2  mac系统默认值，数据库和表名，列名显示都是大小写敏感，但进行查询时全部转换成小写</p></blockquote><p>官网上给出的方案就是windows上的值改成2，查询还是没有大小写限制，但是通过名字大小写可以看<br>出来，所以在本地开发时注意下大小写就行。</p><p>注: linux上mysql改成大小写不敏感</p><ol><li><p>找到mysql配置文件</p><blockquote><p>ubuntu:<br>/etc/mysql/mysql.conf.d/mysqld.cnf<br>centos:<br>/etc/my.cnf</p></blockquote></li><li><p>修改my.cnf</p><blockquote><p>[mysqld]<br>lower_case_table_names=1</p></blockquote></li><li><p>重启mysql</p><blockquote><p>ubuntu<br>systemctl restart mysql.service<br>centos<br>systemctl restart mysqld<br>或者 service mysqld restart</p></blockquote></li></ol><h2 id="mysql表空间"><a href="#mysql表空间" class="headerlink" title="mysql表空间"></a>mysql表空间</h2><p>mysql 5.7以后默认使用<code>File_Per_Table</code>表空间，<br>即在mysql console中输入查询语句<br><code>show variables like &#39;%per_table%&#39;;</code><br>可以看出该变量默认是ON的状态。<br>进一步查看mysql数据内容，windows查看自定义的mysqlData目录，<br>linux服务器查看<code>/var/lib/mysql/</code>目录，进入相应的数据库目录中，可以看见每个表都有自己的<br>.frm和.ibd文件，.ibd即为该表的独立表空间文件。</p><p>mysql 5.7以前是共享系统表空间，它和<code>File_Per_Table</code>表空间的区别大致总结如下：</p><ol><li><p>系统表空间不受文件系统大小限制，可以分开存储在不同的磁盘中，单表上限64TB.但共享系统空间<br>经删除等操作后无法回收相应的空间，无法重复利用。</p></li><li><p><code>File_Per_Table</code>可以移动单个表到另一个数据库，可以执行optimize table来压缩或重新创建表<br>空间，truncate或drop表时可以回收相应的空间。缺点是每个表可能有未使用的表空间，可能造成浪费，<br>无法与旧版本的mysql兼容，变量<code>innodb_autoextend_increment</code>的值作用于系统共享表空间中，对<br>FPT表空间无效果，FPT扩容开始时较小，后面是以4MB开始增长。</p></li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li><p>MySQL免安装版，遇到MSVCR120.dll文件丢失错误的解决方案<br>下载 VC redist packages for x64，下载完成，点击运行即可</p></li><li><p>命令行远程登录mysql</p><ol><li>需要本地安装mysql</li><li>用管理员打开命令行窗口，net start mysql</li><li>输入以下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u &#123;username&#125; -p -h &#123;remote server ip or name&#125; -P &#123;port&#125; -D &#123;DB name&#125;</span><br><span class="line">具体实战</span><br><span class="line">mysql -u root -p -h XXX.XXX.XXX.XXX -P 3306 -D databaseName</span><br><span class="line">输入密码，成功！</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="Ubuntu-18-04上安装Mysql"><a href="#Ubuntu-18-04上安装Mysql" class="headerlink" title="Ubuntu 18.04上安装Mysql"></a>Ubuntu 18.04上安装Mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br><span class="line">mysql --version   // 5.7.27</span><br><span class="line">sudo mysql_secure_installation</span><br><span class="line">sudo mysql</span><br><span class="line">select user, plugin, host from mysql.user;  </span><br><span class="line">// root plugin is auth_socket, need changing to password</span><br><span class="line"></span><br><span class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;root&apos;;</span><br><span class="line">// error: password does not satisfy the current policy requirements</span><br><span class="line">// because I choose 0 in previous secure installation, so I need to change to logger than </span><br><span class="line">// 8 password</span><br><span class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;XXXXXXXXXX&apos;;</span><br><span class="line">// 还可以这样写</span><br><span class="line">update mysql.user set authentication_string=password(&apos;xxxx&apos;) where user=&apos;root&apos;;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line">// check plugin</span><br><span class="line">select user, plugin, host from mysql.user;  </span><br><span class="line"></span><br><span class="line">// check mysql status</span><br><span class="line">systemctl status mysql</span><br><span class="line">// other</span><br><span class="line">sudo systemctl start mysql</span><br><span class="line">sudo systemctl stop mysql</span><br><span class="line">sudo systemctl enable mysql   // auto start mysql at login</span><br><span class="line"></span><br><span class="line">// login</span><br><span class="line">mysql -u root -pYOURPASSWD</span><br></pre></td></tr></table></figure><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201902251.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mysql 8.0&lt;br&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://www.taoblog.cn/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://www.taoblog.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Heroku笔记</title>
    <link href="http://www.taoblog.cn/post/fe2ee907/"/>
    <id>http://www.taoblog.cn/post/fe2ee907/</id>
    <published>2019-02-23T13:03:08.000Z</published>
    <updated>2019-03-01T02:20:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Heroku学习笔记, JDK与JRE, clean add path variable(环境变量),PostgreSQL<br><a id="more"></a></p><p>相关文档</p><blockquote><p><a href="https://devcenter.heroku.com/articles/getting-started-with-java?singlepage=true/" target="_blank" rel="noopener">Heroku with Java</a></p></blockquote><h2 id="创建Heroku账号"><a href="#创建Heroku账号" class="headerlink" title="创建Heroku账号"></a>创建Heroku账号</h2><p>在<a href="https://signup.heroku.com/login" target="_blank" rel="noopener">Heroku官网</a>注册即可，需要注意的是qq邮箱和网易邮箱等都<br>不支持，所以这里我用的是gmail邮箱，密码是字母，数字和特殊字符混合。<br>要求的jdk8，maven3已满足条件。</p><h2 id="安装Heroku-Command-Line-Interface-CLI"><a href="#安装Heroku-Command-Line-Interface-CLI" class="headerlink" title="安装Heroku Command Line Interface(CLI)"></a>安装Heroku Command Line Interface(CLI)</h2><blockquote><p>$ brew install heroku/brew/heroku</p></blockquote><h2 id="用Heroku的例子来练手"><a href="#用Heroku的例子来练手" class="headerlink" title="用Heroku的例子来练手"></a>用Heroku的例子来练手</h2><p>下载了Heroku的例子，在它的github页面上说clone完以后可以直接这样做:</p><blockquote><p>$ mvn install<br>$ heroku local</p></blockquote><p>结果在执行最简单的<code>mvn install</code>时报错<code>Maven Error: Perhapss you are Running on a JRE ratherthan a JDK</code>,无语,用<code>mvn -v</code>查看始终是那个plugin的jre目录，网上说的设置JAVA_HOME环境变量<br>无效，还好最后发现了这个解决方案,在<code>$HOME/.mavenrc</code>文件中写入</p><blockquote><p>JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home</p></blockquote><p>搞定！</p><h2 id="JDK和JRE的区别"><a href="#JDK和JRE的区别" class="headerlink" title="JDK和JRE的区别:"></a>JDK和JRE的区别:</h2><blockquote><p>1.JVM – java virtual machineJVM就是我们常说的java虚拟机，<br>它是整个java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，<br>这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，<br>而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。<br>2.JRE – java runtime environmentJRE是指java运行环境。<br>光有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。<br>在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，<br>lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。所以，<br>在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，<br>这样你的朋友就可以运行你写程序了。（jre里有运行.class的java.exe）<br>3.JDK – java development kitJDK是java开发工具包，基本上每个学java的人都会先在机器上<br>装一个JDK，那他都包含哪几部分呢？让我们看一下JDK的安装目录。在目录下面有六个文件夹、<br>一个src类库源码压缩包、和其他几个声明文件。其中，<br>真正在运行java时起作用的是以下四个文件夹：bin、include、lib、 jre。<br>现在我们可以看出这样一个关系 JDK包含JRE，而JRE包含JVM。bin:最主要的是编译器(javac.exe),<br>include: java和JVM交互用的头文件, lib：类库, jre:java运行环境<br>（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）<br>总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。<br>eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，<br>所以在安装时你会发现他们只要求你选中jre路径就ok了。</p></blockquote><p>注：查看path变量时发现有很多重复的路径，但我只有.bash_profile中定义了path变量，后来发现是多次<br>source .bash_profile文件它多次追加上去的，重启终端就可以看见没有重复的了，网上有个简单的<br>方法可以判断path是否已经包含该路径，若没有，才进行追加。</p><h2 id="干净添加环境变量"><a href="#干净添加环境变量" class="headerlink" title="干净添加环境变量"></a>干净添加环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add() &#123; case &quot;:$&#123;PATH:=$1&#125;:&quot; in *:$1:*) ;; *) PATH=&quot;$1:$PATH&quot; ;; esac; &#125;</span><br><span class="line">add $JAVA_HOME</span><br></pre></td></tr></table></figure><p>经过以上步骤以后，可以在<code>localhost:5000</code>上看到Heroku的例子,<br>接着按其README.md步骤走：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heroku create # 在heroku上创建了一个仓库并且建立了远程分支heroku的追踪关系 </span><br><span class="line">git push heroku master  # 推送代码到heroku分支</span><br><span class="line">heroku open # 自动打开浏览器</span><br></pre></td></tr></table></figure></p><p>这时可以看见在heroku域名上app发布运行了。<br>可以用以下命令查看一些app信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ heroku config  # 查看配置的环境变量 这里显示的是实际的databaseURL，amazon的</span><br><span class="line">$ heroku addons  # 相关插件，看到自动配了一个postgresql数据库</span><br><span class="line">$ heroku open db   # 最后的db是项目目录后追加的路径，功能是访问一次就追加一条记录。</span><br><span class="line">$ heroku pg      # show database information</span><br></pre></td></tr></table></figure></p><h2 id="自己的项目发布到Heroku"><a href="#自己的项目发布到Heroku" class="headerlink" title="自己的项目发布到Heroku"></a>自己的项目发布到Heroku</h2><p>这里用于实验是springboot实战一书的例子，使用h2数据库，用Thymeleaf展示一个读书列表的页面，<br>已经同步到github上，下面来改造并部署到heroku上。</p><ol><li><p>项目根目录下新建system.properties文件</p><blockquote><p>java.runtime.version=1.8</p></blockquote></li><li><p>项目根目录下新建Procfile文件和app.json文件</p><blockquote><p>web: java -jar target/XXX-YYY.jar   # web代表接受外面的http请求</p></blockquote></li></ol><p>app.json中写明app名字，描述和使用的addon信息。</p><ol start="3"><li><p>创建heroku app,这一步主要是创建heroku的git仓库。</p><blockquote><p>$ heroku create appname<br>$ mvn install<br>$ heroku local</p></blockquote></li><li><p>推送到heroku的仓库并打开页面访问app</p><blockquote><p>$ git push heroku master<br>$ heroku open</p></blockquote></li></ol><p>Done!</p><h3 id="heroku发布后出问题时版本回退办法"><a href="#heroku发布后出问题时版本回退办法" class="headerlink" title="heroku发布后出问题时版本回退办法"></a>heroku发布后出问题时版本回退办法</h3><blockquote><p>$ heroku releases   # 查看发布版本记录<br>$ heroku releases:rollback v102  # v102改成相应版本记录</p></blockquote><p>这里也就是说不管是改动代码(code),环境配置(config vars),插件(add-ons)都会产生一个新的release。</p><h3 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a>Addons</h3><p>Dyno可以看成是一个文件系统中包含了release的虚拟unix容器，比如说可以有3个web,2个queue的<br>dyno,具体情况通过<code>heroku ps</code>查看。<br>因为各个Dyno之间的文件状态是隔绝的，所以可以通过addOn来进行Dyno之间的通信，比如web Dyno<br>存储数据到数据库的addon中，queue Dyno可以从数据库addon中查询数据来进行操作。</p><blockquote><p>通过hello的例子可以看出，addons信息配置在根目录下的app.json文件里。</p></blockquote><h3 id="logging-and-monitoring"><a href="#logging-and-monitoring" class="headerlink" title="logging and monitoring"></a>logging and monitoring</h3><p>所有dyno的所有进程的信息会汇聚到一个高性能日志系统logplex中，使用命令</p><blockquote><p>$ heroku logs</p></blockquote><p>查看所有dyno的日志信息,如包括router路由，web1,web2等,可以只查看某个dyno日志</p><blockquote><p>$ heroku logs –ps web.1 –tail   # –tail可以实时更新日志 </p></blockquote><p>多个web dyno可以实现负载均衡。</p><blockquote><p>heroku ps:scale web+5</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A single dyno runs a single instance of a process type (which itself can then spawn </span><br><span class="line">and manage several sub-processes).</span><br></pre></td></tr></table></figure><ol start="5"><li>将h2数据库改造成postgresql<h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2>windows 64位安装postgreSQL,直接双击安装运行包报一个安装runtime错误,网上搜索得知可以<br>跳过安装该runtime,用命令行安装<blockquote><p>./postgresql-9.6.12-1-windows-x64.exe –install_runtimes 0 </p></blockquote></li></ol><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201901312.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Heroku学习笔记, JDK与JRE, clean add path variable(环境变量),PostgreSQL&lt;br&gt;
    
    </summary>
    
      <category term="Heroku" scheme="http://www.taoblog.cn/categories/Heroku/"/>
    
    
      <category term="Heroku" scheme="http://www.taoblog.cn/tags/Heroku/"/>
    
      <category term="JDK与JRE" scheme="http://www.taoblog.cn/tags/JDK%E4%B8%8EJRE/"/>
    
      <category term="Path Variable" scheme="http://www.taoblog.cn/tags/Path-Variable/"/>
    
      <category term="PostgreSQL" scheme="http://www.taoblog.cn/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>工具小技巧合集</title>
    <link href="http://www.taoblog.cn/post/398a782a/"/>
    <id>http://www.taoblog.cn/post/398a782a/</id>
    <published>2019-02-11T06:31:10.000Z</published>
    <updated>2021-03-26T07:40:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>自己总结的工具小技巧: Eclipse, Sublime Text, IntelliJ Idea, Maven, Vim, Babun, Git,<br>Windows10,Karabiner<br><a id="more"></a></p><h2 id="eclipse-windows快捷键"><a href="#eclipse-windows快捷键" class="headerlink" title="eclipse windows快捷键"></a>eclipse windows快捷键</h2><p>下载eclipse安装包应注意选择javaEE版，它里面自带了maven插件。<br>注：如可以下载eclipse vim插件，以下快捷键设置可以不用看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">向上 line up     ctrl+k</span><br><span class="line">向下 line down   ctrl+j</span><br><span class="line">左 previous column  ctrl+h</span><br><span class="line">右 next column  ctrl+L&lt;go to line&gt;</span><br><span class="line">alt+j     incremental find</span><br><span class="line">alt+k    find next</span><br><span class="line">智能提示 .abcd....</span><br><span class="line">字体</span><br><span class="line">背景色 general-editors-text editors</span><br><span class="line"></span><br><span class="line">Ctrl+a      line start</span><br><span class="line">Ctrl+u    Line end</span><br><span class="line">Ctrl+i     Correct indentation 自动缩进</span><br><span class="line">给本地变量赋值 quick assist assign to local variable    ctrl+2,L改为ctrl+p</span><br><span class="line"></span><br><span class="line">ctrl+z  undo the last operation</span><br><span class="line">ctrl+y redo the last operation</span><br><span class="line">全选ctrl+a变为ctrl+shift+a</span><br><span class="line"></span><br><span class="line">show in(package explorer)   alt+1</span><br><span class="line">when editing java source</span><br><span class="line"></span><br><span class="line">show view console   alt+c</span><br><span class="line">show view package explorer  alt+p</span><br><span class="line"></span><br><span class="line">ctrl + backspace 向前删除一个单词</span><br><span class="line">ctrl + delete 向后删除一个单词</span><br><span class="line"></span><br><span class="line">分割窗口 在window下选择new window</span><br><span class="line">然后利用windows系统快捷键window+方向键</span><br><span class="line">控制窗口布局</span><br><span class="line"></span><br><span class="line">ultraEdit分割窗口</span><br><span class="line">“高级”菜单→配置→应用程序布局→文件标签→操作→取掉勾选“可吸附标签”→应用→确定</span><br><span class="line">再进行鼠标拖动到滚动条附近即可</span><br></pre></td></tr></table></figure></p><h2 id="sublimeText-json格式化"><a href="#sublimeText-json格式化" class="headerlink" title="sublimeText json格式化"></a>sublimeText json格式化</h2><p>安装插件Pretty Json, 格式化json文件快捷键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">windows: ctrl + alt + j </span><br><span class="line">macOS:   ctrl + command + j</span><br></pre></td></tr></table></figure></p><h2 id="IntelliJ-Idea"><a href="#IntelliJ-Idea" class="headerlink" title="IntelliJ Idea"></a>IntelliJ Idea</h2><ol><li><p>将当前编辑区文件在package目录下定位显示出来<br>使用插件Scroll From Source,定义快捷键为alt + 2,<br>alt + 1是控制Package目录窗口显示开关。</p></li><li><p>在idea中使用vim模式可以下载插件IdeaVim,定义模式开关快捷键为F1。 </p><h3 id="Idea实现和Eclipse-Workspace一样的多项目并列显示效果"><a href="#Idea实现和Eclipse-Workspace一样的多项目并列显示效果" class="headerlink" title="Idea实现和Eclipse Workspace一样的多项目并列显示效果"></a>Idea实现和Eclipse Workspace一样的多项目并列显示效果</h3></li><li>新建一个空白文件夹ideaWorkspace.</li><li>将需要引入的项目代码拷贝到该文件夹下。</li><li>用idea open ideaWorkspace.</li><li>在右侧的Maven Projects视图中点击加号，用ctrl键多选刚才导入的各个项目的pom.xml文件。</li><li>可以点击刷新图标进行依赖更新。<br>搞定！</li></ol><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>银行里有个jar包找不到，我以为是maven仓库里没有，跟银行里的人说了下，他又给了我2个mirror<br>地址，那么问题来了:</p><blockquote><p>怎么在settings.xml里配置多个mirror同时起作用？<br>mirrorOf是什么意思？<br>repository和mirror的区别是什么？</p></blockquote><p>经过搜索和官方文档，总结如下：</p><ol><li>repository是存储多个jar包的仓库，maven默认是去center仓库下载jar包。</li><li>mirror是repository的复制镜像，由于网速等其他原因用来替代原始仓库，mirror下的mirrorId指定<br>了复制的的repository的ID,而mirrorId是唯一的。</li><li>在mirrorOf里可以使用如<code>*</code>,<code>*,!repo1</code>来控制多个镜像时具体哪一个生效的问题,这里判断的依据<br>就是repository id,<blockquote><p>When you use the advanced syntax and configure multiple mirrors, keep in mind that<br>their declaration order matters. When Maven looks for a mirror of some repository, it<br>first checks for a mirror whose <mirrorof> exactly matches the repository identifier.<br>If no direct match is found, Maven picks the first mirror declaration that matches<br>according to the rules above (if any). Hence, you may influence match order by changing<br>the order of the definitions in the settings.xml</mirrorof></p></blockquote></li></ol><p>就是说它先是寻找最匹配的，再按顺序查找其他匹配的。</p><blockquote><p>As of Maven 3.x, repositories are searched in the order in which they are declared.<br>具体实战settings.xml如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">  &lt;mirror&gt;  </span><br><span class="line">       &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">       &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">       &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          </span><br><span class="line">   &lt;/mirror&gt;</span><br><span class="line"> &lt;/mirrors&gt;</span><br><span class="line"> &lt;profiles&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">      &lt;id&gt;nexus private&lt;/id&gt;</span><br><span class="line"></span><br><span class="line">      &lt;repositories&gt;</span><br><span class="line">       &lt;repository&gt;</span><br><span class="line">         &lt;id&gt;ccb&lt;/id&gt;  </span><br><span class="line">         &lt;name&gt;ccb&lt;/name&gt;  </span><br><span class="line">         &lt;url&gt;http://xxx.xxx.xxx:1280/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">       &lt;/repository&gt;</span><br><span class="line">     &lt;/repositories&gt;</span><br><span class="line">     &lt;pluginRepositories&gt;</span><br><span class="line">       &lt;pluginRepository&gt;</span><br><span class="line">         &lt;id&gt;ccb&lt;/id&gt;  </span><br><span class="line">         &lt;name&gt;ccb&lt;/name&gt;  </span><br><span class="line">         &lt;url&gt;http://xxx.xxx.xxx:1280/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">       &lt;/pluginRepository&gt;</span><br><span class="line">     &lt;/pluginRepositories&gt;</span><br><span class="line">   &lt;/profile&gt;</span><br><span class="line"> &lt;/profiles&gt;</span><br><span class="line"> &lt;activeProfiles&gt;</span><br><span class="line">    &lt;activeProfile&gt;nexus private&lt;/activeProfile&gt;</span><br><span class="line"> &lt;/activeProfiles&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>具体优先级为</p><blockquote><p>本地local .m2/repository &gt; 私服profile &gt; 远程仓库 mirror和pom.xml中的repository</p></blockquote><p>真正解决问题的是这篇文章，点赞！<br><a href="https://swenfang.github.io/2018/06/03/Maven-Priority/" target="_blank" rel="noopener">maven download jars</a><br>注： 可以用如<code>mvn -X dependency:tree</code>来查看maven debug信息。</p><p>nexus的作用就是替代中央仓库，完全自主控制公司或集团内部需要的下载的jar包，是提供了缓存作用<br>的maven仓库。<br><a href="https://blog.packagecloud.io/eng/2017/03/09/how-does-a-maven-repository-work/" target="_blank" rel="noopener">how does a maven repository work?</a><br>经过大半天折腾，我最后仔细的看了下那个没找到的jar包，原来就是现在这个多模块项目的子模块，<br>无语！<br>在相应目录下执行mvn install就好了。。。</p><p>2019.3.10加：<br>经返回查看书籍《maven实战》一书，查漏补缺知识总结如下:</p><ol><li>mvn install即将自己的项目jar包安装到本地仓库</li><li><p>远程仓库的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;&lt;/id&gt;     &lt;!--每个仓库id是唯一的--&gt;</span><br><span class="line">        &lt;name&gt;&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;&lt;/url&gt;</span><br><span class="line">        &lt;releases&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;/enabled&gt; &lt;!-- 可以下载release版本--&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--默认daily-每天检查一次,其他有</span><br><span class="line">            never - 从不更新</span><br><span class="line">            always - 都更新</span><br><span class="line">            interval: X - 每隔X分钟更新--&gt;</span><br><span class="line">            &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt; </span><br><span class="line"></span><br><span class="line">            &lt;!--默认warn-构建时输出警告信息，其他有</span><br><span class="line">            fail - 校验和错误时让构建失败</span><br><span class="line">            ignore - 忽略校验和错误--&gt;</span><br><span class="line">            &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; </span><br><span class="line">        &lt;/releases&gt;</span><br><span class="line">        &lt;snapshots&gt;</span><br><span class="line">            &lt;enabled&gt;false&lt;/enabled&gt; &lt;!-- 不可以下载snapshots版本--&gt;</span><br><span class="line">            &lt;updatePolicy&gt;daily&lt;/updatePolicy&gt; </span><br><span class="line">            &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; </span><br><span class="line">        &lt;/snapshots&gt;</span><br><span class="line">        &lt;layout&gt;default&lt;/layout&gt;   &lt;!-- 布局为maven2或3,而不是maven 1的布局--&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;repositories&gt;</span><br></pre></td></tr></table></figure></li><li><p>远程仓库需要认证时在settingsx.xml文件中配置server信息，id为repositoryId。</p></li><li><p>将项目jar包部署到私服或其他远程仓库。</p><ol><li><p>修改pom.xml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;proj-release&lt;/id&gt;  &lt;!--发布版本的仓库--&gt;</span><br><span class="line">        &lt;name&gt;&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">    &lt;snapshotRepository&gt;</span><br><span class="line">        &lt;id&gt;proj-snapshot&lt;/id&gt;  &lt;!--快照版本的仓库--&gt;</span><br><span class="line">        &lt;name&gt;&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;&lt;/url&gt;</span><br><span class="line">    &lt;/snapshotRepository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p>从远程仓库下载jar包和部署jar包都需要认证，都是配置在settings.xml文件中。</p></li><li><p>执行命令<code>mvn clean deploy</code>,当前项目版本是release版本,maven会部署到发布版本仓库，<br>当前项目若是snapshot版本，会被部署到快照版本仓库。</p><blockquote><p>The Central Maven repository stores release artifacts. Snapshots capture a work<br>in progress and are used during development. A Snapshot artifact has both a version<br>number such as “1.3.0” or “1.3” and a timestamp.</p></blockquote></li><li><p>jar包版本是release或snapshot,latest时，maven首先需要根据远程仓库的更新策略来检查更新，<br><code>&lt;release&gt;</code>的<code>&lt;enabled&gt;</code>,<code>&lt;updatePolicy&gt;</code>的值来确定是否允许下载和是否检查更新（可以在命令行里<br>使用-U来强制更新)。由于release,latest容易版本问题导致构建失败，所以maven 3中已经取消了<br>对它们的支持，实际使用还是以具体版本号较多。</p></li><li><p>镜像仓库完全屏蔽了原仓库，当镜像不可用时，maven无法访问原仓库，所以此时无法下载jar包。</p></li><li><p>生命周期是maven自己定义的概念，具体的操作由不同的maven插件来执行，相当于设计模式里的<br>模版方法。</p></li><li><p>maven有3套相互独立的生命周期: clean(清理项目)、default(构建项目)、 site(建立项目站点),<br>每套生命周期内部的阶段phase前后有依赖关系,某个生命周期的phase的执行对其他生命周期的phase<br>没有影响。<code>mvn clean install</code>执行了clean生命周期的pre-clean,clean阶段，default生命周期的<br>从validate到install的所有阶段。<br><code>mvn clean deploy site-deploy</code>实际执行了clean的pre-clean,clean阶段，default的所有阶段，<br>site生命周期的所有阶段。</p><blockquote><p>clean： pre-clean, clean, post-clean<br>site： pre-site, site, post-site, site-deploy<br>default: validate - initialize - resources - compile - test resources -<br>test compile - test - package - integration test - verify - install -deploy</p><p>default基本流程为:<br>初始化 - 处理主资源文件-编译主源码-处理测试资源文件-编译测试源码-<br>执行测试 - 打包 - 集成测试 - 验证 - 项目jar包安装到本地仓库 - 部署到远程仓库</p></blockquote></li><li><p>单个maven插件可以完成多个功能。由于这些功能有很多可以复用的代码，所以将它们集合到一个<br>插件中，每个功能点就是一个插件目标plugin goal,如命令<code>mvn dependency:tree</code>就是调用了插件<br>maven-dependency-plugin的插件目标:列出项目依赖树。<code>mvn compiler:compile</code>是插件maven-<br>compiler-plugin的compile目标。</p></li><li><p>maven通过将生命周期阶段和对应的插件目标进行绑定从而实现具体的构建任务。如clean生命周期<br>的clean阶段和maven-clean-plugin的clean阶段是默认绑定在一起的。clean生命力周期的pre-clean和<br>post-clean阶段由于没有默认绑定插件目标，所以它们没有实际的行为。</p></li><li><p>可以自定义插件目标绑定到生命周期的某个阶段中，如可以将插件maven-source-plugin的jar-<br>no-fork目标绑定到default生命周期的verify阶段从而实现在该阶段创建出项目的源码jar包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">          &lt;executions&gt;</span><br><span class="line">              &lt;execution&gt;</span><br><span class="line">                  &lt;id&gt;attach-sources&lt;/id&gt;</span><br><span class="line">                  &lt;!--如该phase配置省略，jar-no-fork默认绑定到package阶段执行--&gt;</span><br><span class="line">                  &lt;phase&gt;verify&lt;/phase&gt; </span><br><span class="line">                  &lt;goals&gt;</span><br><span class="line">                      &lt;goal&gt;jar-no-fork&lt;/goal&gt;</span><br><span class="line">                  &lt;/goals&gt;</span><br><span class="line">              &lt;/execution&gt;</span><br><span class="line">          &lt;/executions&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p>插件配置。</p><ol><li>可以在命令行进行配置，如命令<code>mvn install -DskipTests</code>就是在执行default生命<br>周期从开始到install阶段的过程中跳过test阶段。</li><li><p>可以在pom声明该插件时配置该插件的某些全局属性，如maven-compiler-plugin的jdk<br>版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-compile-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">              &lt;source&gt;1.7&lt;/source&gt; &lt;!--编译jdk1.7版本的源文件--&gt;</span><br><span class="line">              &lt;target&gt;1.7&lt;/target&gt; &lt;!--生成与jdk1.7版本兼容的字节码文件--&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p>还可以针对插件目标绑定到某个生命周期阶段的具体任务进行插件配置。此时<br><code>&lt;configration&gt;</code>配置节点位于具体的<code>&lt;execution&gt;</code>节点下。</p></li></ol></li><li><p>命令行里执行<code>mvn -h</code>可以看到其基本使用方法为<code>mvn option goal phase</code>,option为mvn命令<br>执行时的一些参数，如-X等，goal为插件目标，如命令<code>mvn dependency:tree</code>,即mvn是可以直接从<br>命令行调用插件目标的，这适用于那些不方便绑定到某个生命周期阶段的插件目标，如help:describe,<br>dependency:tree等，其中help,dependecy叫做插件前缀，用来代替插件的groupId,artifactId,version<br>信息,maven对前缀的解析分为几个步骤：</p><ol><li>maven有默认的groupId,有org.apache.maven.plugin, org.codehaus.mojo2个groupId,还可以<br>在settings.xml文件的<code>&lt;pluginGroups&gt;</code>中配置自己的插件仓库groupId.</li><li>依赖的元数据位于groupId/artifactId/maven-metadata.xml中，插件的元数据位于groupId/<br>maven-metadata.xml中，其中定义了每个插件前缀和artifactId的映射关系。</li><li>核心插件版本在超级pom中已经设定好了，而对于非核心插件并且没有设定版本号的插件，<br>maven 2会解析到latest版本，maven 3会解析到release版本，不过这样还是容易引起版本问题，<br>所以还是推荐指定插件版本号。</li></ol></li><li><p>maven属性，一般常见的为pom.xml中定义属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;spring.version&gt;4.5&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"># 依赖中就可以使用$&#123;spring.version&#125;来替代具体的版本</span><br></pre></td></tr></table></figure></li><li><p>maven资源过滤，针对如src/main/resources资源目录下的文件，如指定不同环境的数据库JDBC<br>配置,需要根据环境切换，和spring的profile类似，maven也提供了相同的功能。</p><ol><li>maven的profile可以在pom.xml文件，user/.m2/settings.xml文件(针对当前用户有效)，<br>maven安装目录/conf/settings.xml文件(针对本机所有用户有效)这3个文件中定义，其中<br>pom.xml文件由于可以加入版本控制，利于移植，所以pom.xml文件中profile可配置的属性最多，<br>有repository,dependency,depencymanagement,build中的plugin,resource等，而<br>settings.xml中的profile由于不方便分享，所以只能配置仓库和属性值。</li><li>在profile中定义不同环境的profile,如每个profile都有自己的JDBC配置，如db.url属性<br>每个profile的值都不相同，然后在application.yml中使用${db.url}来替代具体的属性值，<br>但是资源文件处理是由插件maven-resources-plugin处理的，但它功能是将项目的主资源文件<br>复制到主代码编译输出目录，测试资源文件复制到测试代码编译输出目录，即它不会解析具体<br>的${db.url}的值，所以我们需要在pom.xml中进行配置告诉它进行属性解析。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resouces&gt;</span><br><span class="line">       &lt;resource&gt;</span><br><span class="line">           &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class="line">           &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">       &lt;/resource&gt;</span><br><span class="line">    &lt;/resouces&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li></ol><p>测试资源目录配置相同,目录由main改成test即可。</p><ol start="3"><li>最后，激活需要使用的profile即可得到需要的配置属性。</li><li>命令行激活 <code>mvn clean install -Pdev</code>激活了dev profile.</li><li>settings.xml文件中<code>&lt;activeProfiles&gt;</code>配置来永久激活某些profile.</li><li>系统属性，操作系统不同，某个文件存在与否都可以用来判断是否激活某个profile.</li><li>默认激活，在以上方式没有任何一种已经激活的情况下，选择默认激活，<code>&lt;profile&gt;</code>下<br>的<code>&lt;activation&gt;&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;&lt;/activation&gt;</code>来默认激活。</li></ol></li><li><p>web资源过滤，对于src/main/webapp目录的资源如果也想开启资源过滤解析属性功能时，<br>由于它是有插件maven-war-plugin控制的，所以需要对该插件进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  &lt;profiles&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;client-a&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;client.logo&gt;a.jpg&lt;/client.logo&gt;</span><br><span class="line">            &lt;client.theme&gt;red&lt;/client.theme&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;client-b&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;client.logo&gt;b.jpg&lt;/client.logo&gt;</span><br><span class="line">            &lt;client.theme&gt;blue&lt;/client.theme&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line"> &lt;/profiles&gt;</span><br><span class="line"></span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1-beta-1&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;webResources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">                &lt;directory&gt;src/main/webapp&lt;/directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**/*.css&lt;/include&gt;</span><br><span class="line">                    &lt;include&gt;**/*.js&lt;/include&gt;</span><br><span class="line">                &lt;/includes&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/webResources&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></li><li><p>聚合<br>聚合的作用是可以一条maven命令同时构建多个项目。</p></li></ol><p>maven聚合模块的groupId, versionId一般与被聚模块相同，聚合模块的打包方式packaging不能为<br>jar或war，必须为pom.<br>module元素的值代表的是被聚模块的相对路径，如聚合模块pom路径为D:/code/parent/pom.xml,module<br>为<code>&lt;module&gt;module1&lt;/module&gt;</code>，代表它有被聚模块D:/code/parent/module1（即这个值代表的是目录名）<br>module1有自己的pom.xml,src/main/java, src/test/java等，可以独立构建。<br>以上是父子目录结构，如果是平行结构，即聚合模块和被聚模块处于同级目录下时，module为<br><code>&lt;module&gt;../module1&lt;/module&gt;</code>.</p><ol start="17"><li>继承<br>继承的作用是消除重复，包括依赖，插件等。</li></ol><p>与聚合相同，父模块的packaging也必须为pom，它也不需要pom.xml之外的src/main等文件，只是为<br>了消除重复。继承体现在子模块pom.xml的parent元素中。</p><p>父项目中使用dependencyManagement元素可以定义统一的依赖groupId,artifactId,version和scope,<br>它并不会实际引入依赖，子模块中只需要定义groupId和artifactId即可引入该依赖，version和<br>scope由dependencyManagement继承而来，这样统一管理了依赖版本。</p><p>可以继承的pom元素主要有<br><code>groupId,versionId,properties,dependencies,dependencyManagement,repositories,build</code></p><p>其中dependencyManagement除了可以复制和继承来实现复用外，还可以通过<code>&lt;scope&gt;import&lt;/scope&gt;</code><br>来引入。即import只有在dm元素下生效，将另一个dm内容引入到当前的dm中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">     &lt;dependencies&gt;</span><br><span class="line">         &lt;dependency&gt;</span><br><span class="line">             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">             &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">             &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">             &lt;-- import的都是pom packaging--&gt;</span><br><span class="line">             &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">             &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line"></span><br><span class="line">         &lt;/dependency&gt;</span><br><span class="line">     &lt;/dependencies&gt;</span><br><span class="line"> &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li></ol><p>类似的，插件也有依赖管理pluginManagement,对一些核心插件的配置，如maven-compiler-plugin<br>对编译jdk版本的控制，maven-resources-plugin对编码格式定为utf-8的控制等，可以在父模块中<br>定义即可，插件完全不用配置即可使用该插件，原因如下：</p><ol><li>生命周期默认绑定的插件不需要显式的配置。</li><li>超级pom定义了这些默认插件的版本。</li><li>pluginManagement定义了这些插件的行为。</li></ol><p>经测试，父项目中直接定义plugins标签，子模块可以继承得到该插件。</p><ol start="18"><li><p>聚合与继承<br>聚合与继承目地不同，聚合只要聚合模块知道哪些被聚合了，继承只有子模块知道自己的父模块。<br>实际开发中为了方便，通常会将聚合与继承合为一个项目。即该父pom中元素有module,properties,<br>dependencyManagement,pluginManagement.</p></li><li><p>maven的约定<br>maven默认的java源代码目录是src/main/java,测试源代码目录src/test/java,这个约定是在maven的<br>超级pom中定义的，maven3的super pom位置为$MAVEN_HOME/lib/maven-model-builder-x.x.x.jar中。</p></li><li><p>maven依赖传递总结<br>相同依赖不同版本的调解原则：</p><ol><li>就近原则，离根路径短者优先。</li><li>声明优先，路径相同时先声明者优先。<br>传递范围：<br>compile: 默认范围，编译，测试，运行都有效<br>test:   只对测试时有效，编译和运行无效，如junit<br>provided: 编译和测试有效，运行无效，如servlet api,运行时外部容器tomcat等已提供。<br>runtime:  测试和运行有效，编译时无效， 如jdbc驱动的实现类，编译时只需要接口，运行时才需要实现。</li></ol><p>依赖传递表左边一列是第一依赖，上面一行是第2依赖。<br>简单总结为：</p><ol><li>第二依赖为compile时，传递依赖范围以第一依赖为准。</li><li>第二依赖为test时，无法传递。</li><li>第二依赖为provided时，只有第一依赖也为provided可以传递，其他范围不能传递。</li><li>第二依赖为runtime时，范围以第一依赖为准，除了第一依赖为compile时，其范围为runtime.</li></ol><p>依赖优化：</p><ol><li>使用exclude标签去除冲突的依赖。</li><li>使用properties标签统一依赖版本号。</li><li>使用mvn dependency:list, tree, analyze查看依赖情况。</li></ol></li><li><p>反应堆<br>在一个多模块项目中，如上层目录是聚合模块，父项目是其他子模块的平级目录，则从聚合模块中<br>执行<code>mvn clean install</code>命令时，maven会按照一定顺序确定构建的顺序，<br>即所有模块构成的构建结构叫做反应堆（reactor),该顺序为反应堆的构建顺序。</p><p>maven按顺序构建pom,如果该模块有依赖，则先构建依赖，如果该依赖还有前置依赖，则也先构建该<br>前置依赖，依次类推。</p><p>如果想一次构建所有项目时，直接执行<code>mvn clean install</code>即可，如果模块非常多，想一次构建<br>其中部分模块，跑到每个模块下执行该命令过于麻烦，可以在父目录下带上命令行参数实时裁剪<br>反应堆，这里记录下以供以后使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用mvn -h查看</span><br><span class="line">mvn clean install</span><br><span class="line">-pl  --projects  构建指定的模块列表，用逗号分割，只会构建模块本身，不构建依赖或下属</span><br><span class="line">-am  --also-make 同时构建它依赖的模块，如构建子模块时，会同时构建父模块parent</span><br><span class="line">-amd -also-make-dependents  同时构建下属依赖，如构建父模块时，会同时构建所有子模块</span><br><span class="line">-rf  -resume-from  在已有反应堆顺序的基础上，可以指定从某个模块开始构建</span><br><span class="line">可以在-pl,-am,-amd的基础上使用-rf来精确控制。</span><br></pre></td></tr></table></figure></li></ol><p>2019-08-02 14:58:50 添加:<br>最近项目上经常因为某些包有安全漏洞需要升级版本，但由于银行内部的nexus仓库没有最新的版本<br>或者说依赖包不全，这时候就需要链接外网到阿里的镜像仓库中下载，这时问题来了，如何编写maven<br>配置文件settings.xml使得通过ali镜像下载的包可以和通过内网下载的包一起生效？</p><p>问题背景是工作是用的虚拟机，虚拟机设置的是按特定网卡链接到虚拟机(还是搞不太清楚具体的虚拟<br>机网络配置), 总之，外网和内网不能同时访问。</p><p>链接外网时，将内网的repository注释掉时发现aliyun还下载了其他不需要更新的包。<br>所以个人认为，下载的包中有记录该包所属的仓库信息，需要在settings配置中保留内网的repository,<br>这样maven就不会到新仓库中去下载本地已有的包了。<br>所以使用以下配置即可，以后无论链接内网或外网，都不应当也不需要更改配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">  &lt;mirror&gt;  </span><br><span class="line">       &lt;id&gt;publicRepo&lt;/id&gt;  </span><br><span class="line">       &lt;name&gt;publicRepo&lt;/name&gt;  </span><br><span class="line">       &lt;url&gt;内网&lt;/url&gt;  </span><br><span class="line">       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          </span><br><span class="line">   &lt;/mirror&gt;</span><br><span class="line"> &lt;/mirrors&gt;</span><br><span class="line"> &lt;profiles&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">      &lt;id&gt;nexus private&lt;/id&gt;</span><br><span class="line">      &lt;repositories&gt;</span><br><span class="line"></span><br><span class="line">       &lt;repository&gt;</span><br><span class="line">         &lt;id&gt;ccb&lt;/id&gt;  </span><br><span class="line">         &lt;name&gt;ccb&lt;/name&gt;  </span><br><span class="line">         &lt;url&gt;内网1&lt;/url&gt;  </span><br><span class="line">       &lt;/repository&gt;</span><br><span class="line">       &lt;repository&gt;</span><br><span class="line">         &lt;id&gt;ccb2&lt;/id&gt;  </span><br><span class="line">         &lt;name&gt;ccb2&lt;/name&gt;  </span><br><span class="line">         &lt;url&gt;内网2&lt;/url&gt;  </span><br><span class="line">       &lt;/repository&gt;</span><br><span class="line">       &lt;!--  其他更多内网url地址， 最后放外网的aliyun地址，这样就可以最大程序利用</span><br><span class="line">       已经有的本地jar包，不用重复下载--&gt;</span><br><span class="line">       &lt;repository&gt;</span><br><span class="line">         &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">         &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">         &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">       &lt;/repository&gt;</span><br><span class="line"></span><br><span class="line">     &lt;/repositories&gt;</span><br><span class="line">   &lt;/profile&gt;</span><br><span class="line"> &lt;/profiles&gt;</span><br><span class="line"> &lt;activeProfiles&gt;</span><br><span class="line">    &lt;activeProfile&gt;nexus private&lt;/activeProfile&gt;</span><br><span class="line"> &lt;/activeProfiles&gt;</span><br></pre></td></tr></table></figure></p><p>2019-08-05 14:35:24添加:<br>还是以上的版本升级问题，相应jar包下载成功后，在pom.xml中指定要升级的特定版本，结果项目启动<br>报错，无法初始化ObjectMapper类。<br>网上说maven编译成功，但运行报错的情况，还是jar包依赖有冲突。这次是要升级jackson-databind<br>版本到2.9.9.2，使用mvn dependency:tree命令发现它依赖的jackson-core和jackson-annotation还是<br>旧版本，查看2.9.9.2的pom文件找到它依赖的core和annotation具体版本，指定以后项目启动成功！</p><p>注: 以上就是解决问题的具体办法，在网上搜索的过程中，如果是自己的项目需要升级springboot中的<br>某个版本，网上说首先是升级springboot本身的版本，这也是最安全的。其次就是在自己的pom.xml使用<br>properties配置项指定要升级的版本，这样也不需要自己声明依赖，也比较安全。最后实在无法解决，<br>才是自己显式的声明依赖版本。</p><p>由于maven依赖的就近原则和声明优先原则，所以依赖的版本有冲突时会被忽略，但升级依赖时冲突的<br>依赖关系会留下隐患(如上面的maven编译成功，运行报错的情况),所以可以使用<br><code>mvn dependency:tree -Dverbose -Dincludes=groupId:artifactId</code>来查看某个依赖的重复引入情况，<br>-Dincludes选项省略即为全部依赖的情况。</p><p>由以上问题也可以看出，当子模块继承了父模块时，当子摸块没有具体指明依赖版本时就会使用父模块的<br>dependencyManagement对子模块影响很大，这对于依赖传递也是同样的效果，所以出问题时可以通过<br>mvn dependency:tree命令查看具体的依赖版本是否正确。</p><p>2020-04-13 21:55:34 添加:<br>刚又碰到个maven的问题，这里记录下。<br>场景是需要从公司的nexus私服中下载一些jar包，但它需要开vpn, 并且该vpn只有windows版本，我想<br>下载包到mac环境使用，所有需要在windows虚拟机中下载好包后到mac中使用。<br>windows虚拟机中安装好jdk, mvn变量后，下载发现localRepository中没有需要的包，后经过开启<br>-X查看，发现依赖路径不对！<br>这里maven, jdk都是windows上的，项目本身在mac上，在项目路径下执行maven打包命令时，发现它的依赖<br>根路径自动切换为mac上，所以我之前写的localRepository=/z/.m2/repository会多出一层z文件夹，<br>直接改为/.m2/repository即可。因为项目的classpath是Z盘，maven有可能取得是这个根路径.</p><h2 id="Babun"><a href="#Babun" class="headerlink" title="Babun"></a>Babun</h2><p>因为vimrc里的mapleader报错，发现babun里面的vim还是版本7的，于是用pact update vim来更新vim，结果<br>运行完成后命令vim没有反应，网上搜索说可以更新cygwin，babun update命令有问题，<br>可以手动更新babun from executing C：\Users\LYPC.babun\update.bat</p><p>上面命令自动运行的cygwin下载速度太慢，还会卡死，所以还是自己来装….</p><ol><li>到官网上下在64位cygwin安装器，镜像地址 <a href="http://mirrors.sohu.com/cygwin/" target="_blank" rel="noopener">http://mirrors.sohu.com/cygwin/</a></li><li><a href="https://github.com/babun/babun/wiki/64-bit/" target="_blank" rel="noopener">https://github.com/babun/babun/wiki/64-bit</a></li></ol><blockquote><p>cp -a /cygdrive/c/Users/LYPC/.babun/cygwin-32/home/ThinkPad-T540p/.<em> ~/<br>cp -a /cygdrive/c/Users/LYPC/.babun/cygwin-32/etc/{group,minttyrc,nanorc,passwd,vimrc} /etc<br>cp -a /cygdrive/c/Users/LYPC/.babun/cygwin-32/usr/local/bin/</em> /usr/local/bin/<br>cp -a /cygdrive/c/Users/LYPC/.babun/cygwin-32/usr/local/etc/* /usr/local/etc/<br>pact install gcc-core $(cat /usr/local/etc/babun/source/babun-packages/conf/cygwin.x86.packages | tr ‘\n’ ‘ ‘)</p></blockquote><p>pact install 下载地址可以添加镜像<br>我的是C:\Users\LYPC.babun\cygwin\home\ThinkPad-T540p.pact地址下修改pact.repo文件<br>将第一行默认的kernel注释掉，加上</p><blockquote><p>PACT_REPO=<a href="http://mirrors.sohu.com/cygwin/" target="_blank" rel="noopener">http://mirrors.sohu.com/cygwin/</a></p></blockquote><p>执行babun install脚本时oh-my-zsh卡住了，找了个镜像可以用<br><a href="https://bitbucket.org/zalew/oh-my-zsh-mirror.git" target="_blank" rel="noopener">https://bitbucket.org/zalew/oh-my-zsh-mirror.git</a></p><p>一通折腾过后，babun里vim变成了8.0.1567，但是mapleader还是报错，mac里也报错，看来是脚本本身的问题，不过目前使用<br>mapleader正常，看来不影响使用,vim的高级用法以后还是要多看看帮助文档，记录零散知识。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>今天建行里面做了Git的简单培训，其中提到2个场景，因为以前也使用git,但对这2种场景具体处理办法<br>还不是很清楚，查询了他人的博客特地总结如下：</p><h3 id="开发上线后产生了一个bug，当前还在开发新功能，如何回退到线上版本修改bug并提交？"><a href="#开发上线后产生了一个bug，当前还在开发新功能，如何回退到线上版本修改bug并提交？" class="headerlink" title="开发上线后产生了一个bug，当前还在开发新功能，如何回退到线上版本修改bug并提交？"></a>开发上线后产生了一个bug，当前还在开发新功能，如何回退到线上版本修改bug并提交？</h3><p>其中最关键的是<code>git reflog</code>命令</p><ol><li><p>上线最好要打一个tag，方便以后回退版本，查看问题等</p><blockquote><p>git commit -m ‘version 1.0’<br>git tag v1.0</p></blockquote></li><li><p>这时已经开发到后面的功能，发现v1.0版本有bug,则进行回退修复处理，在出问题的master分支上<br>先找到v1.0的commitId</p><blockquote><p>git tag  # 查看所有tag<br>git show v1.0  # 从中找出该tag的commitId<br>git reset –hard commitId<br>git checkout -b bugfix  # 新建bugfix分支<br>git checkout master     # 先回master分支<br>git reflog # reflog记录了最近几次的动作包括分支转换，从中找到git reset前最近一次<br>提交的commitId<br>git reset –hard commitId    # 这时master分支回到起始状态</p><p>git checkout bugfix   # 切换回bugfix分支，面对的是干净的有bug的版本v1.0<br>git add -a . &amp;&amp; git commit -m ‘bug fixed’  # 修改bug并提交<br>git tag v1.1   # 可以打上标签为v1.1</p><p>git checkout master   # 切换回master<br>git merge bugfix    # 合并bugfix内容<br>解决冲突后<br>git add -A .    # 冲突的文件需要重新暂存<br>git commit -m ‘bug fixed’   # 解决bug<br>标签需要手动推送到远程仓库，可以使用命令<br>git push origin –tags  # 推送所有tags到远程仓库</p></blockquote></li></ol><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ol><li>合并后产生冲突，可以使用<code>git merge --abort</code>放弃这次合并，回到合并前的状态。</li><li>使用合并工具<code>git mergetool</code>会调用一个可视化工具来解决冲突。</li><li><code>git diff commitId...commitId</code>可以用来查看版本差异，可以手工找到共同祖先，拿到fetch后<br>的commitId.</li><li><code>git show :1:filename</code>查看共同祖先的版本，<code>git show :2:filename</code>查看当前分支head版本，<br><code>git show :3:filename</code>查看远程分支merged_head版本。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 多提交，少推送。多人协作时，推送会频繁地带来合并冲突的问题，影响效率。因此，</span><br><span class="line">尽量多使用提交命令，减少合并的使用，这样会节省很多时间。</span><br><span class="line">2. 使用Git流（Git Flow）。</span><br><span class="line">3. 使用分支，保持主分支的整洁。这是我强烈推荐的一点，在分支进行提交，</span><br><span class="line">然后切到主分支更新(git pull —rebase)，再合并分支、推送。这样的流程会避免交叉合并的情况出现</span><br><span class="line">（不会出现共同祖先节点为多个的情况）。事实上，git合并操作让很多人感到不知所措的原因就是</span><br><span class="line">各种原因所产生的交叉合并问题，从而造成在合并的过程中丢失某些代码。</span><br><span class="line">保持主分支的整洁能够避免交叉合并的情况出现。</span><br><span class="line">4. 禁用fast-forward模式。在拉取代码的时候使用rebase参数（前提是保持主分支的整洁）、</span><br><span class="line">合并的时候使用—no-ff参数禁用fast-forward模式，这样做既能保证节点的清晰，</span><br><span class="line">又避免了交叉合并的情况出现。</span><br></pre></td></tr></table></figure><p>关于fast-foward<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前分支合并到另一分支时，如果没有分歧解决，就会直接移动文件指针。</span><br><span class="line">这个过程叫做fast forward。</span><br><span class="line">例如，开发一直在master分支进行，但忽然有一个新的想法，于是新建了一个develop的分支，</span><br><span class="line">并在其上进行一系列提交，完成时，回到 master分支，此时，master分支在创建develop分支之后</span><br><span class="line">并未产生任何新的commit。 此时的合并就叫fast forward.</span><br><span class="line">可以看到master在合并develop分支的时候并没有产生新的节点回到develop分支，对代码进行修改，</span><br><span class="line">提交。切换到master分支，使用git merge develop --no-ff 进行合并，此时会产生一个commit节点.</span><br><span class="line">很明显使用--no-ff合并时，在删除develop分之后，该分支的合并信息仍然被保留，</span><br><span class="line">在以后的代码分析中可以便捷的查看到历史信息，而fast forward方式则无法辨识代码的合并信息。</span><br></pre></td></tr></table></figure></p><h3 id="Git分支模型使用总结"><a href="#Git分支模型使用总结" class="headerlink" title="Git分支模型使用总结"></a>Git分支模型使用总结</h3><ol><li>master分支是一个长期维护的主分支，主要作用是存储稳定的正式版本内容，数据来源于合并其他<br>分支(如develop,修复紧急bug的短期分支等)，合并完以后打上版本号即可以正式发布。</li><li>develop分支是另一个主分支，develop分支主要用来存储下个版本的最新变化,也不好用于直接干活，<br>可以用来合并其他短期分支(如某个功能分支，修复bug分支等).当版本稳定时，可以将develop分支合<br>并到master分支并打上标签作为新版本发布。</li><li>用于真正干活的短期分支(如功能分支，修复bug分支等),完成后合并到develop分支。<br>具体命令操作如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b some_feature develop   # 从develop分支创建某功能开发分支</span><br><span class="line"></span><br><span class="line"># developing...then merge it to develp branch,before that,rebase pull first</span><br><span class="line"></span><br><span class="line">git checkout develop  # 以下操作都在develop分支下进行</span><br><span class="line">git pull     </span><br><span class="line">git merge --no-ff some_feature  # 不使用fast-forward模式，保留合并信息</span><br><span class="line">git branch -d some_feature   # 删除该短期分支</span><br><span class="line">git push origin develop  # 推送到远程develop分支,这里默认本地develop分支追踪远程develop分支</span><br></pre></td></tr></table></figure></li></ol><p>develop分支合并到master分支过程基本相同，只不过记得打上标签tag,并使用命令<code>git push --tags</code><br>来推送tag。</p><p>注： 如在develop分支上执行命令<code>git rebase master</code>将会导致develop分支上与master分支分离的<br>后续全部提交变成补丁(patch),git会逐个将这些补丁添加到现有的master分支上，从而使得master<br>分支与新的develop分支在一条直线上。<code>git pull</code>相当于<code>git fetch &amp;&amp; git merge</code>,而<code>git pull --rebase</code>相当于<code>git fetch &amp;&amp; git rebase</code>,像上文引用的那样，虽然这样保持了分支整洁，但是<br>在rebase的过程中容易出现问题，毕竟它改变了提交历史，风险很大，所以还是正常<code>git pull</code>为好。</p><h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h3><p>带有submodule子模块的项目进行全部更新，根据<code>git pull --help</code>的说法，在已经checkout<br>submodule的情况下，可以使用下面命令来一次性更新主项目和子模块：</p><blockquote><p>git pull –recurse-submodules</p></blockquote><h3 id="git回退单个文件到指定版本"><a href="#git回退单个文件到指定版本" class="headerlink" title="git回退单个文件到指定版本"></a>git回退单个文件到指定版本</h3><ol><li>cd到文件父目录</li><li>git log filename</li><li><p>git reset commitId filename (对于文件名不能使用hard模式,默认mixed模式)</p><blockquote><p>git reset –soft  只回退commit信息，即head指针，index和worktree不变，可以用来压缩commit<br>git reset –mixed 默认方式，回退commit和index,worktree不变，回退后需要checkout<br>git reset –hard  commit,index,worktree都回退</p></blockquote></li><li><p>git checkout filename</p></li><li>commit and push, done!</li></ol><h3 id="git修改默认的推送远程仓库"><a href="#git修改默认的推送远程仓库" class="headerlink" title="git修改默认的推送远程仓库"></a>git修改默认的推送远程仓库</h3><p>因为我的代码现在是放在2个地方，一个是github, 另一个是腾讯的coding(也是担心万一哪天github<br>把中国屏蔽了…), 所以代码一般有2个远程，推送时明显coding要快，github慢很多。所以我想将<br><code>git push</code>命令设置成默认推送到coding(本地和远程分支相同), 用<code>git push github</code>再推送到github<br>上。</p><p>我们第一次push时会执行命令<code>git push -u origin master</code>，这一步就是设置了默认的推送仓库(origin)<br>和分支(master).所以使用这个命令即可，之后可以使用<code>git branch -vv</code>查看分支跟踪情况，确定<br>是否设置成功。</p><p>不带参数的<code>git push</code>命令只会推送当前分支，这是git默认的simple方式。可以设置<br><code>git config --global push.default matching</code>, 这样它会推送所有有对应远程分支的本地分支，<br>这种方法有风险，因为多个分支一起push如果没准备好会出现错误，所以应当避免使用matching.<br>还可以设置为current, current和simple类似，但默认的simple推送时要求当前分支对远程仓库有<br>追踪关系，否则报错。而current则不要求，如果没有同名的远程分支，<code>git push</code>会自动新建同名<br>的远程分支。</p><p>个人觉得最稳妥的方式是保持默认的simple方式不变，当需要推送新分支时，使用git push全命令，<br>如<code>git push github newBranch:newBranch</code>, 其中本地分支和远程分支名字需要保持一致。推送时<br>到每个分支下分别执行<code>git push</code>命令。如果实在修改了很多分支，想要一次性推送，可以使用<br><code>git push -all</code>，-all选项不会检查分支追踪情况，意味着它也会将新建的本地分支推送到远程仓库。</p><p>注: 简单来说，push.default的选项中upstream是根据追踪关系来确定推送分支，current是根据分支<br>名称，simple则是结合了upstream和current, 最严格也最安全，要求同时有追踪关系和相同分支名称。</p><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>当git有多个分支时, 需要写一个特性或补丁同时提交到多个分支时,可以使用git cherry-pick.<br><strong>它默认只提取最后一个commit.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout A</span><br><span class="line">git commit -m &quot;Fixed the bug x&quot;</span><br><span class="line">git checkout B</span><br><span class="line">git cherry-pick A</span><br></pre></td></tr></table></figure></p><p> 2020-12-17 10:07:57 added:<br> when developing in local branch, it is common to cherry-pick to test or other branches<br> to make sure the deploy the latest code, so I wrote a script to auto-do this:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;Are you sure the all related branches is clean? (y/n):&quot;</span><br><span class="line">read XN</span><br><span class="line"></span><br><span class="line">if [ &quot;$XN&quot; != &quot;y&quot; ]; then</span><br><span class="line">  echo &quot;Abort!!&quot;</span><br><span class="line">  exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -z &quot;$1&quot; || -z &quot;$2&quot; ]]; then</span><br><span class="line">  echo &quot;Usage: cherryPick.sh [starHash]^..[endHash] [&lt;branch1&gt; &lt;branch2&gt; &lt;branch3&gt; ...]&quot;</span><br><span class="line">  echo </span><br><span class="line">  echo &quot;e.g. cherrypick.sh xxxxxx^..yyyyyy master test&quot;</span><br><span class="line">  exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for branch in &quot;$&#123;@:2&#125;&quot;</span><br><span class="line">do</span><br><span class="line">  #echo $branch</span><br><span class="line">  git checkout $branch</span><br><span class="line">  git cherry-pick -x -s $1</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p> in real usage, we need get the start commit hash code, remember the same commit content<br> has different hash code in different branches, so when we need to check the<br> cherry-pick-soure branch like local to get the right hash code, and we can use below code<br> the get the pretty one-line content of git log:<br> <code>git log --pretty=format:&quot;%h%x09%an%x09%ad%x09%s&quot;</code><br> %h is hashcode short, %x09 is tab: as spaces format, %an is author, %ad is author date,<br>as <code>git commit --amend</code> will change the author date(we use it to modify commit message),<br>so we can also use commit date as %ci, but normally it is the same, and for me, the<br>created author date is more important as developing sequence.<br>Furthermore, I need to cherry-pick one whole days’ commits to other branches, so we can<br>use this to find out all the commits after yesterday,<br>so today is 2020-12-17, I need to get all the commits today committed, command like:<br><code>git log --after=&quot;2020-12-17T00:00:00&quot; --pretty=format:&quot;%h%x09%an%x09%ci%x09%s&quot;</code></p><p>furthermore, we can use alias to make this quite convenient, in bash shell alias command:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias todaylog=&apos;git log --after=&quot;$(date &apos;+%Y-%m-%dT00:00:00&apos;)&quot; --pretty=format:&quot;%h%x09%an%x09%ci%x09%s&quot;&apos;</span><br></pre></td></tr></table></figure></p><p> 2020-12-25 09:54:06 added:<br>when working with several git branches at once, use the git cherry-pick to apply all changes<br>to different branches is convenient, but how can I push all modified branches to remote at<br>one time, the answer is quite simple, searching on internet and stackoverflow will get the<br>answer:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push REMOTE --all   // push all tracked branches</span><br><span class="line">git push REMOTE --tags  // push all tags</span><br></pre></td></tr></table></figure></p><p>simply, <code>--all</code> is enough. </p><p> 2021-03-25 09:45:04 added:<br>the above cherry-pick script is convenient, but after using it for some time, it is<br>troublesome to get the commit hash id by hand, after searching online, I found what I<br>wanted actually is synchronize the local two branches, and git pull equals git fetch &amp;&amp;<br>git merge, as there is no remote branch here, so git fetch will fail.<br>So I just need to use git merge or git rebase!!!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># synchronize local master commits to local dev branch</span><br><span class="line">git checkout local</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure></p><p> 2021-03-25 16:25:05 added:<br> after testing, I got what I wanted:</p><ol><li>git checkout local from master</li><li>change to local config, as ip and others, commit it</li><li>git checkout master</li><li>git merge or rebase local  to get the local changes</li><li>revert that commit, this generates a new commit to return to prod config</li><li>git checkout local, commit changes and merge it to master is ok now<br>by this way, we can not directly change master branch, if we do that, we can only use<br>the above cherrypick script to make that change to local branch.</li></ol><p>So make it safe, start local tomcat, and change code in local branch, after testing ok,<br>merge it to master branch, and push all.</p><p>So for frontend changes, we can use cherrypick script to avoid local tomcat starting,<br>for tomcat server changes, we can use the right way merge, we can change to master branch<br>to test the prod database. </p><p> 2021-03-26 13:42:47 added:<br> when using frontend and merge changes from master to local branch, after testing,<br> need to do below steps:</p><ol><li>make commit in master branch</li><li>git checkout local</li><li>git cherry pick from master</li><li>git checkout master</li><li>if we just git rebase local, we will have two same commits, so we need to reset hard<br>back to the commit just before the change commits</li><li>git rebase local</li></ol><p>so, simply put it, we make commit in master, move it to local, then go back to master to<br>clean that commit and use rebase to get that commit back, in this way, the master and<br>local branches synchronized.</p><p>ps: after testing, use git rebase local in master branch is ok, but it will conflict with<br>remote master branch, we can not push it normally, so use git merge local instead.</p><h2 id="Windows10-自带微软拼音输入法支持小鹤双拼输入法"><a href="#Windows10-自带微软拼音输入法支持小鹤双拼输入法" class="headerlink" title="Windows10 自带微软拼音输入法支持小鹤双拼输入法"></a>Windows10 自带微软拼音输入法支持小鹤双拼输入法</h2><p>本来还是用搜狗，但是虚拟机内无法联网登录，结果经常重启虚拟机后搜狗的设置全部都不见了，<br>非常麻烦，今天终于找到了让win10自带的拼音输入法支持小鹤的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. win + R，输入 regedit，打开注册表</span><br><span class="line">2. 找到  计算机\HKEY_CURRENT_USER\Software\Microsoft\InputMethod\Settings\CHS 项</span><br><span class="line">3. 新建一个名为 UserDefinedDoublePinyinScheme0 的字符串值，值为 小鹤双拼*2*^*iuvdjhcwfg^xmlnpbksqszxkrltvyovt</span><br><span class="line">4. 打开控制面板--微软拼音输入法设置，把 小鹤双拼 设置为双拼的默认选择即可。</span><br><span class="line">可以在区域中添加Enlish(United State),在高级键盘设置中设置英语为默认输入法，</span><br><span class="line">同时勾选为每个窗口使用不同输入法，默认切换输入发快捷键为windows+space键。</span><br></pre></td></tr></table></figure></p><h2 id="MacOS中vim添加中文输入法支持插件"><a href="#MacOS中vim添加中文输入法支持插件" class="headerlink" title="MacOS中vim添加中文输入法支持插件"></a>MacOS中vim添加中文输入法支持插件</h2><p>linux下的fcitx.vim插件对于输入中文非常有效果，尤其是对于写这样的长篇中文博客来说，<br>有时切换中文输入非常麻烦，但是fcitx.vim是linux下的，mac不支持，今天又在网上搜到<br>有牛人写了个工具，可以迁移到macOS系统中来。简记如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vundle</span><br><span class="line">Plugin &apos;CodeFalling/fcitx-vim-osx&apos;</span><br><span class="line"></span><br><span class="line">:PluginInstall</span><br><span class="line"></span><br><span class="line">brew tap codefalling/fcitx-remote-for-osx</span><br><span class="line">brew install codefalling/fcitx-remote-for-osx/fcitx-remote-for-osx --with-sogou-pinyin</span><br><span class="line">Set your shortcut for Select next source in input menu to Ctrl-Shift-z</span><br><span class="line">And set your English input method to US（美式英语）</span><br></pre></td></tr></table></figure></p><p>OK！<br> 2020-03-22 14:10:51添加:<br>使用该插件后打开vim文件中会出现乱码，暂时无法使用了….</p><h2 id="Karabiner针对某个app的快捷键设置"><a href="#Karabiner针对某个app的快捷键设置" class="headerlink" title="Karabiner针对某个app的快捷键设置"></a>Karabiner针对某个app的快捷键设置</h2><p>作为程序员快捷键必不可少，尤其是使用vim时，个人认为esc和capslock的位置必换不可。交换主要<br>还是通过各种改键程序来实现：</p><ol><li><p>windows我用key tweak + hotkey, 可以交换键和快捷启动某些程序，<br>如F12启动cmder，windows+c启动cmd窗口一样。</p></li><li><p>linux ubantu下有gnome-tweak-tool或Xmomap文件等。</p></li><li><p>macOS有利器karabiner，而且有配套的keyEvent-viewer可以查看按下键的名字等，非常好用，<br>这次就是用它来针对某个特定的app进行设置快捷键。<br>背景：因为经常要用pdf阅读器查看技术书籍，需要经常在鼠标和键盘之间切换非常麻烦，ubantu下<br>自带的document viewer支持vim的操作，还有zathura也支持，说到底就是一个连续翻页的基础上<br>使用j向下滚动，k向上滚动的功能，在网上搜索到可以使用karabiner针对特定的app来定义快捷键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.config/karabiner/assets/complex_modifications/pdf-viewer.json</span><br><span class="line">内容为（其中bundle_identifiers可以由keyEvent-viewer查看)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;keys&quot;,</span><br><span class="line">  &quot;rules&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;description&quot;: &quot;shortcuts for preview&quot;,</span><br><span class="line">      &quot;manipulators&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;conditions&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;bundle_identifiers&quot;: [</span><br><span class="line">                &quot;^com\\.apple\\.Preview$&quot;</span><br><span class="line">              ],</span><br><span class="line">              &quot;type&quot;: &quot;frontmost_application_if&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;from&quot;: &#123;</span><br><span class="line">              &quot;key_code&quot;: &quot;k&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;to&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">            &quot;key_code&quot;: &quot;up_arrow&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;type&quot;: &quot;basic&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;conditions&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;bundle_identifiers&quot;: [</span><br><span class="line">                &quot;^com\\.apple\\.Preview$&quot;</span><br><span class="line">              ],</span><br><span class="line">              &quot;type&quot;: &quot;frontmost_application_if&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;from&quot;: &#123;</span><br><span class="line">              &quot;key_code&quot;: &quot;j&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;to&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">            &quot;key_code&quot;: &quot;down_arrow&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;type&quot;: &quot;basic&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Got to karabiner preferences-&gt;complex Modifications-&gt;Add rule and press enable on it.</span><br></pre></td></tr></table></figure></li></ol><h2 id="谷歌浏览器访问本地文件CORS错误"><a href="#谷歌浏览器访问本地文件CORS错误" class="headerlink" title="谷歌浏览器访问本地文件CORS错误"></a>谷歌浏览器访问本地文件CORS错误</h2><p>这个问题是由于本人有个静态网站目录存储在本地，直接访问index.html文件报错CORS.网上搜索到<br>解决方案如下。</p><ol><li><p>先关闭所有浏览器实例，从命令行启动谷歌浏览器:<br><code>.\chrome.exe --allow-file-access-from-files</code></p></li><li><p>使用npm的http-server模块或python的SimpleHTTPServer模块,python3中该模块被整合进<br>http.server模块中，使用python3测试执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python --version   // 3.6.0</span><br><span class="line">cd 到想要访问的files folder下，我这个路径下有个index.html文件</span><br><span class="line">python -m SimpleHTTPServer  </span><br><span class="line">谷歌浏览器访问http://localhost:8000或http://localhost:8000/index.html可以正常访问</span><br></pre></td></tr></table></figure></li></ol><h2 id="kindle-pocket-calibre-pandoc"><a href="#kindle-pocket-calibre-pandoc" class="headerlink" title="kindle, pocket, calibre, pandoc"></a>kindle, pocket, calibre, pandoc</h2><p>昨天在网上看到QuQu的博客中有一个将自己的博客制作成电子书发到kindle上的效果，瞬间恢复了对<br>kindle的热情，这里简单记录下自己尝试的过程:</p><ol><li>使用pandoc将自己的博客markdown文件列表统一转换为一本epub电子书，这一步是使用haskell编写<br>的pandoc工具完成的，我写了一个脚本来获取博客中post文件夹下的所有md文件，统一拼接成一个字符串<br>作为pandoc命令的输入文件参数。</li><li>生成epub后，由于亚马逊个人文档最大50M,邮箱附件最大20/30M的限制，所以我是用calibre转换<br>为azw3格式后直接用usb传到kindle中的。(也试过亚马逊官方的kindlegen, 也能生成，不过calibre<br>还支持从pdf转换到azw3, 功能更强大，所以就放弃了kindlegen, 统一使用calibre吧)。</li></ol><p>将自己喜欢的网页保存下来制作成电子书。这个首先要说Pocket这个app, 有chrome插件，ios app,<br>PC 多个平台，和印象笔记差不多，不过印象笔记免费用户限制较多。</p><p>pocket的Chrome插件的帐号设置界面中可以导出文章列表的html, 自己写一个脚本将其中的超链接的<br>href值提取出来，导入到oneTab中，全部打开后再用EpubPress统一转换为epub格式。<br>这样很麻烦，但对于零散的文章可以先在pocket中查看，进一步筛选后再做成电子书。<br>注: 可以简单的使用grep的正则表达式来提取url,命令如下:<br><code>grep -Po &quot;(?&lt;=\&quot;)http(s)?://.*?(?=\&quot;)&quot; ril_export.html &gt; test.txt</code></p><p>或者放入pocket中时就使用EpubPress做成电子书，再用calibre将所有零散的epub整合成一个大的epub.<br>calibre需要在偏好设置中安装新插件EpubMerge合并插件(还可以安装EpubSplit拆分插件)。</p><p>2019-08-30 10:51:13添加:<br>通过oneTab插件导入url,再通过EpubPress插件来生成epub电子书操作明显很麻烦，关键在于Epubpress<br>的网页内容抓取。所以我到它的github上查看其源码，希望能找到抓取的逻辑。</p><p>这时又发现EpubPress同时提供了EpubPress.js可以调用，并且ReadMe.md中介绍了使用方法，<br>所以我们就可以自己写个js使用node直接运行来生成需要的epub,而不再需要使用chrome插件。</p><p>EpubPress.js的抓取逻辑是先用node-fetch包的fetch方法抓取对应网站的全部内容，再用fileSaver.js<br>包保存的网页文件。</p><ol><li><p>安装EpubPress.js<br><code>sudo npm install --save epub-press-js</code></p></li><li><p>写脚本调用EpubPress.js生成epub文件<br>这应该是写的第一个有用的node.js脚本了，node还是不错的，还可以调用shell命令。<br>node使用的是Chrome的V8引擎，FileSaver.js说它支持的chrome浏览器MaxBlog = 2GB, 如果理解的<br>没错的话，生成的epub最大也应该有2GB, EpubPress.js中没有看到其他限制，等以后pocket文章多了<br>以后看看是不是这个最大值。</p></li></ol><p>可以加入koa, koa-route的node.js调试框架，测试node-fetch包的fetch方法运行结果。<br>调试node.js命令为<code>node --inspect test.js</code>.开发工具中点击node图标可以打开node.js的调试窗口。</p><p>getEpub.js代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// put pocket&apos;s html in blog directory, no need to contain in this blog</span><br><span class="line">const data = fs.readFileSync(path.resolve(__dirname, &apos;../ril_export.html&apos;), &apos;utf-8&apos;);</span><br><span class="line"></span><br><span class="line">console.log(data);</span><br><span class="line">console.log(&apos;#####################################&apos;);</span><br><span class="line">console.log(&apos;pocketFile read done!&apos;)</span><br><span class="line">console.log(&apos;#####################################&apos;);</span><br><span class="line">// 删除不匹配的内容，用正向否定环视定位，.*来具体匹配字符</span><br><span class="line">const regexp = RegExp(&apos;(?&lt;=&quot;)http(s)?://.*?(?=&quot;)&apos;, &apos;g&apos;);</span><br><span class="line">let urlArr = [];</span><br><span class="line">while((matches = regexp.exec(data)) != null)&#123;</span><br><span class="line">  console.log(matches[0]);</span><br><span class="line">  urlArr.push(matches[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;#####################################&apos;);</span><br><span class="line">console.log(&apos;get url done!&apos;)</span><br><span class="line">console.log(&apos;#####################################&apos;);</span><br><span class="line"></span><br><span class="line">const EpubPress = require(&apos;epub-press-js&apos;);</span><br><span class="line">const ebook = new EpubPress(&#123;</span><br><span class="line">    title: &apos;Tao Pocket WebPages&apos; + new Date().toLocaleDateString(),</span><br><span class="line">    description: &apos;Personal favourite webpages&apos;,</span><br><span class="line">    urls: urlArr </span><br><span class="line">&#125;);</span><br><span class="line">ebook.publish().then(() =&gt; &#123;</span><br><span class="line">  // it will download to the current directory</span><br><span class="line">    ebook.download();  // Default epub or ebook.email(&apos;epubpress@gmail.com&apos;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">   console.log(&apos;Success!&apos;);</span><br><span class="line">&#125;).catch((error) =&gt; &#123;</span><br><span class="line">    console.log(`Error: $&#123;error&#125;`);</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;#####################################&apos;);</span><br><span class="line">  console.log(&apos;epub done!&apos;);</span><br><span class="line">  console.log(&apos;#####################################&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>直接运行<code>node getEpub.js</code>命令，等待脚本执行结束后在当前目录可以看到生成的epub文件。</p><h2 id="Linux上安装jdk8-maven"><a href="#Linux上安装jdk8-maven" class="headerlink" title="Linux上安装jdk8, maven"></a>Linux上安装jdk8, maven</h2><p>很神奇的是这么久在玩linux系统，但一直使用windows下的idea开发，主要还是因为认为快捷键是和<br>windows系统绑定的，最近想通了，完全可以将快捷键直接移植到Linux中。</p><ol><li>IntelliJ 安装，这里略过。</li><li><p>安装jdk8.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br><span class="line">sudo vi /etc/environment  # 添加以下环境变量</span><br><span class="line">  JAVA_HOME=&quot;/usr/lib/jvm/java-8-openjdk-amd64&quot;</span><br></pre></td></tr></table></figure></li><li><p>安装maven 3.6.1 这里我直接是使用.zip格式的安装包，直接解压即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/environment  # 添加以下内容</span><br><span class="line">  path变量最后添加 :/home/tao/wtt/apache-maven-3.6.1/bin </span><br><span class="line">  M2_HOME=&quot;/home/tao/wtt/apache-maven-3.6.1&quot;</span><br><span class="line"></span><br><span class="line"># update mvn commnad</span><br><span class="line">sudo update-alternatives --install &quot;/usr/bin/mvn&quot; &quot;mvn&quot; &quot;/opt/apache-maven-3.6.0/bin/mvn&quot; 0</span><br><span class="line">sudo update-alternatives --set mvn /opt/apache-maven-3.6.0/bin/mvn</span><br><span class="line"></span><br><span class="line"># mvn commnad autoComplete</span><br><span class="line">sudo wget https://raw.github.com/dimaj/maven-bash-completion/master/bash_completion.bash --output-document /etc/bash_completion.d/mvn</span><br><span class="line"></span><br><span class="line"># logout and login</span><br><span class="line">mvn --version</span><br><span class="line"></span><br><span class="line"># 修改settings.xml文件 添加阿里云镜像仓库</span><br><span class="line">&lt;mirrors&gt;</span><br><span class="line">  &lt;mirror&gt;  </span><br><span class="line">       &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">       &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">       &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          </span><br><span class="line">   &lt;/mirror&gt;</span><br><span class="line"> &lt;/mirrors&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="关于pip的2个问题"><a href="#关于pip的2个问题" class="headerlink" title="关于pip的2个问题"></a>关于pip的2个问题</h2><ol><li>pip install报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File &quot;/usr/bin/pip&quot;,line 9, in &lt;module&gt;</span><br><span class="line">  from pip import main</span><br><span class="line">Import error: cannot import name main</span><br></pre></td></tr></table></figure></li></ol><p>解决: 这是pip 10和pip 8冲突导致，卸载pip 10即可，ubantu上应尽量使用apt.<br><code>python -m pip uninstall pip</code></p><ol start="2"><li>pip uninstall 不会删除相关的依赖包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pip-autoremove </span><br><span class="line"># 如删除batmon的相关依赖</span><br><span class="line">/home/tao/.local/lib/python2.7/site-packages/pip_autoremove.py batmon -y</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用shell脚本来重启sprintboot应用"><a href="#使用shell脚本来重启sprintboot应用" class="headerlink" title="使用shell脚本来重启sprintboot应用"></a>使用shell脚本来重启sprintboot应用</h2><p>通过查资料和以前的一些印象终于搞出个能用的……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export SPRING_PROFILE=prod</span><br><span class="line">export APP_NAME=pra-plat</span><br><span class="line">export VERSION=1.0.0-SNAPSHOT</span><br><span class="line">export SERVER_PORT=8080</span><br><span class="line"></span><br><span class="line">## setting log home</span><br><span class="line">export JAR_HOME=/home/ap/cloudapp</span><br><span class="line">export LOG_HOME=/home/ap/cloudapp/logs</span><br><span class="line">export LOG_NAME=$&#123;APP_NAME&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># =两边不能有空格,命令输出结果用$()来赋给变量,注意awk的写法</span><br><span class="line">pid=$(ps -ef | grep java | grep $&#123;APP_NAME&#125;| awk &apos;&#123;print $2&#125;&apos;)</span><br><span class="line"># 注意如何判断变量为空</span><br><span class="line">if [ $&#123;pid&#125; ]</span><br><span class="line">then # then需要另起一行，与if在同一行时需要在then前加分号</span><br><span class="line">    echo &quot;stop $&#123;APP_NAME&#125;_$&#123;SERVER_PORT&#125; service&quot;</span><br><span class="line">    echo &quot;kill process $&#123;pid&#125;&quot;</span><br><span class="line">    kill -9 $&#123;pid&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;start $&#123;APP_NAME&#125;_$&#123;SERVER_PORT&#125; service&quot;</span><br><span class="line">JAVA_OPTS=&quot;-Dspring.profiles.active=$&#123;SPRING_PROFILE&#125;&quot;</span><br><span class="line"># 直接jar包报cannot access jar file错误</span><br><span class="line">nohup java -jar $&#123;JAVA_OPTS&#125; $&#123;JAR_HOME&#125;/$&#123;APP_NAME&#125;-$&#123;VERSION&#125;.jar &gt;$&#123;LOG_HOME&#125;/$&#123;LOG_NAME&#125;.out 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">echo &quot;tail -f $&#123;LOG_HOME&#125;/$&#123;LOG_NAME&#125;.out&quot;</span><br></pre></td></tr></table></figure></p><h2 id="Mac-parallel安装centos虚拟机"><a href="#Mac-parallel安装centos虚拟机" class="headerlink" title="Mac parallel安装centos虚拟机"></a>Mac parallel安装centos虚拟机</h2><ol><li><p>下载centos最小安装镜像,我选择的版本是CentOS-7-x86_64-Minimal-1810.iso<br>官网地址: <a href="https://www.centos.org/download/" target="_blank" rel="noopener">centos下载</a></p></li><li><p>一步步安装，登录后发现命令界面太小，网上搜索后没有解决办法，突然想到可以用远程ssh<br>登录，自己装的iterm2已经非常美观实用了。<br>已找到方法：<a href="https://superuser.com/questions/816528/with-centos-7-as-a-virtualbox-guest-on-a-mac-host-how-can-i-change-the-screen-r" target="_blank" rel="noopener">修改centos分辨率</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su</span><br><span class="line">$ vi /etc/default/grub </span><br><span class="line">add vga=792 to the end of GRUB_CMDLINE_LINUX</span><br><span class="line">$ grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">$ reboot</span><br></pre></td></tr></table></figure></li><li><p>centos开通root远程ssh访问权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -V    # 查看ssh 版本</span><br><span class="line">$ vi /etc/ssh/sshd_config </span><br><span class="line">将配置中的 #PermitRootLogin yes 这一行前面的＃号去掉</span><br><span class="line">$ service sshd restart  # 重启ssh服务</span><br><span class="line">$ ip addr   # 查看ip地址，eth0中的inet值即是</span><br><span class="line"></span><br><span class="line">本地mac iterm2 登录ssh</span><br><span class="line">$ ssh -l tao 10.211.55.9</span><br><span class="line">输入密码链接成功！</span><br></pre></td></tr></table></figure></li><li><p>centos关机命令<br><code>sudo shutdown 0</code></p></li><li><p>iterm2配置自动登录ssh<br>网上说的是配置profile,但启动还需要定义快捷键，可以直接定义别名</p></li><li><p>用item2登录后发现centos界面颜色与真实的一致，所以还是需要修改centos上自带的颜色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cp /etc/DIR_COLORS ~/.dir_colors</span><br><span class="line">vim ~/.dir_colors</span><br><span class="line">第59行：DIR 01;34（01：粗体，34：蓝色）</span><br><span class="line">修改为：DIR 01;33（01：粗体，33：黄色）</span><br></pre></td></tr></table></figure></li></ol><h2 id="老mac安装Ubantu"><a href="#老mac安装Ubantu" class="headerlink" title="老mac安装Ubantu"></a>老mac安装Ubantu</h2><p>昨天在新mac上用parallel成功安装了centos虚拟机，想到我那个小的mid-2011的macbook air,<br>突然萌生了要改装linux系统的想法，马上google搜索一番，发现果然有人在网上说可以这样干，<br>因为老mac带不动最新的macOs系统，却可以带动最新的linux系统，但linux系统版本众多，选择<br>哪一个版本也是问题，google上有人测评过，说还是ubantu靠谱,所以就决定装它了!<br>具体安装过程参考这篇文章：<br><a href="https://www.imore.com/how-try-out-linux-aging-mac" target="_blank" rel="noopener">try out linux on aging mac</a></p><p>具体安装过程就按这篇文章进行即可，找个u盘用软件Ether做成系统光盘，然后在老mac上启动时<br>按option键选择install ubantu即可。<br>安装过程中可以先不连wifi，语言可以选英文，选中文的话会出现中文目录。</p><p>ubantu下载软件比较慢，可以换成阿里云的源，不同版本的ubantu源也不一样，<br>我装的是最新的LTS版18.04。</p><ol><li>备份原来的源文件<br>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</li><li>安装vim<br>sudo apt-get install vim</li><li>编辑源文件<br>sudo vim /etc/apt/sources.list</li><li>可以全部删除原来的，新增以下内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>更新软件列表<br>sudo apt-get update</li><li><p>更新软件包<br>sudo apt-get upgrade</p></li><li><p>其中系统的复制粘贴命令同windows，ctrl+c,ctrl+v。终端(ctrl + option + t)中的复制粘贴<br>可以从preference中看出，复制ctrl+shift+c,粘贴ctrl+shift+v.</p></li><li><p>安装蓝灯，github上有ubantu版</p></li><li><p>安装google浏览器。</p><ol><li>在ubantu中访问<a href="https://www.google.com/chrome/" target="_blank" rel="noopener">google官网</a>,<br>点击下载会自动出现linux版，下载到Downloads下面。</li><li><p>终端中执行：</p><blockquote><p>dpkg -i google-chrome-stable_current_amd64.deb</p></blockquote></li><li><p>网上说可能报错，需要按提示的命令执行apt-get -f install,我这边没有报错，直接按<br>command键输入google，愉快的打开并登陆了！</p></li></ol></li><li><p>使用vim经常要用到esc键，所以我习惯将capslock与esc键交换位置<br>tweak-tool的工具。</p><blockquote><p>sudo apt-get install gnome-tweak-tool -y &amp;&amp; gnome-tweak-tool</p></blockquote><p>装好后有一个tweaks应用，在keyboard&amp;Mouse&gt;additional layout&gt;capslock behavior&gt;<br>swap esc and capslock</p></li><li><p>完全卸载ubantu里的软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apt-get purge / apt-get --purge remove </span><br><span class="line">删除已安装包（不保留配置文件)。如软件包a，依赖软件包b，则执行该命令会删除a，</span><br><span class="line">而且不保留配置文件</span><br><span class="line"></span><br><span class="line">apt-get autoremove </span><br><span class="line">删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</span><br><span class="line"></span><br><span class="line">apt-get remove </span><br><span class="line">删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</span><br><span class="line"></span><br><span class="line">apt-get autoclean </span><br><span class="line">APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，</span><br><span class="line">apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb。</span><br><span class="line"></span><br><span class="line">apt-get clean </span><br><span class="line">使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 </span><br><span class="line">rm /var/cache/apt/archives/*.deb。</span><br><span class="line"></span><br><span class="line">实际使用：</span><br><span class="line"># 删除软件及其配置文件</span><br><span class="line">apt-get --purge remove &lt;package&gt;</span><br><span class="line"># 删除没用的依赖包</span><br><span class="line">apt-get autoremove &lt;package&gt;</span><br></pre></td></tr></table></figure></li><li><p>gnome用上面的gnome-tweak-tool软件可以成功，但后面又看到阮一峰推荐的fish+Xfce+<br>xmonad+vim的工作套件，尤其是xmonad窗口管理工具简直是分屏利器，于是把我的老mac也整<br>这样一套。</p><ol><li><p>ubantu上安装xfce桌面，登录时可以选择桌面系统，ubantu(gnome)或xfce(更轻更快)</p><blockquote><p>sudo apt install xfce4  #xfce最新的为2015年的4.2版本</p></blockquote></li><li><p>交换xfce中的esc和capslock键，新建文件~/.Xmodmap,其中内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear Lock</span><br><span class="line">keysym Caps_Lock = Escape</span><br><span class="line">keysym Escape = Caps_Lock</span><br><span class="line">add Lock = Caps_Lock</span><br></pre></td></tr></table></figure></li><li><p>重启后修改也生效！蓝灯和google浏览器也能访问之前安装的程序。<br>注：xfce下之前测了可以，但在ubantu默认的gnome3下该交换重启后又不行了，gnome3下重启后<br>仍生效的是执行下面这个命令，使用gnome3默认安装的dconf工具：</p><blockquote><p>dconf write “/org/gnome/desktop/input-sources/xkb-options” “[‘caps:swapescape’]”</p></blockquote></li></ol></li></ol><p>2019-09-05 14:41:45 添加:<br>xfce中一直使用上面的xmodmap配置文件来交换esc和capslock键，但最近总失灵，<br>需要重新执行xmodmap文件，并且开启新的窗口报错。<br>在网上又找到个方案，目前看可以使用，没有报错，步骤记录如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 删除上面的.XmodMap文件，不然无效</span><br><span class="line">2. vi /usr/share/X11/xkb/rules/base.lst</span><br><span class="line">3. 搜索esc, 找到交换capslock和esc的配置项`caps:swapescape`.</span><br><span class="line">4. sudo vi /etc/default/keyboard </span><br><span class="line">5. 修改为XKBOPTIONS=&quot;caps:swapescape&quot;</span><br><span class="line">6. sudo dpkg-reconfigure keyboard-configuration</span><br><span class="line">7. 我选择了general 104 key and us layout, 最后确定保留配置</span><br><span class="line">8. 重启电脑生效</span><br></pre></td></tr></table></figure></p><p> 2019-10-23 16:32:17添加:<br>最近写racket要写很多括号，装了几个插件，并将<code>[</code>和<code>(</code>在vim中进行了交换(具体配置见以上vimrc配置),<br>发现如果软件层面上搞不定快捷键，可以买那些人体工学键盘(通常比较贵)来从硬件层面解决，如果<br>能从软件层面解决就更好，因为这样不用局限在某一块或某一类键盘上，不过人的”局限性”太大了，如<br>有再多钱只能睡一张床，只能开一辆车一样，我们也通常只能敲1,2块键盘，软件上的设置也是一种<br>局限，只不过它的移动性要比硬件更强，更新换代也更方便。</p><p>Anyway, 除了上面vim中的配置，简单的交换capslock和esc个人觉的还不够，可以将capslock再加上<br>ctrl的功能—-右边的ctrl键正式宣布废弃使用! xkb对于x窗口是个神器！还可以切换qwerty成dvorak,<br>colemak等其他布局。以后有时间可以玩玩。同理对于单独按下modifier修饰键映射成其他键的功能是<br>xcape.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 将上面修改的/etc/defaul/keyboard中的XKBOPTION改为&apos;caps:ctrl_modifier&apos;。</span><br><span class="line">2. sudo apt install xcape</span><br><span class="line">3. 新建~/.xprofile文件，加入</span><br><span class="line">/usr/bin/xcape -e &apos;Caps_Lock=Escape&apos;</span><br><span class="line">4. 重启(前面改了xkb设置，必须重启)</span><br></pre></td></tr></table></figure></p><p> 2019-10-24 10:01:43 添加:<br>上面的配置是可以的，但ctrl键其实用的较少，因为我使用xmonad, modMask键是super键，所以通常<br>来说super要比ctrl用的多，所以我提出了以下的配置目标:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. capslock键单独按是esc, 长按是super键。(大写常开功能就不要了).</span><br><span class="line">2. left shift 是切换fcitx中英文输入法 (esc, left_control, left_super 都不动) </span><br><span class="line">3. right shift单独按是左括号(xcape实现) </span><br><span class="line">4. space单独按时是空格键不变，长按时是ctrl键。(xcape实现)</span><br></pre></td></tr></table></figure></p><p>注: 可以用xev命令查看对应键的keycode.<br>实现步骤:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1. 修改capslock:</span><br><span class="line">   /etc/defaul/keyboard改为:(主要是XKBOPTIONS项，也可以使用setxkbmap命令放在.bashrc中实现)</span><br><span class="line">     BACKSPACE=&quot;guess&quot;</span><br><span class="line">     XKBMODEL=&quot;pc104&quot;</span><br><span class="line">     XKBLAYOUT=&quot;us&quot;</span><br><span class="line">     XKBVARIANT=&quot;&quot;</span><br><span class="line">     XKBOPTIONS=&quot;caps:super&quot;</span><br><span class="line">  通过xev发现它映射为左边的super键，因为~/.xprofile发现重启后没有生效，所以放到.bashrc中,</span><br><span class="line">  我是.bash_aliases:</span><br><span class="line">     # Run xcape once.</span><br><span class="line">     if [ -z $XCAPE ] ; then</span><br><span class="line">     export XCAPE=1</span><br><span class="line">     /usr/bin/xcape -e &apos;Super_L=Escape&apos; </span><br><span class="line">     fi</span><br><span class="line">  重启电脑后即可发现caslock修改成功！控制xmonad和作为esc很方便。</span><br><span class="line">  注: 上面的方法有问题，打开多个终端窗口时有多个括号，具体原因见本博客LinuxNote.</span><br><span class="line">  可以放在.bash_profile中，启动时执行一次`. ~/.bash_profile`, 还未找到启动执行命令的方法。</span><br><span class="line">  或者不用变量，使用ps -ef 查找进程，如果有，就不执行，代码还是放在.bashrc中——这只是暂时</span><br><span class="line">  的办法，按理说不应当每次打开终端都要进行判断。</span><br><span class="line"></span><br><span class="line">  再注: 经过查找资料和多次尝试，终于找到了解决方法！</span><br><span class="line">  1. 自定义的环境变量若想使用全部用户，放在/etc/profile.d/下的新建脚本中，使用export导出</span><br><span class="line">  xmonad也能看到。</span><br><span class="line">  2. 环境变量和命令针对X11独有的配置可以放到.xsessionrc下。xcape命令直接放入即可，不需要</span><br><span class="line">  上面的环境变量判断，因为.xsessionrc只会在启动时执行一次！</span><br><span class="line"></span><br><span class="line">  经过测试发现，ubuntu wayland登录时不会执行.xsessionrc文件。gnome有自己的启动项设置</span><br><span class="line">  gnome-session-properties.</span><br><span class="line"></span><br><span class="line">2. fcitx配置同以上记录，不要修改，中英文切换对于写博客来说太常用了....</span><br><span class="line">3. 这一步在mac系统上使用karabiner很方便就实现了。今天发现xcape提供了类似的功能，还是非常</span><br><span class="line">强大的，windows系统可以使用autoHotKey.</span><br><span class="line">    将以上的xcape命令改为如下即可:</span><br><span class="line">      /usr/bin/xcape -e &apos;Super_L=Escape;Shift_R=parenleft&apos; </span><br><span class="line">  注: 经测试，启动后直接按capslock并没有生效，按下右shift有效，再回来按capslock就生效了，</span><br><span class="line">  估计和xcape执行顺序有关。</span><br><span class="line"></span><br><span class="line">4. `man xcape`上的例子，之前也有说用回车键的，但还是远了点，空格键不错.</span><br><span class="line">试着像上面一样将命令直接放到.xsessionrc中，但是没有生效，网上查找资料猜测是由于.xsessionrc</span><br><span class="line">很早就被加载执行，其中的xmodmap命令无效，所以我将相关代码全部提取出来单独作为一个脚本，</span><br><span class="line">重启后手动执行，所有改的键都生效了！只是这样同前面的问题一样，不能执行多次该脚本，否则</span><br><span class="line">会出现多个括号。</span><br><span class="line">注: 在.xsessonrc中执行该脚本. /home/tao/key.sh &amp;, key.sh中先sleep 20(睡20秒),重启改键生效！</span><br><span class="line">不用手动执行了！</span><br></pre></td></tr></table></figure></p><p>注: 由于右边的shift键与回车键较远，所以暂时先将fcitx的中英输入法切换为右shift, 左括号键<br>改为左shift, 正好练练右shift键，要知道写博客时中英输入法是切换的非常多的。</p><p>由于fcitx(还有中英文自动切换输入的vim插件)是使用左shift键进行切换的，当我上面的options中<br>加入<code>, shift:both_capslock_cancel</code>(将左右shift键同时按变为capslock功能)时，fcitx无法正常<br>工作。所以只好暂时放弃大写功能，可以使用vim的~键统一转或gU。<br>注: fcitx之前也折腾了很久……, 这里记录下双拼的按键配置，防止再出问题…:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">global config</span><br><span class="line">Trigger input method: Lshift empty (操作时可以用escape变为empty)</span><br><span class="line">extra key for trigger input method: L_shift</span><br><span class="line">enable hotkey to scroll.... non-check</span><br><span class="line">scroll between input method: ctrl+shift</span><br><span class="line">prev-page: - up</span><br><span class="line">next-page: = down</span><br></pre></td></tr></table></figure></p><p> 2019-10-28 11:50:09 添加:<br>ubuntu用以上工具xcape，xkb改键后，其中的win10虚拟机中没有生效，有奇怪的问题，如右边的shift<br>键变为了数字9，anyway, 我只需要<code>caslock-&gt;escape</code>, <code>space-&gt;ctrl modifier</code>这2大核心功能就行，<br>括号除了lisp其他时候也用的少(这里我倒是可以双shift), 下面记录下使用AutoKey实现这2个功能<br>的脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Capslock::Esc</span><br><span class="line">*Space::</span><br><span class="line">&#123;</span><br><span class="line">  SendInput, &#123;Ctrl Down&#125;</span><br><span class="line">  Key =</span><br><span class="line">      Input, Key, V L1</span><br><span class="line">      Return</span><br><span class="line">&#125;</span><br><span class="line">*Space Up::</span><br><span class="line">&#123;</span><br><span class="line">  SendInput, &#123;Ctrl Up&#125;</span><br><span class="line">  Input,,T.01</span><br><span class="line">      If !Key</span><br><span class="line">      &#123;</span><br><span class="line">          If (A_TimeSincePriorHotkey &lt; 300)</span><br><span class="line">          &#123;</span><br><span class="line">              SendInput, %A_Space%</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  Return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 2020-06-02 14:06:19 add:<br><strong>Now it’s the end of this whole keyboard config</strong><br>due to pursuit of emacs meta key, I succeed to own ctrl, super, meta, alt keys work<br>perfectly together!</p><ol><li>capslock -&gt; escape alone and left control when pressed</li><li>left control acts like left meta, now in terminal ctrl + e/v can jump to temp editor,<br>and emacs use!</li><li>left alt is still alt, can control st rolll up/down and size up/down perfectly and other<br>usages, like listary in windows.</li></ol><p>all of the above functions only need one script, key.sh(work in X11)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># to be executed from .xsessionrc</span><br><span class="line"></span><br><span class="line"># make xkb take effect first, or .xsessionrc executing too early</span><br><span class="line">sleep 3</span><br><span class="line"></span><br><span class="line">setxkbmap -option caps:none -option caps:ctrl_modifier -option ctrl:lctrl_meta</span><br><span class="line"></span><br><span class="line">killall xcape 2&gt;/dev/null</span><br><span class="line">xcape -e &quot;Shift_L=parenleft;Caps_Lock=Escape&quot; </span><br><span class="line"></span><br><span class="line"># make h,j,k,j move faster</span><br><span class="line">xset r rate 300 50</span><br></pre></td></tr></table></figure></p><p>workman layout switch shortcuts:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// fish shell </span><br><span class="line">alias workman &quot;bash -c &apos;setxkbmap -v workman-p &amp;&amp; xset r 66&apos;&quot;</span><br><span class="line">alias us &quot;bash -c &apos;setxkbmap us; xset -r 66&apos;&quot;</span><br></pre></td></tr></table></figure></p><p>by the above config, we can toggle between different layouts, but how can we input<br>chinese?<br>in fcitx, we can change the english input layout to workman, solved!<br>As we can notice, xiaohe shuangping symbols is bind to specific keys, so we can actually<br>use workman layout to input xiaohe shuangping chinese!</p><p>wonder what need to be configed in emacs to use evil to input chinese.</p><p>linux下的pdf编辑工具，使用libreOffice Draw进行编辑，可以下载pdfshuffler来进行删除和<br>合并pdf操作。经测试重组的pdf仍然会有些小问题，还是可以看，有问题再对照原版吧。</p><pre><code>4. 安装fish shell.&gt; sudo apt-get install fish&gt; fish  #启动shell,不建议设置为默认shell5. 安装xmonad&gt; sudo apt-get install xmonad&gt; sudo apt-get install xmobar dmenu  #小工具安装完之后只logout发现没有xmonad桌面，重启后才出来那个全黑的界面，果断alt+shift+enter,当当！终端出来了，vim看看capslock和esc也已经交换了，证明了它确实只是一个窗口管理软件，至此，fish+xfce+xmonad+vim的一套已经搞定，具体使用和问题后面再写，今天到点睡觉了！-- 2019-03-31 23:00:21 xmonad下蓝灯无效果，而且中文输入法也出不来，只能暂时放弃，等以后有需求和时间再来折腾一下。</code></pre><ol start="13"><li>安装fcitx来使用小鹤双拼，以及vim中输入中文输入的插件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install fcitx</span><br><span class="line">sudo apt install fcitx-pinyin</span><br><span class="line">fcitx</span><br><span class="line">在桌面图标上选择config current input method</span><br><span class="line">为配合插件使用，第一位选择keyboard-English,第一个加上Shuangpin,</span><br><span class="line">这里加上以后默认的不是小鹤双拼，需要修改默认双拼方案</span><br><span class="line">cd ~/.config/fcitx/conf</span><br><span class="line">vi fcitx-pinyin.config</span><br><span class="line">设置为DefaultShuangpinSchema=XiaoHe</span><br></pre></td></tr></table></figure></li></ol><p>另: fcitx输入中文变繁体，按ctrl + shift + f变回简体输出。</p><ol start="14"><li><p>在ubantu系统启动时执行某些命令，如<code>sudo tlp start</code>软件减少散热的，还有命令别名<br>设置等，之前放到.bash_profile中不行，网上搜索到可以放在.bashrc中，查看.bashrc文件，发现<br>它有检查.bash_aliases文件，于是新建该文件，将命令放入其中即可。</p></li><li><p>shell基本使用</p><ol><li>不建议设置为默认shell,在.bashrc或.bash_aliases中写入<code>exec fish</code>来实现启动终端时<br>执行fish。</li></ol></li></ol><hr><pre><code>  2019-10-25 14:34:17 添加: 由于.bashrc会在执行bash命令中自动执行(包括执行命令&apos;bash&apos;和打开新终端实例), 所以达不到bash和shell自由切换的效果，这里找到了一种方法可以切换。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在terminator的profile-&gt;commnad中选中run a custom command instead of my shell, 写入fish,</span><br><span class="line">后面的when command exits, 选择exit the terminal.</span><br></pre></td></tr></table></figure><h2 id="这样，打开新终端实例时，自动进入fish-输入命令bash即可切换到bash-非常方便！"><a href="#这样，打开新终端实例时，自动进入fish-输入命令bash即可切换到bash-非常方便！" class="headerlink" title="这样，打开新终端实例时，自动进入fish, 输入命令bash即可切换到bash, 非常方便！"></a>这样，打开新终端实例时，自动进入fish, 输入命令<code>bash</code>即可切换到bash, 非常方便！</h2><pre><code>2. 执行命令`fish_config`进入网页配置界面，默认8000端口打开的本地网页，可以设置颜色主题和提示符prompt等。3. 自定义别名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alias post &apos;cd /home/tao/wtt/blog/source/_posts&apos;</span><br><span class="line">funcsave post     #可以在.config/fish/config.fish/functions下找到生成的fish文件</span><br><span class="line">alias pull &apos;git pull; and echo &quot;done&quot;&apos;</span><br><span class="line">funcsave pull</span><br><span class="line">alias push &apos;git add . ;and git commit -m $argv[1];and git push origin source; and echo &quot;done&quot;&apos;</span><br><span class="line">funcsave push</span><br><span class="line">alias pub &apos;git push github source;and echo &quot;done&quot;&apos;</span><br><span class="line">funcsave pub</span><br></pre></td></tr></table></figure></code></pre><p>  2019-08-16 15:41:06 添加:<br>Linux下使用sdcv作为终端查单词非常方便，直接使用sudo apt install sdcv即可安装，其中词典<br>需要自己下载，google一个星际译王的网站，里面有大量词典。其中有些字典在终端下排版格式不<br>好看，无法阅读，只能放弃。<br>目前本人使用的字典有(排序分先后):<br>Collins Thesaurus (En-En)<br>Concise Oxford English Dictionary (En-En)<br>Oxford Advanced Learner’s Dictionary 8th Ed.<br>Cambridge Advanced Learners Dictionary 3th Ed. (En-En)</p><p>通过man sdcv查看相关命令配置等。fish的别名使用上面的alias命令无法生效，报错找不到文件，直接<br>写function然后保存反倒是成功了，说明了function的适用性更强一点。<br> 2020-09-29 11:22:05 add:<br>function fw<br>        command sdcv $argv[1] | less<br>end</p><p> 2019-08-21 09:38:15 添加:<br>在写博客的过程中如果要使用命令行查单词，需要先退出vim编辑器，比较麻烦，可以使用linux<br>命令ctrl+z将当前任务暂时挂起并停止运行，查询完单词后使用fg命令将挂起命令恢复到前台。</p><p> 2019-10-26 07:32:15 添加:<br>去除fish shell欢迎语: <code>set fish_greeting</code>.</p><ol start="16"><li><p>vim中输入中文的插件，实现插入模式中自动切换为中文，leave insertMode时切换为英文，<br>按教程安装vundle,plugin有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plugin &apos;scrooloose/nerdtree&apos;</span><br><span class="line">Plugin &apos;lilydjwg/fcitx.vim&apos;</span><br></pre></td></tr></table></figure><p>fcitx.vim针对的是fcitx下的中文输入，其脚本中也是切换键盘输入，所以前面设置fcitx时需要<br>将第一位设置为英文，第二位设置为双拼。其插件脚本为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&quot;##### auto fcitx  ###########</span><br><span class="line">let g:input_toggle = 1</span><br><span class="line">function! Fcitx2en()</span><br><span class="line">   let s:input_status = system(&quot;fcitx-remote&quot;)</span><br><span class="line">   if s:input_status == 2</span><br><span class="line">      let g:input_toggle = 1</span><br><span class="line">      let l:a = system(&quot;fcitx-remote -c&quot;)</span><br><span class="line">   endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function! Fcitx2zh()</span><br><span class="line">   let s:input_status = system(&quot;fcitx-remote&quot;)</span><br><span class="line">   if s:input_status != 2 &amp;&amp; g:input_toggle == 1</span><br><span class="line">      let l:a = system(&quot;fcitx-remote -o&quot;)</span><br><span class="line">      let g:input_toggle = 0</span><br><span class="line">   endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">set ttimeoutlen=150</span><br><span class="line">&quot;退出插入模式</span><br><span class="line">autocmd InsertLeave * call Fcitx2en()</span><br><span class="line">&quot;进入插入模式</span><br><span class="line">autocmd InsertEnter * call Fcitx2zh()</span><br><span class="line">&quot;##### auto fcitx end ######</span><br></pre></td></tr></table></figure></li></ol><h2 id="ubantu下vim的粘贴复制问题"><a href="#ubantu下vim的粘贴复制问题" class="headerlink" title="ubantu下vim的粘贴复制问题"></a>ubantu下vim的粘贴复制问题</h2><p>昨天使用ubantu默认的gnome-teminal时，发现多个tab间无法进行复制粘贴操作，经网上搜索发现<br>以前gnome-terminal确实有这个bug,但是后来已经修复了，回到家用自己电脑下了一个terminator<br>来替代gnome-terminal，发现还是有这个问题。本来已经放弃了，但是今天无意中搜索到原来是vim的<br>问题，原生的vim不能与系统剪切板进行交互，需要下载vim-gnome！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt --purge remove vim</span><br><span class="line">sudo apt install vim-gnome</span><br></pre></td></tr></table></figure></p><p>OK!将原来的.vimrc中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set clipboard+=unnamed</span><br><span class="line">noremap &lt;Leader&gt;y &quot;+y</span><br><span class="line">noremap &lt;Leader&gt;v &quot;+p</span><br><span class="line">noremap &lt;Leader&gt;V &quot;+P</span><br></pre></td></tr></table></figure></p><h2 id="ubantu下vmware虚拟机网络设置问题"><a href="#ubantu下vmware虚拟机网络设置问题" class="headerlink" title="ubantu下vmware虚拟机网络设置问题"></a>ubantu下vmware虚拟机网络设置问题</h2><p>终于这个困扰本人许久的问题终于正式解决了！<br>首先看一下引发解决的关键点：</p><ol><li>vmware workstation的editor-&gt;virtual network editor</li><li>bridge,nat,host等概念</li><li>有限网络的默认网关屏蔽</li></ol><p>首先介绍一下操作背景，银行通过有线网线来链接内网，平时查资料需要通过个人热点来链接外网，<br>同时因本人喜欢终端命令行操作及vim编辑等功能，打算放弃windows操作系统，但银行内部需要<br>windows来进行工作，所以是重装了ThinkPad T540P笔记本为ubantu LTS 18.04系统，安装了<br>linux版的vmware workstation,其中安装了用于工作的windows10系统————这就是操作环境。</p><ol><li><p>插上网线和链接上个人热点后，通过<code>ip route show</code>看到有两个默认网关，链接外网失败。<br>在网络设置中-wired connected-settings-ipv4中，先关闭链接，再勾选<br>use this connection only for resources on its network<br>再链接后，可以发现默认网关只有一个热点了，此时可以上外网。</p></li><li><p>配置vmware workstation的网络设置，在editor-&gt;virtual network editor中进行配置，可以<br>选择对应的网卡。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Bridge mode:This connects the virtual network adapter directly to the physical network</span><br><span class="line">NAT: This allows the virtual network adapter to share the host’s IP address</span><br><span class="line">Host Only: This creates a private network that the virtual network adapter shares with the host</span><br><span class="line">Custom: This allows you to create your own virtual network</span><br><span class="line"></span><br><span class="line">Note: Although VMnet0, VMnet1 and VMnet8 are technically available in this menu, </span><br><span class="line">they are usually used for bridged, host-only, and NAT configurations, respectively.</span><br></pre></td></tr></table></figure></li></ol><p>由以上概念可知，这里实际需要的就只是桥接模式，直接接入物理网络，nat模式选择时还需要进行<br>手动网络转换，而且之前使用也达不到目地，就不选这个了，host模式只能宿主机访问，也不满足要求。<br>这里为避开0,1,8的默认名字，可以取名VMnet11,12代表有线和无线2个网卡。</p><ol start="3"><li><p>为工作的虚拟机配置里选择网络设置为custom，选择刚才新建的虚拟有限网卡，为自己玩的<br>centos配置虚拟无线网卡。</p></li><li><p>登录工作虚拟机，发现链接内网成功！</p></li><li><p>登录centos7,这里时新建的minimal安装，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/</span><br><span class="line">ip addr // 查看除了lo外的另一个网卡名字如ens33</span><br><span class="line">su root  // enter password</span><br><span class="line">vi ifcfg-ens33</span><br><span class="line">onboot=no 改为 yes</span><br><span class="line">systemctl restart network</span><br><span class="line">ping www.baidu.com   // done!</span><br></pre></td></tr></table></figure></li></ol><h2 id="ubantu修改swap文件"><a href="#ubantu修改swap文件" class="headerlink" title="ubantu修改swap文件"></a>ubantu修改swap文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff /swapfile</span><br><span class="line">sudo rm -rf /swapfile</span><br><span class="line">sudo fallocate -l 2G /swapfile</span><br><span class="line"> # sudo dd if=/dev/zero of=/swapfile bs=1024 count=2000000  #建立swap文件2G</span><br><span class="line">sudo chmod 600 /swapfile     </span><br><span class="line">sudo mkswap /swapfile    #创建系统</span><br><span class="line">sudo swapon /swapfile   # 开启swap</span><br><span class="line">sudo vi /etc/fstab</span><br><span class="line">/swapfile swap swap defaults 0 0</span><br><span class="line">free -h  # check swap size</span><br></pre></td></tr></table></figure><h2 id="ubantu备份和还原"><a href="#ubantu备份和还原" class="headerlink" title="ubantu备份和还原"></a>ubantu备份和还原</h2><p>终于完美从thinkpad迁移到mac的虚拟机上！</p><ol><li>备份老系统<br>由于我是默认用的fish,所以为防止报错，写了一个bash shell脚本来执行打包命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vi bashShell.sh</span><br><span class="line"></span><br><span class="line">内容如下</span><br><span class="line">#!/bin/bash</span><br><span class="line">tar cvpzf /media/tao/ExFAT/backup.tgz --exclude=/media/* --exclude=/sys/* </span><br><span class="line">--exclude=/proc/* --exclude=/dev/* --exclude=/run/* --exclude=/snap/* </span><br><span class="line">--exclude=/home/tao/vmware/* </span><br><span class="line">--exclude=/home/tao/Documents/CentOS-7-x86_64-DVD-1804.iso /</span><br><span class="line"></span><br><span class="line">sudo su</span><br><span class="line">chmod +x bashShell.sh</span><br><span class="line">sudo ./bashShell.sh</span><br></pre></td></tr></table></figure></li></ol><p>2.如果是原来机子回复系统，可以这样做（未测试）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">sudo su</span><br><span class="line">sudo tar -xvpzf /media/tao/ExFAT/backup.tgz -C /</span><br><span class="line">sudo reboot 0</span><br></pre></td></tr></table></figure></p><p>done!<br>注： tar命令只会覆盖已有的文件，备份后新增的文件不会修改或删除。</p><p>3.如果是虚拟机或其他电脑，因为硬盘的uuid不同，所以需要多些步骤<br>由于我的移动硬盘是exfat格式，所以需要给ubantu安装exfat-utils:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">更新数据源为阿里云，</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install exfat-utils</span><br><span class="line">插上u盘后，始终无法识别，这里还要将vmware虚拟机设置下硬件，</span><br><span class="line">改为usb 3.0接口</span><br><span class="line"></span><br><span class="line">备份fstab,得到其中的uuid</span><br><span class="line">cd ~</span><br><span class="line">mkdir back</span><br><span class="line">cd /etc/</span><br><span class="line">sudo cp fsta ~/back</span><br><span class="line">备份grub.cfg</span><br><span class="line">sudo cp /boot/grub/grub.cfg ~/back</span><br><span class="line"></span><br><span class="line">恢复旧系统备份</span><br><span class="line">cd /</span><br><span class="line">sudo su</span><br><span class="line">sudo tar -xvpzf /media/tao/ExFAT/backup.tgz -C /</span><br><span class="line"></span><br><span class="line">回复fstab和grub</span><br><span class="line">sudo cp ~/back/fstab /etc/</span><br><span class="line">sudo cp ~/back/grub.cfg /boot/grub/</span><br><span class="line"></span><br><span class="line">重启</span><br><span class="line">sudo reboot 0</span><br></pre></td></tr></table></figure></p><p>done!</p><ol start="4"><li><p>卸载ubantu虚拟机上的vmware-workstation软件<br>sudo ./VMware-Workstation-Full-15.0.3-12422535.x86_64.bundle -u vmware-workstation</p><p>2019-10-15 17:27:07 添加, 备份系统其实应该用rsync命令，rsync用于拷贝不同的文件到目的文件夹<br>下，非常适合用于在以前备份的基础上进行更新备份包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// -a: archive mode, same as -rlptgoD 基本是递归保存文件的信息 </span><br><span class="line">// v verbose z compress mode 传输过程中使用</span><br><span class="line">// 压缩文件形式，适合远程备份， -P progress显示进度条</span><br><span class="line">rsync -avzP -f &apos;exclude *.db&apos; source destination</span><br><span class="line">// 本地备份到移动硬盘时可以不用压缩</span><br><span class="line">rsync -avP -f &apos;exclude *.db&apos; source destination</span><br></pre></td></tr></table></figure></li></ol><h2 id="vmware-workstation上修改ubantu分辨率"><a href="#vmware-workstation上修改ubantu分辨率" class="headerlink" title="vmware workstation上修改ubantu分辨率"></a>vmware workstation上修改ubantu分辨率</h2><p>27寸的HKC屏幕最佳分辨率是2560X1440,ubantu虚拟机给出的最大分辨率是2560X1600,网上找到可以<br>修改的方案，记录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">xrandr   # 得到第二行的第一个单词，connected primary前的单词为显示设备名称Virtual1</span><br><span class="line"></span><br><span class="line">cvt 2560 1440   # 输入需要的分辨率</span><br><span class="line"># 得到一行modeline</span><br><span class="line"># Modeline &quot;2560x1440_60.00&quot;  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync</span><br><span class="line"></span><br><span class="line"># 添加新mode, --newmode后为前面的modeline</span><br><span class="line">sudo xrandr --newmode &quot;2560x1440_60.00&quot;  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync</span><br><span class="line"></span><br><span class="line"># 将新模式应用到显示设备中,设备名和分辨率分别取前面的值</span><br><span class="line">sudo xrandr --addmode Virtual1 &quot;2560x1440_60.00&quot;</span><br><span class="line"></span><br><span class="line"># 在settings-&gt;resolution中可以看到需要的分辨率了，apply即可成功！</span><br><span class="line"></span><br><span class="line"># 编辑～/.profile使ubantu下次以这个分辨率启动</span><br><span class="line">加入上面2行命令</span><br><span class="line">sudo xrandr --newmode &quot;2560x1440_60.00&quot;  312.25  2560 2752 3024 3488  1440 1443 1448 1493 -hsync +vsync</span><br><span class="line">sudo xrandr --addmode Virtual1 &quot;2560x1440_60.00&quot;</span><br></pre></td></tr></table></figure></p><p>注！按以上配置，重新登录后黑屏，只好在登录界面按ctrl+alt+F3进入命令登录界面，<br>删除刚才修改的~/.profile文件。<br>具体原因明天再看吧！</p><h2 id="xmonad"><a href="#xmonad" class="headerlink" title="xmonad"></a>xmonad</h2><p>折腾了一晚上，成功的搞出了背景图片，浏览器里可以输入中文(fcitx),双屏切换alt+w,r操作前先<br>在大屏上最大化再扩展小屏也能正常使用，但是！vim里面fcitx又出不来了，终于放弃，后来又发现<br>ubantu gnome也支持双屏操作的快捷键，主要是以下4个快捷键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alt + tab  切换应用</span><br><span class="line">alt + esc(我改成capslock)  切换上下屏幕</span><br><span class="line">command + shift + up/down  将当前窗口移动到上面的屏幕或下面的屏幕中</span><br></pre></td></tr></table></figure></p><p>就这样吧，太喜欢折腾也不好，还是不能为了工具太折腾，明天赶紧装下idea, 正常写代码和锻炼！</p><p> 2019-04-21 22:01:59<br> 注: 说不折腾，但还是又搞了几天，终于搞出来了，也算行吧。<br> ubantu上直接安装xmonad，按教程走到最后，发现在终端里始终不能输入中文，但浏览器里可以，<br>这个问题卡了蛮久，当时想的是终端的问题，但没有实践，后来又转到mac下去实现xmonad了，不过<br>最近又实践了一下，发现成功了！mac也成功了！双喜临门！记录如下：</p><ol><li>ubantu 18.04下安装xmonad<br>主要是参照教程<a href="https://beginners-guide-to-xmonad.readthedocs.io/intro.html" target="_blank" rel="noopener">https://beginners-guide-to-xmonad.readthedocs.io/intro.html</a>,<br>我自己修改的地方就是改动了最后的启动文件.xsessionrc</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># Load resources</span><br><span class="line"></span><br><span class="line">xrdb -merge .Xresources</span><br><span class="line"></span><br><span class="line"># Set up an icon tray</span><br><span class="line">stalonetray &amp;</span><br><span class="line"></span><br><span class="line"># Fire up apps</span><br><span class="line"></span><br><span class="line">xscreensaver -no-splash &amp;</span><br><span class="line"></span><br><span class="line">if [ -x /usr/bin/nm-applet ] ; then</span><br><span class="line">   nm-applet --sm-disable &amp;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">fcitx &amp;</span><br><span class="line">xmodmap ~/.Xmodmap &amp;</span><br><span class="line">feh --bg-scale ~/back.jpg &amp;</span><br><span class="line"># 虚拟机内使用 vmware-tool</span><br><span class="line">vmware-user &amp;</span><br><span class="line"></span><br><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=@im=fcitx</span><br><span class="line"></span><br><span class="line">exec xmonad</span><br></pre></td></tr></table></figure><p>可以看到我加了输入法fcitx,esc和capslock键的交换，背景图片以及fcitx的环境变量配置<br>其中.Xmodmap文件内容上文有提到，这里掠过。</p><p>最后，替换掉gnome-terminal发现可以正常使用fcitx输入法，<br>sudo apt install terminator<br>sudo update-alternatives –config x-terminal-emulator<br>选择terminator，输入其编号即可</p><p>Done!<br>xmonad官网上有与gnome整合的文章，没有细看，这里配好了就不需要它了，<br><a href="https://xmonad.org/documentation.html" target="_blank" rel="noopener">https://xmonad.org/documentation.html</a><br>最下面一排小字！<br>ubantu上还有问题就是vmware-tool的复制粘贴功能没有了，gnome下可以实现，还需要再整整，<br>to be continued……</p><p> 2019-04-22 21:14:57 solved:<br> google上搜到了vmware-tools-user-guide官方文档，可以手动启动vmware user process进程，<br> 在.xsessionrc中加入一行： <code>vmware-user &amp;</code><br> Done!<br> 另：上班时发现电脑自动关机了，后来发现是电池没有电了，xmonad没有低电量警告！<br> 网上搜到一个python程序rcoh/batmon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-pip</span><br><span class="line">pip install batmon</span><br><span class="line">ls /sys/class/power_supply/   #BAT0或其他数字</span><br><span class="line">vi ~/.xsessionrc # 添加</span><br><span class="line">batmon BAT0 &amp;</span><br></pre></td></tr></table></figure><p> 2019-04-23 21:46:57 注：<br> 在thinkpad上使用了无效果，发现notify-send命令在xmonad下无效,</p><p>当时也是在那发现了<br>mac上安装xmonad的方法，根据这个又整了一个周末。<br><a href="https://wiki.haskell.org/Xmonad/Using_xmonad_on_Apple_OSX" target="_blank" rel="noopener">https://wiki.haskell.org/Xmonad/Using_xmonad_on_Apple_OSX</a><br>这篇太简略了，还参照了这篇<a href="https://gist.github.com/danchoi/3923233" target="_blank" rel="noopener">my xmonad recipe for macOS</a></p><p>我自己的步骤为</p><ol><li>下载XQuartz,并按recipe里设置好</li><li>下载haskell-platform macOS 64位安装包(brew安装太慢，问题太多了…)</li><li>在文章里找到这个<a href="https://github.com/xmonad/X11/issues/24" target="_blank" rel="noopener">https://github.com/xmonad/X11/issues/24</a>,使用命令<br>LIBRARY_PATH=/opt/X11/lib:$LIBRARY_PATH cabal install xmonad</li><li>按wiki.haskell里新建~/.xinitrc/90-xmonad.shell，但xmonad并没有生效，USERVM中的路径用<br>命令<code>which xmonad</code>并没有输出，也搜索了很久和重装xmonad后，在~/.cabal/config中发现说要在<br>.bash_profile中加入path变量，加入后，<code>which xmonad</code>即成功输出为文档中的值。</li><li><p>启动XQuartz,设置成全屏模式，并按alt+shift+enter,可以发现xmonad成功启动了！<br>但它还不支持多屏…<br>to be continued<br>2019-04-22 22:55:55 注：<br>今天又试了下，发现XQuartz在全屏模式下是支持多屏的，用xmonad的mod+w,e可以正常切换屏幕，<br>明天再试着调用app,改造终端样式等。<br>2019-04-23 21:44:56<br>看到一篇日语文章，和我之前整的过程差不多，它最后也是推荐Amethyst,想想mac上xmonad也就整到<br>这里了。</p><p>2019-04-26 18:39:10<br>今天解决了2个在实际使用ubantu,xmonad,lantern的问题</p><ol><li>xmonad下无电池低电量预警<br>xmonad-contrib里之前收到有一个urgency插件，但配置比较麻烦，也许可以使得notify-send命令<br>产生效果，但一直没试。今天搜到可以让有电池信息的xmobar在xmonad全屏模式下显示出来，具体<br>是修改.xmobarrc文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Config &#123; font = &quot;-*-Fixed-Bold-R-Normal-*-13-*-*-*-*-*-*-*&quot;</span><br><span class="line">        , borderColor = &quot;black&quot;</span><br><span class="line">        , border = TopB</span><br><span class="line">        , bgColor = &quot;black&quot;</span><br><span class="line">        , fgColor = &quot;grey&quot;</span><br><span class="line">        , position = TopW L 100</span><br><span class="line">        , persistent = True     # wtt-add</span><br><span class="line">        , overrideRedirect = False  # wtt-add</span><br><span class="line">        , commands = [ Run Weather &quot;ZUUU&quot; [&quot;-t&quot;,&quot;&lt;tempC&gt;C&quot;,&quot;-L&quot;,&quot;18&quot;,&quot;-H&quot;,&quot;25&quot;,&quot;--normal&quot;,&quot;green&quot;,&quot;--high&quot;,&quot;red&quot;,&quot;--low&quot;,&quot;lightblue&quot;] 36000</span><br><span class="line">        , Run Battery [ &quot;--template&quot; , &quot;Batt: &lt;acstatus&gt;&quot;</span><br><span class="line">               , &quot;--Low&quot;      , &quot;10&quot;        -- units: %</span><br><span class="line">               , &quot;--High&quot;     , &quot;80&quot;        -- units: %</span><br><span class="line">               , &quot;--low&quot;      , &quot;darkred&quot;</span><br><span class="line">               , &quot;--normal&quot;   , &quot;darkorange&quot;</span><br><span class="line">               , &quot;--high&quot;     , &quot;darkgreen&quot;</span><br><span class="line">               , &quot;--&quot; -- battery specific options</span><br><span class="line">                      -- discharging status</span><br><span class="line">               , &quot;-o&quot;, &quot;&lt;left&gt;% (&lt;timeleft&gt;)&quot;</span><br><span class="line">                      -- AC &quot;on&quot; status</span><br><span class="line">               , &quot;-O&quot;, &quot;&lt;fc=#dAA520&gt;Charging&lt;/fc&gt;&quot;</span><br><span class="line">                      -- charged status</span><br><span class="line">               , &quot;-i&quot;, &quot;&lt;fc=#006000&gt;Charged&lt;/fc&gt;&quot;</span><br><span class="line">             ] 50</span><br><span class="line">                        , Run Network &quot;eth0&quot; [&quot;-L&quot;,&quot;0&quot;,&quot;-H&quot;,&quot;32&quot;,&quot;--normal&quot;,&quot;green&quot;,&quot;--high&quot;,&quot;red&quot;] 10</span><br><span class="line">                        , Run Network &quot;eth1&quot; [&quot;-L&quot;,&quot;0&quot;,&quot;-H&quot;,&quot;32&quot;,&quot;--normal&quot;,&quot;green&quot;,&quot;--high&quot;,&quot;red&quot;] 10</span><br><span class="line">                        , Run Cpu [&quot;-L&quot;,&quot;3&quot;,&quot;-H&quot;,&quot;50&quot;,&quot;--normal&quot;,&quot;green&quot;,&quot;--high&quot;,&quot;red&quot;] 10</span><br><span class="line">                        , Run Memory [&quot;-t&quot;,&quot;Mem: &lt;usedratio&gt;%&quot;] 10</span><br><span class="line">                        , Run Swap [] 10</span><br><span class="line">                        , Run Com &quot;uname&quot; [&quot;-s&quot;,&quot;-r&quot;] &quot;&quot; 36000</span><br><span class="line">                        , Run Date &quot;%a %b %_d %Y %H:%M:%S&quot; &quot;date&quot; 10</span><br><span class="line">                        , Run StdinReader</span><br><span class="line">                        ]</span><br><span class="line">        , sepChar = &quot;%&quot;</span><br><span class="line">        , alignSep = &quot;&#125;&#123;&quot;</span><br><span class="line">        , template = &quot;%StdinReader% | %cpu% | %memory% * %swap% | %eth0% - %eth1% | %ZUUU% | %battery% &#125;&#123;&lt;fc=#ee9a00&gt;%date%&lt;/fc&gt;  | %uname% &quot;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>这样配了之后，打开需要的google,vmware,terminal，需要重启xmonad才能看到xmobar，目前只能这样<br>了:执行命令<code>xmonad --restart</code>。</p><ol start="2"><li>xmonad和KDE,XFCE下lantern可链接但无法访问google问题，此前只有在gnome下lantern才能正常<br>使用。今天搜索如何在linux下设置代理找到了配置方法，成功在xmonad下正常使用xmonad。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/environment</span><br><span class="line"></span><br><span class="line">添加</span><br><span class="line">all_proxy=socks://127.0.0.1:43359/</span><br><span class="line">ALL_PROXY=socks://127.0.0.1:43359/</span><br><span class="line">http_proxy=http://127.0.0.1:43359</span><br><span class="line">HTTP_PROXY=http://127.0.0.1:43359</span><br><span class="line">ftp_proxy=http://127.0.0.1:43359</span><br><span class="line">FTP_PROXY=http://127.0.0.1:43359</span><br><span class="line">https_proxy=http://127.0.0.1:43359</span><br><span class="line">HTTPS_PROXY=http://127.0.0.1:43359</span><br><span class="line"></span><br><span class="line">新建配置文件，这个应该是针对apt的代理设置</span><br><span class="line">vi /etc/apt/apt.conf </span><br><span class="line"></span><br><span class="line">Acquire::http::proxy &quot;http://127.0.0.1:43359/&quot;;</span><br><span class="line">Acquire::ftp::proxy &quot;ftp://127.0.0.1:43359/&quot;;</span><br><span class="line">Acquire::https::proxy &quot;https://127.0.0.1:43359/&quot;;</span><br><span class="line">使用命令来校验</span><br><span class="line">apt-config dump  | grep -i proxy</span><br></pre></td></tr></table></figure></li></ol><p>之前突然看到有linux上的fliqlo屏保，叫gluqlo,今天在xmonad上成功安装。</p><ol><li>因为之前装xmonad时已经安装了xscreensave,所以把另外2个包也下载下，主要是各种屏保文件。<br>sudo apt remove gnome-screensaver # 这步没有执行<br>sudo apt install xscreensaver-gl-extra xscreensaver-data-extra</li></ol><p>下载gluqlo<br>sudo apt-add-repository ppa:alexanderk23/ppa<br>sudo apt-get update<br>sudo apt-get install gluqlo</p><p>看了xscreensaver manual,里面说设置直接执行以下命令即可<br>xscreensaver-demo<br>里面选择只展示一张，选中gluqlo即可。<br>主动激活屏保的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 2; xscreensaver-command -activate</span><br></pre></td></tr></table></figure></p><p>结合前面的重启xmonad命令，可以这样定义2个别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias rstX &apos;xmonad --restart&apos;</span><br><span class="line">funcsave resX</span><br><span class="line">alias xlock &apos;sleep 1; xscreensaver-command -activate&apos;</span><br><span class="line">funcsave xlock</span><br></pre></td></tr></table></figure></p><h2 id="xfce中使用vmware-workstation快捷键问题"><a href="#xfce中使用vmware-workstation快捷键问题" class="headerlink" title="xfce中使用vmware-workstation快捷键问题"></a>xfce中使用vmware-workstation快捷键问题</h2><p>由于xmonad没有很方便的提示电池电量的方法（不支持notify-send命令）,所以在经历了几次电池<br>耗尽自动关机后还是抛弃了xmonad,转向xfce,xfce也没有自带电池监控软件，但是可以<br><code>sudo apt install xfce4-battery-plugin</code>插件，实际使用很方便，到设定的百分比时在虚拟机<br>全屏界面下也可以正常给出弹框提示。<br> 2019-08-22 16:19:45 添加:<br>xfce4桌面不能调节屏幕亮度，网上搜索到可以安装<code>sudo apt install xfce4-power-manager-plugins</code>,<br>可以实现鼠标拖动修改屏幕亮度，还有电池电量监控，所以可以不用安装上面的battery插件。</p><p>在实际使用虚拟机时发现一个快捷键问题，在ctrl+alt跳出虚拟机后，在不知情的情况下按下Idea<br>的快捷键ctrl+e来查看最近打开的文件，结果虚拟机关闭了！！！</p><p>原来vmware-workstation自带的快捷键有<br>ctrl + e  power off<br>ctrl + r  reset power </p><p>主要是这2个大坑，其他快捷键没有多大影响。经网上搜索windows下可以用autohotkey来映射ctrl+e<br>到别的键上，mac可以用karabiner,linux可以用xmodmap,但具体xmodmap怎么配置组合按键没有搜到，<br>但对于xfce可以使用其自带的快捷键修改功能来完成。<br>终端下输入<br><code>xfce4-settings-editor</code>进入键盘修改界面，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xfce4-keyboard-shortcuts -&gt; commands/custom</span><br><span class="line">-&gt; new -&gt;</span><br><span class="line">property: /commands/custom/&lt;Control&gt;E</span><br><span class="line">type: String</span><br><span class="line">value: gedit或terminator等任意其他即可</span><br><span class="line">-&gt; close</span><br><span class="line">Done!</span><br><span class="line"></span><br><span class="line">同理可设置ctrl+r</span><br></pre></td></tr></table></figure></p><p> 2019-05-10 11:27:34 注:<br> 实际使用时发现ctrl+r在vim中是默认的redo,按以上设置无法正常使用，所以保险的方法还是<br> 在跳转到虚拟机界面时按j或k,使用虚拟机的capture key功能来避免误操作。<br> ctrl+e的设置可以保留。</p><h2 id="xfce4-截屏"><a href="#xfce4-截屏" class="headerlink" title="xfce4 截屏"></a>xfce4 截屏</h2><p>需要安装截屏插件<br><code>sudo apt install xfce4-screenshooter</code><br>在applications-&gt;settings-&gt;keyboard-&gt;application shortcut中add<br>command:<br>xfce4-screenshooter -r<br>按键prt-sc定义快捷键，done!</p><h2 id="ubantu内核升级后回退版本"><a href="#ubantu内核升级后回退版本" class="headerlink" title="ubantu内核升级后回退版本"></a>ubantu内核升级后回退版本</h2><p>最近在系统中安装了sdcv方便查找单词，不自觉的按网上常规”要求”执行<code>sudo apt update</code>命令后<br>在乖乖执行<code>sudo apt upgrade</code>进行系统升级操作。结果上班发现vmware-workstation启动不起来，<br>报错<code>cannot build vmnet</code>, 经过多番尝试，发现可以回退内核版本，回退就可以正常工作了，所以<br>没事还是不能随便升级!尤其是在工作电脑上！</p><p>回退步骤:</p><ol><li>修改/etc/default/grub文件，将其中的<code>grub_timeout</code>值修改为3以上的数字。</li><li>重启时按esc(EFI固件)进入grub页面，选择ubantu高级操作，选择需要回退的内核版本(不要选择<br>有其他后缀的版本，如rollback等)。</li><li>done!</li></ol><h2 id="command-line-editor-in-fish-shell"><a href="#command-line-editor-in-fish-shell" class="headerlink" title="command line editor in fish shell"></a>command line editor in fish shell</h2><ol><li><p>发现可以用ssh远程登录自己的ubantu虚拟机来写博客，如果要在本地的mac上使用ubantu上的<br>zathura看pdf的话，还需要在mac上配置X11forwarding=yes, 并且启动Xquartz, 折腾了一下，mac<br>终端卡住没反应。想想还是觉得没必要，mac也有zathura的brew版本，不过毕竟zathura原本是linux<br>上的软件，移植过来性能或配置可能会有些问题(看其github的issue等), 还是用虚拟机本体看pdf吧。</p></li><li><p>mac的终端有些命令如ls和linux终端还是不一样的，还是不同流派的原因，所以也没有必要非要将<br>mac都改造成linux的功能, 如使用命令<code>brew install coreutils</code>等。我还是就使用虚拟机玩ubantu,<br>RHEL等原生linux系统吧。</p></li><li><p>在网上突然发现命令行上也可以使用vim，虽然之前在银行的服务器上看到过这样的效果，但以为<br>那是它自带的效果，今天发现原来它是命令行绑定的键盘映射。我们平时经常用的是默认的Emac模式，<br>如ctrl + a, ctrl + e跳到开始和结束位置等快捷键都是Emac的快捷键。因为我使用的shell是fish,<br>所以它修改为vim的命令行编辑器的命令为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 切换为vim模式 -U universal 重启Shell后也生效</span><br><span class="line">set -U fish_key_bindings fish_vi_key_bindings </span><br><span class="line"></span><br><span class="line"># 切换为默认的Emac模式</span><br><span class="line">set -U fish_key_bindings fish_default_key_bindings</span><br></pre></td></tr></table></figure></li></ol><p>vim模式在命令提示符前会给出当前模式的提示符，但是fish的自动补全功能快捷键ctrl+f在vim模式中<br>无法使用了。fish的github的issue中讨论了这个问题，说可以单独指定，但这样很可能vi的模式提示<br>符就没有了(fish document中还给出了一个<code>hybrid_bindings</code>方案，经测试可以使用，功能很强大，<br>可以同时使用Emacs和vim的快捷键，但还是没有模式提示), 经测试比较，还是决定直接使用vim模式，<br>需要补全的，按Esc跳到普通模式后使用w进行补全操作，也不是很麻烦.</p><p> 2019-10-18 15:01:25 添加:<br> bash中在.bashrc或<code>.bash_profile</code>中添加<code>set -o vi</code>可以将bash命令设置vim模式，而不是默认的<br> emac模式，其中在普通模式中按v不是进入选择模式，而是bash的内置fc命令的编辑器界面。<br> bash中<code>fc --help</code>可以查看命令.通过help和网页上搜索相关资料，这个命令基本上没有什么用了，<br> 不如<code>history | grep xxx</code>好用，<code>fc -s xxx</code>不好用。</p><p> (fish中没有fc命令，不过它在上下切换历史命令后按alt + e或<br> alt + v可以进入fc一样的编辑命令编辑器中，第一次运行提示$VISUAL或$EDITOR变量没有设置，<br> 在.bashrc(我的是<code>.bash_aliases</code>)中添加<code>export EDITOR=/usr/bin/vim</code>后即可正常使用,<br> fc中待编辑的命令即使不保存也会执行，可以使用vim自带的:cq以错误码形式退出即可).</p><p>注: bash中使用vi模式，插入模式和命令模式切换界面没有提示，可以在home目录下编辑.inputrc文件，<br>添加如下一行即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#set editing-mode vi    # 这2行由于我上面使用了set -o vi针对bash设置了模式，其他如mysql,</span><br><span class="line">#set keymap vi-command  # git等终端界面可以使用这里的配置也使用vi模式输入(未测试)</span><br><span class="line">set show-mode-in-prompt on</span><br></pre></td></tr></table></figure></p><p>说是要bash 4.2以上</p><p>再注: fc命令最强大的地方即在于使用history查找需要的命令行数后(如123), 使用<code>fc 123</code>进行修改<br>后执行，不需要用鼠标选中修改! (不需要修改时直接!123即可)</p><p>终极解决方案: reverse-i-search<br>按ctrl+r, 再输入历史中的命令关键字即可，按ctrl+r进行切换。<br>fish中直接输入然后使用上/下(vim模式是j/k)键即可智能搜索。</p><h2 id="SSH-to-Vmware-Fusion-ubantu-guest-from-mac"><a href="#SSH-to-Vmware-Fusion-ubantu-guest-from-mac" class="headerlink" title="SSH to Vmware Fusion ubantu guest from mac"></a>SSH to Vmware Fusion ubantu guest from mac</h2><ol><li>ubantu上要安装ssh-server, 关闭防火墙。</li><li>查看ip addr show查看ip地址, 之前用ip route show查看的default不是它的IP地址，下面的ens33<br>网卡的IP才是真实IP, 因为IP搞错了，搞得一晚上连不上也是无语了。</li><li>确认是桥接模式的网卡适配器。</li><li>mac上直接使用<code>ssh tao@xxx.xxx.xx.xx</code>进行连接，输入密码后即可登录。</li></ol><p>注: 可以将本地mac的SSH公钥传输到VM guest上，这样下次登录就不用输入密码了，命令为<br><code>ssh-copy-id tao@xxx.xxx.xx.xx</code>.</p><p>再注: 使用mac SSH登录到虚拟机上时发现fcitx-vim的输入法切换插件无法使用了，估计它还是需要底层<br>的输入法控制，fcitx-vim插件作者在博客中有提到在不同linux主机间的ssh操作可以使用socat转发<br>套接字，不过mac就不行了。最后发现我之前的小工具博客中有记录具体的fcitx-vim-for-osx的操作<br>过程，配置成功！</p><h2 id="Xmonad-Latest-and-Fullest-config"><a href="#Xmonad-Latest-and-Fullest-config" class="headerlink" title="Xmonad Latest and Fullest config"></a>Xmonad Latest and Fullest config</h2><hr><h2 id="xmonad-xmonad-hs-github-repo"><a href="#xmonad-xmonad-hs-github-repo" class="headerlink" title=".xmonad/xmonad.hs github repo"></a><a href="https://github.com/wutaotao2015/tao_config_repo/blob/master/HOME/.xmonad/xmonad.hs" target="_blank" rel="noopener">.xmonad/xmonad.hs github repo</a></h2><hr><h2 id="xmobarrc-github-repo"><a href="#xmobarrc-github-repo" class="headerlink" title=".xmobarrc github repo"></a><a href="https://github.com/wutaotao2015/tao_config_repo/blob/master/HOME/.xmobarrc" target="_blank" rel="noopener">.xmobarrc github repo</a></h2><hr><h2 id="stalonetrayrc-github-repo"><a href="#stalonetrayrc-github-repo" class="headerlink" title=".stalonetrayrc github repo"></a><a href="https://github.com/wutaotao2015/tao_config_repo/blob/master/HOME/.stalonetrayrc" target="_blank" rel="noopener">.stalonetrayrc github repo</a></h2><hr><h2 id="xsessionrc-github-repo"><a href="#xsessionrc-github-repo" class="headerlink" title=".xsessionrc github repo"></a><a href="https://github.com/wutaotao2015/tao_config_repo/blob/master/HOME/.xsessionrc" target="_blank" rel="noopener">.xsessionrc github repo</a></h2><p>for now, fcitx can’t input shuangpin chinese…to be done.<br>2019-09-14 09:32:14 注:<br>发现fcitx在终端中无法输入的原因是fcitx在启动terminal后定义的，所以修改.xsessionrc文件将<br>启动terminator放到最后即可。以上配置文件已修改为正确配置。</p><h2 id="Ubantu安装Typora"><a href="#Ubantu安装Typora" class="headerlink" title="Ubantu安装Typora"></a>Ubantu安装Typora</h2><p>之前是使用pandoc将markdown文件转换为epub文件放到kindle中，发现效果不好，后来发现了<br>donot print插件可以很方便的重组pdf方便不同设备阅读pdf,所以想到可以安装typora先将markdown<br>转换为pdf, 再进行重组，初步看效果不错。以下将安装过程记录下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE</span><br><span class="line">sudo add-apt-repository &apos;deb http://typora.io linux/&apos;</span><br><span class="line">sudo apt install typora</span><br></pre></td></tr></table></figure></p><p>注: 使用pandoc将html转换为pdf效果不好，还需要安装一个很大的pdflatex引擎(textlive-full)</p><h2 id="Terminator-theme"><a href="#Terminator-theme" class="headerlink" title="Terminator theme"></a>Terminator theme</h2><p>在Terminator中安装Dracula主题，将安装步骤记录如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">mkdir -p $HOME/.config/terminator/plugins</span><br><span class="line">wget https://git.io/v5Zww -O $HOME&quot;/.config/terminator/plugins/terminator-themes.py&quot;</span><br><span class="line">preference --&gt; plugin --&gt; terminator theme</span><br><span class="line">theme --&gt; dracula --&gt; install</span><br><span class="line">// 如果点击theme无反应，使用sudo apt install python-requests命令</span><br><span class="line">vi ~/.config/terminator/config</span><br><span class="line">replace Dracula with default under profiles setting</span><br></pre></td></tr></table></figure></p><h2 id="Linux处理usb设备"><a href="#Linux处理usb设备" class="headerlink" title="Linux处理usb设备"></a>Linux处理usb设备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l  # 查看分区情况，可以看到插入的usb设备，类型一般为dos?也可通过size判断</span><br><span class="line">               # 还可以看见usb的格式类型</span><br><span class="line">sudo mkdir -p /mnt/usb  # 创建挂载点</span><br><span class="line">sudo mount /dev/sdb3 /mnt/usb # 挂载  分区点根据实际情况变化</span><br><span class="line">sudo umount /dev/sdb3     # 卸载</span><br></pre></td></tr></table></figure><h2 id="Ubantu-18-04上安装vmware-workstation-15-0-3"><a href="#Ubantu-18-04上安装vmware-workstation-15-0-3" class="headerlink" title="Ubantu 18.04上安装vmware workstation 15.0.3"></a>Ubantu 18.04上安装vmware workstation 15.0.3</h2><p>用虚拟机办公很久了，今天启动时突然又报错<code>before you can run VMware, some modules must be compiled and loaded into the running kernel</code>, 点击install时是必定失败的，日志报错为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to build vmmon and Failed to build vmnet.</span><br></pre></td></tr></table></figure></p><p>之前报这个错是因为不小心升级了内核版本，后来<br>自己回退了版本(上文有记录方法)后又可以正常使用了。但今天没有升级内核又报这个错, 上次查问题时<br>查到vmware需要安装一个补丁，当时试了没用就没管它，今天又搜到该方法的文章，试了成功了!<br>作者提供了一个脚本，执行后即可正常启动vmware.(拯救了工作机器，Thank God!)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#This needs to be the actual name of the appropriate branch in mkubecek&apos;s GitHub repo for your purposes</span><br><span class="line">VMWARE_VERSION=workstation-15.0.3 </span><br><span class="line">TMP_FOLDER=/tmp/patch-vmware</span><br><span class="line">rm -fdr $TMP_FOLDER</span><br><span class="line">mkdir -p $TMP_FOLDER</span><br><span class="line">cd $TMP_FOLDER</span><br><span class="line">#Use `git branch -a` to find all available branches and find the one that&apos;s appropriate for you</span><br><span class="line">git clone https://github.com/mkubecek/vmware-host-modules.git </span><br><span class="line">cd $TMP_FOLDER/vmware-host-modules</span><br><span class="line">git checkout $VMWARE_VERSION</span><br><span class="line">git fetch</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo rm /usr/lib/vmware/lib/libz.so.1/libz.so.1</span><br><span class="line">sudo ln -s /lib/x86_64-linux-gnu/libz.so.1 /usr/lib/vmware/lib/libz.so.1/libz.so.1</span><br><span class="line">systemctl restart vmware &amp;&amp; vmware &amp;</span><br></pre></td></tr></table></figure></p><p>下面记录下安装vmware workstation pro 15 过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">download install package, e.g., VMware-Workstation-Full-15.0.3-12422535.x86_64.bundle</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install gcc build-essential  # install prerequisites packages</span><br><span class="line">sudo ./VMware-Workstation-Full-15.0.3-12422535.x86_64.bundle</span><br><span class="line"></span><br><span class="line"># input product activate code  one of down</span><br><span class="line">UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA</span><br><span class="line">VF750-4MX5Q-488DQ-9WZE9-ZY2D6</span><br><span class="line">UU54R-FVD91-488PP-7NNGC-ZFAX6</span><br><span class="line">YC74H-FGF92-081VZ-R5QNG-P6RY4</span><br><span class="line">YC34H-6WWDK-085MQ-JYPNX-NZRA2</span><br><span class="line">=================</span><br><span class="line">https://www.luochenzhimu.com</span><br><span class="line"></span><br><span class="line">sh vmware.sh   # content as above</span><br></pre></td></tr></table></figure></p><p>执行脚本中可以看到vmwareworkstation pro 15.0.3版本已经不再更新了，最新版已经到15.1.x了，<br>15.0.3支持的kernel版本是5.2.(我现在是5.0.0-27-generic)<br>为了防止激活码过期，还是不要升级了vmwareworkstation了，同时内核版本也可以不升。</p><h2 id="Ubantu-18-04-升级内核版本并开启bbr算法"><a href="#Ubantu-18-04-升级内核版本并开启bbr算法" class="headerlink" title="Ubantu 18.04 升级内核版本并开启bbr算法"></a>Ubantu 18.04 升级内核版本并开启bbr算法</h2><ol><li>升级内核<br>简单的做法是在线升级<code>sudo do-release-upgrade</code>(待测试), 还可以自己下载内核deb包手动升级内核.<br>一般是2个header, 1个image, 用<code>sudo dpkg -i *.deb</code>即可(待测试).</li><li>开启bbr算法<br>bbr是google开发的提高网络带宽利用的拥塞控制算法，简单来说就是可以网络加速, 主要是用来提高<br>上传速度，配置在服务器上时”上传”给客户端即相当于提升了客户端的下载速度，非常适合给自己的<br>云服务器或VPN服务器安装.Linux 内核4.9版本开始预安装该算法，我刚好5.0.0, 下面就来开启一下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">开启bbr</span><br><span class="line">$ sudo su</span><br><span class="line"># echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line"># echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">// 保存</span><br><span class="line"># sysctl -p</span><br><span class="line">// 查看是否开启</span><br><span class="line">$ sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br><span class="line"></span><br><span class="line">$ lsmod | grep bbr</span><br><span class="line">tcp_bbr                20480  0</span><br><span class="line"></span><br><span class="line">关闭bbr</span><br><span class="line">$ sed -i &apos;/net\.core\.default_qdisc=fq/d&apos; /etc/sysctl.conf</span><br><span class="line">$ sed -i &apos;/net\.ipv4\.tcp_congestion_control=bbr/d&apos; /etc/sysctl.conf</span><br><span class="line">$ sysctl -p</span><br><span class="line">// 查看是否关闭</span><br><span class="line">$ lsmod | grep bbr</span><br></pre></td></tr></table></figure></li></ol><h2 id="linxu-获取root权限命令"><a href="#linxu-获取root权限命令" class="headerlink" title="linxu 获取root权限命令"></a>linxu 获取root权限命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">To get root access, you can use one of a variety of methods:</span><br><span class="line"></span><br><span class="line">Run sudo &lt;command&gt; and type in your login password, if prompted, to run only that instance </span><br><span class="line">of the command as root. Next time you run another or the same command without the sudo </span><br><span class="line">prefix, you will not have root access.</span><br><span class="line"></span><br><span class="line">Run sudo -i. This will give you an interactive root shell. Note that the $ at the end of </span><br><span class="line">your prompt has changed to a #, indicating that you have root access. But you fall in the </span><br><span class="line">root home directory (/root/). From here you can run any sequence of commands as root, or </span><br><span class="line">run the command exit to leave the root shell.</span><br><span class="line"></span><br><span class="line">Use the su (substitute user) command to get a root shell. This is effectively the same as </span><br><span class="line">using sudo -i. Note that when you use this command it will ask for the root password and </span><br><span class="line">not your login password. These are not the same. You may have to set or change the root </span><br><span class="line">password by running sudo passwd root first.</span><br><span class="line"></span><br><span class="line">Run sudo -s. This gives you root access, but maintains your current SHELL. Shell specific </span><br><span class="line">settings, including your current directory, are preserved. For instance if you use bash </span><br><span class="line">(Ubuntu&apos;s default shell), aliases (and any other settings from ~/.bashrc) are kept when </span><br><span class="line">you switch to the root user. To leave the root access, type exit as in the cases above.</span><br></pre></td></tr></table></figure><p>从以上可以看出，最实用的是<code>sudo su</code>,可以保留我的fish shell环境。<br>开启后提示符会由<code>$</code>变为<code>#</code>号, 使用完后使用exit退出即可。</p><h2 id="Linux删除旧内核版本"><a href="#Linux删除旧内核版本" class="headerlink" title="Linux删除旧内核版本"></a>Linux删除旧内核版本</h2><p>可以删除旧内核节省一点硬盘空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"></span><br><span class="line">dpkg -l | grep linux-image</span><br><span class="line">apt purge linux-image-4.15* -y</span><br><span class="line"></span><br><span class="line">// 注意headers 5.0.0.27-generic依赖于5.0.0.27，卸载了5.0.0.27后generic也没有了,</span><br><span class="line">// 还需要apt install 装回来...</span><br><span class="line">dpkg -l | grep linux-headers    </span><br><span class="line">apt purge linux-headers-4.15* -y</span><br><span class="line"></span><br><span class="line">dpkg -l | grep linux-modules</span><br><span class="line">apt purge linux-modules-4.15* -y</span><br></pre></td></tr></table></figure></p><h2 id="实现iphone上写java代码并运行"><a href="#实现iphone上写java代码并运行" class="headerlink" title="实现iphone上写java代码并运行"></a>实现iphone上写java代码并运行</h2><p>突然想到如何在手机上运行java代码，上网搜一下，果然有！搜到一个支持jdk7的app可以运行java代码，<br>不过需要收费，还花18元买了一个Koder，但是点进去运行总报错”are you connected to internet”,<br>看评论知道应该是不能用了，浪费了钱……总结下来，觉得靠谱的方案是:<br><code>在手机上装git客户端，在手机上commit后利用Travis的持续集成功能查看程序运行结果!</code>, 这应该是<br>最简便的方案了，但如果有自己的云服务器的话(以后不用蓝灯了要搞一个), 可以在手机上装一个SSH<br>工具，直接链接到服务器上，这样可支持的功能更多。<br>实现步骤:</p><ol><li>建立github仓库，上传项目</li><li>Travis关联到github上。</li><li>项目中的.travis.yml文件为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">language: java</span><br><span class="line">jdk:</span><br><span class="line">  - openjdk8</span><br><span class="line">cache:</span><br><span class="line">  directories:</span><br><span class="line">    - $HOME/.m2</span><br><span class="line">script: mvn test</span><br></pre></td></tr></table></figure></li></ol><p>由于travis是由ruby写的，ruby的依赖是系统范围的，不是针对某个项目的，所以它对于maven项目会<br>默认执行命令<code>mvn install -DskipTests=true -Dmaven.javadoc.skip=true -B -V</code>, install属于<br>default生命周期中较后面的一个阶段，包括了源码和测试代码的编译。而<code>-DskipTests=true</code>不会<br>执行单元测试，但仍然会编译单元测试生成class文件，<code>-Dmaven.test.skip=true</code>即不会编译也不会<br>执行单元测试。所以Travis已经编译过了新的测试代码，我们不需要clean, 直接执行单元测试即可。</p><ol start="4"><li>想要看到程序的执行结果时直接在相应的单元测试下打印即可，maven执行单元测试时会打印出来。</li><li>手机上使用git app(Working Copy, push需要解锁专业版100元！发现codeHub commit就是push!免费!)<br>进行推送测试即可。</li><li>codeHub就是界面没有working copy方便，但是免费!使用open in 存储到文件-&gt;Documents, 再<br>用ivim(:idocuments)打开下载的文件，全选(set clipboard=unnamed有效!)后复制y, 回到codeHub<br>edit文件粘贴, commit后查看Travis运行日志，到这里就实现了手机写代码并查看运行结果了!<br>注: ivim单手指长按是隐藏扩展小键盘，双手指长按是隐藏整个键盘，双手指可以上下拖动屏幕。</li></ol><h2 id="命令行批量命名文件"><a href="#命令行批量命名文件" class="headerlink" title="命令行批量命名文件"></a>命令行批量命名文件</h2><p>从InfoQ上下载了一批电子书，打算放到kindle上观看，但是下载文件的文件名都是一长串随机字符，<br>想要批量进行修改，于是想到使用终端命令一次性搞定(当然不可能逐个mv)！</p><ol><li><p>mac上操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install rename</span><br><span class="line">// 这个版本的rename有-N参数，支持自动递增的文件名 </span><br><span class="line">rename -n -N 01 &apos;s/.*.mobi/infoQ-ebook-$N.mobi/&apos; *.mobi</span><br><span class="line">// -n 代表dry-run, 演示重命令效果，并不真正操作</span><br><span class="line">// -N 代表递增参数后面的perl表达式中使用$N来表示递增变量 01是占位符 结果为01, 02, 03...</span><br></pre></td></tr></table></figure></li><li><p>ubuntu 18.04上操作</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install rename</span><br><span class="line">man rename</span><br><span class="line">// 可以看到这个rename版本不支持-N参数</span><br><span class="line">// 因为后面的表达式是perl表达式，所以想着自定义perl变量来递增，如下</span><br><span class="line">rename -n &apos;our $d=0;s/.*.md/$d++/e&apos; *.md</span><br><span class="line">// 看到结果为全部命名为0, 原因为变量d每次执行时都被初始化为0,所以没有实现递增，而且后面的</span><br><span class="line">// 替换不能直接写...</span><br><span class="line">// google上搜索到这时可以使用管道一次读取全部文件名，再进行逐一操作，如下</span><br><span class="line">ls -1 -c | xargs rename -n &apos;s/.*.md/our $i; sprintf(&quot;%02d.md&quot;, $i++)/e&apos;</span><br></pre></td></tr></table></figure><p>如果不用rename, 还可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -v | cat -n | while read n f; do mv -n &quot;$f&quot; &quot;$n.md&quot;; done</span><br></pre></td></tr></table></figure><p>可以看到这里充分利用了管道的功能，ls列出所有要重命名的文件名，交给cat命令使用-n进行编号，<br>最后使用mv命令循环重命名。这种方式最为通用，不用额外依赖rename命令。</p><h2 id="linux上的番茄工作法"><a href="#linux上的番茄工作法" class="headerlink" title="linux上的番茄工作法"></a>linux上的番茄工作法</h2><p>最近迷上了番茄工作法，发现它对于提高效率，集中注意力办一件事情非常有好处，个人感觉是非常<br>科学的工作法。它的本质还是一个定时任务，Quara上提供了一个linux上实现的方法，用命令行命令<br>就能实现，我整理成了脚本，这里记录一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 25 min = 1500 sec</span><br><span class="line"># 30 min = 1800 sec</span><br><span class="line">sleep 1800 &amp;&amp; zenity --info --text &apos;&lt;span foreground=&quot;blue&quot; font=&quot;32&quot;&gt;jobs done!&lt;/span&gt;&apos; --no-wrap 2&gt; /dev/null;</span><br><span class="line">sleep 360 &amp;&amp; zenity --info --text &apos;&lt;span foreground=&quot;blue&quot; font=&quot;32&quot;&gt;get up!&lt;/span&gt;&apos; --no-wrap 2&gt; /dev/null;</span><br><span class="line"></span><br><span class="line">#sleep 3 &amp;&amp; zenity --info --text &apos;&lt;span foreground=&quot;blue&quot; font=&quot;32&quot;&gt;jobs done!&lt;/span&gt;&apos; --no-wrap 2&gt; /dev/null;</span><br><span class="line">#sleep 2 &amp;&amp; zenity --info --text &apos;&lt;span foreground=&quot;blue&quot; font=&quot;32&quot;&gt;get up!&lt;/span&gt;&apos; --no-wrap 2&gt; /dev/null;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></p><p>注: 以上脚本虽然可以满足定时的需要，但是无法暂停(这倒没关系，毕竟这是应当尽量避免的),<br>其次是无法保存番茄的历史记录，自己写脚本来实现估计可以，但是现在还没什么思路，以后系统<br>学习了bash shell再看看。Anyway, 网上找到一个google chrome app, 叫”cherry tomato”, 界面简洁，<br>有基本设置和历史记录，用命令<code>google-chrome --app-id=cghomilbbfdmgfidkdinillpmdpdjgmm</code>可以<br>在命令行中启动它，这里是默认已经打开了google浏览器的前提下运行的，不然会报一些错误。</p><h2 id="chrome-使用vimium焦点脱离地址栏"><a href="#chrome-使用vimium焦点脱离地址栏" class="headerlink" title="chrome 使用vimium焦点脱离地址栏"></a>chrome 使用vimium焦点脱离地址栏</h2><p>ctrl/command + l focus到地址栏后无法不用鼠标点击网页body脱离焦点(多次tab可以), 网上找到一个<br>方法可以自定义一个搜索引擎，定义关键字如j, url为javascript:, 这样直接输入j, 再回车即可脱离<br>焦点从而继续使用vimium快捷键!<br>注: vimium基本功能外额外键映射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map R reload hard   # 清除缓存刷新</span><br><span class="line">map gc closeOtherTabs  # 关闭其他tab页，这是chrome自带的功能，所以vimium作为扩展没有提供</span><br><span class="line">                      # 该功能，这里只是提供了快捷键</span><br><span class="line">unmap &lt;a-p&gt;</span><br><span class="line">map gp togglePinTab  # pin or unpin tab， chrome默认是alt + p，我将它设置为激活pocket扩展，</span><br></pre></td></tr></table></figure></p><h2 id="linux上快速删除文件方法"><a href="#linux上快速删除文件方法" class="headerlink" title="linux上快速删除文件方法"></a>linux上快速删除文件方法</h2><p>该方法经测试非常有效，尤其适合删除大文件。<br>因为rm -rf用于删除大量文件或大文件时速度非常慢，经搜索它是需要逐个遍历每个文件进行删除，<br>所以很慢，而使用以下命令，直接进行目录替换，没有遍历，所以非常快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 先创建一个空目录</span><br><span class="line"># 注意：最好是用和被清空目录的所有者(用户)去创建这个空目录，使用的命令会将空目录的权限带过去</span><br><span class="line">mkdir /tmp/empty</span><br><span class="line"># 清除目标目录的文件,不要忘记目录后面的`/`</span><br><span class="line">rsync --delete-before -av /tmp/empty/ /xxx/target/</span><br></pre></td></tr></table></figure></p><p>–delete-before含义经man命令查看，应该是在进行rsync的增量算法以前执行清空终点目录的意思。</p><h2 id="vmware-workstation避开360虚拟机检测"><a href="#vmware-workstation避开360虚拟机检测" class="headerlink" title="vmware workstation避开360虚拟机检测"></a>vmware workstation避开360虚拟机检测</h2><ol><li>首先安装好vmware tools.</li><li>在虚拟机目录中寻找xxx.vmx文件，在最后一行添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor_control.restrict_backdoor = &quot;true&quot;</span><br></pre></td></tr></table></figure></li></ol><p>经测试，成功！</p><h2 id="mac-fusion-安装ubuntu-虚拟机整理-总结"><a href="#mac-fusion-安装ubuntu-虚拟机整理-总结" class="headerlink" title="mac fusion 安装ubuntu 虚拟机整理(总结)"></a>mac fusion 安装ubuntu 虚拟机整理(总结)</h2><ol><li>新建虚拟机, 设置参数</li><li>安装ubuntu</li><li>同步firefox </li><li>改为aliyun源, sudo apt update, sudo apt upgrade</li><li>上传coding公钥, 下载config项目</li><li>安装vmware-tool, 执行update-vmware-tool脚本</li><li>sudo apt install vim</li><li>sudo apt install terminator<br>sudo update-alternatives –config x-terminal-emulator<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python --version 2.xxx</span><br><span class="line">sudo apt install python-pip</span><br><span class="line">pip install requests</span><br><span class="line">mkdir -p $HOME/.config/terminator/plugins</span><br><span class="line">   // wget没有vpn连不上, 只能自己从config目录下载相关文件了</span><br><span class="line">wget https://git.io/v5Zww -O $HOME&quot;/.config/terminator/plugins/terminator-themes.py&quot;</span><br><span class="line">preference --&gt; plugin --&gt; terminator theme</span><br><span class="line">theme --&gt; dracula --&gt; install</span><br><span class="line">vi ~/.config/terminator/config</span><br><span class="line">replace Dracula with default under profiles setting</span><br></pre></td></tr></table></figure></li></ol><p>在实际执行命令时, 发现要粘贴以上wget命令不用鼠标难以实现复制粘贴功能, vim的可视模式选择<br>后只有在vim中可以复制粘贴成功, 但无法拷贝内容到终端中执行, 后经过搜索, 这种功能可以用<br>screen命令或tmux实现, 本质上是将终端变成了”文本”, 从而实现了复制粘贴.<br>注: 发现如果仅仅实现从vim中复制命令到终端执行, 可以很方便的使用fc, fc也是用vim打开,<br>所以整个过程都在vim中执行, 这样整个命令执行流为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可视模式选择文本 -&gt; y复制 -&gt; 退出vim, 或打开一个新的终端 -&gt; 随便输入一个字母, alt + v</span><br><span class="line">打开fc编辑窗口 -&gt; ,v粘贴 -&gt; :x 保存退出 -&gt; enter执行</span><br></pre></td></tr></table></figure></p><p>因为alt + v的过程中会使用系统剪贴板进行同步, 所以前面复制不能使用,y, ,y我的配置是<br><code>noremap &lt;Leader&gt;y &quot;+y</code>, 它只修改了系统剪贴版, 所以会在alt + v的过程中丢失信息.<br>,v的配置是<code>noremap &lt;Leader&gt;v &quot;0p</code>取得就是vim中上一次的复制内容.<br>实际上y + ,v的组合在我的ideaVim中同样适用(相同的vimrc配置).<br>注: ,v不好用时还是使用p吧.</p><ol start="9"><li>sudo apt install xmonad xmobar suckless-tools xscreensaver stalonetray feh </li><li><p>fish shell及相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install fish </span><br><span class="line">chsh -s /usr/local/bin/fish</span><br><span class="line">set fish_greeting</span><br><span class="line">set -U fish_key_bindings fish_vi_key_bindings </span><br><span class="line">// write this in ~/.config/fish/config.fish</span><br><span class="line">set -gx EDITOR vim</span><br></pre></td></tr></table></figure></li><li><p>复制配置文件<code>.vimrc .stalonetray .xsessionrc .xmonad/xmonad.hs .xmobarrc .bash_aliases .config/fish/functions/* key.sh</code></p></li><li><p>sudo apt install fcitx fcitx-pinyin<br>配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">global config</span><br><span class="line">Trigger input method: Rshift, empty (操作时可以用escape变为empty)</span><br><span class="line">extra key for trigger input method: R_shift</span><br><span class="line">enable hotkey to scroll.... non-check</span><br><span class="line">scroll between input method: ctrl+shift</span><br><span class="line">prev-page: - up</span><br><span class="line">next-page: = down</span><br></pre></td></tr></table></figure></li><li><p>安装vim相关插件, 这一步需要vpn才能较快安装, 修改<code>/etc/profile.d/wtt_start.sh</code>文件使用<br>vpn<br>注: vim有报错, 后来查看vundle github, 知道使用fish shell时, .vimrc中需要添加:<br><code>set shell=/bin/bash</code></p></li><li>sudo apt install openjdk-8-jdk, unzip maven.zip</li></ol><h2 id="screen命令实现屏幕拷贝执行命令"><a href="#screen命令实现屏幕拷贝执行命令" class="headerlink" title="screen命令实现屏幕拷贝执行命令"></a>screen命令实现屏幕拷贝执行命令</h2><p>感觉screen命令稍微轻量一点.故先使用screen, 毕竟是本地使用, 不涉及远程链接.<br>因为screen默认引导键是ctrl + a, 它和我的全选快捷键冲突, 所以需要修改,创建~/.screenrc文件,<br>内容为<code>escape ^Ss</code>即改为ctrl + s.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install screen</span><br><span class="line">screen -S 0    // 新建名称为0的session</span><br><span class="line">screen -XS [sessionName] quit  // 删除某个session</span><br><span class="line">screen -r 0   // 重新链接到session 0, reattach</span><br><span class="line">// 窗口windows内操作</span><br><span class="line">ctrl + s, d   // detach current session</span><br><span class="line">ctrl + s, c   // create new window</span><br><span class="line">ctrl + s, [   // 进入复制模式</span><br><span class="line">space开始选择, space结束选择</span><br><span class="line">ctrl + s, ctrl + s </span><br><span class="line">             // 切换到前一个window, 2个窗口的情况下可来回切换,这里可按住ctrl键不放</span><br><span class="line">             // 实际上由于我将space修饰为ctrl, 所以按住space键也可以</span><br><span class="line">ctrl + s, ]  // 粘贴刚才复制的内容</span><br><span class="line">ctrl + s, &quot;  // 列出窗口列表</span><br><span class="line">ctrl + s, k  // 杀死当前窗口</span><br></pre></td></tr></table></figure></p><p>screen创建的session默认是打开bash, 从这一点看, 它应该是写死的使用bash shell, 没有查看<br>当前用户设置的默认shell(我的是fish), 所以可以通过以下命令设置别名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ss &apos;screen -S $argv[1] bash -c &quot;fish&quot;&apos;</span><br></pre></td></tr></table></figure></p><p>总结: 通过使用screen, 我们就可以从vim文本中复制命令到另一个窗口中直接执行了.<br>命令执行流为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c-s, [     // enter copy mode</span><br><span class="line">space -&gt; space  // can use h, l, f, t and others to move cursor</span><br><span class="line">c-s, c-s   // enter next window</span><br><span class="line">c-s, ]     // paste the command to execute</span><br></pre></td></tr></table></figure></p><h2 id="install-v2ray"><a href="#install-v2ray" class="headerlink" title="install v2ray"></a>install v2ray</h2><p>最近蓝灯连不上了, 刚好女朋友公司给了一个v2rayN的客户端, 研究了下, 发现确实可以用, 主要是<br>可以蹭他们的服务器…下面记录下安装步骤</p><ol><li>检查时间, v2ray要求客户端和服务端必须同步时间, 误差在90秒内. 所以客户端最好检查是否<br>设置了自动同步时间.</li><li>v2ray服务端和客户端是一体的, 区别仅在于配置文件config.json, json文件是系统平台通用的,<br>所以windows, mac, linux客户端完全可以使用同一个配置文件.</li><li>wget <a href="https://install.direct/go.sh" target="_blank" rel="noopener">https://install.direct/go.sh</a>(原本担心会需要翻墙才能顺利下载, 好在没有这问题)</li><li>sudo bash go.sh, 该命令执行后会打印出服务器port和id, 但对于客户端没啥用.</li><li>sudo systemctl start v2ray, 启动v2ray服务.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart v2ray   // 修改配置文件后需要重启服务生效</span><br><span class="line">sudo systemctl enable v2ray    // 脚本里应该执行了这个, 默认开机启动</span><br><span class="line">sudo systemctl disable v2ray   // 取消开机启动</span><br><span class="line">sudo systemctl stop v2ray     // 停止v2ray服务</span><br></pre></td></tr></table></figure></li></ol><p>配置文件在/etc/v2ray/config.json中, 修改后重启v2ray服务, 浏览器本身再设置以下代理,<br>我配置文件中是socks协议, 浏览器也只能写socks协议, 否则通过命令<br><code>sudo journalctl -b -u v2ray</code>可以看到报错: <code>unknown socks version: 67</code>.<br>注: 用美区appleId在apple store上找了一个支持vmess协议的app: 91vpn, 配置好后可以查看到<br>配置的config.json文件, 成功在ios上实现了翻墙!<br>注: firefox浏览器在设置中即可开启代理, chrome需要通过命令行参数指定代理服务器, 登上账号<br>后可以使用扩展插件switchyOmega执行代理.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google-chrome --proxy-server=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure></p><p>注: 如果需要用到多实例多开, 可以使用以下命令, 主要是<code>man google-chrome</code>的用法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">google-chrome --proxy-server=socks5://127.0.0.1:1080 </span><br><span class="line">  --user-data-dir=/home/tao/Documents/share/note/chrome1/</span><br></pre></td></tr></table></figure></p><h2 id="filco键盘蓝牙配对"><a href="#filco键盘蓝牙配对" class="headerlink" title="filco键盘蓝牙配对"></a>filco键盘蓝牙配对</h2><p>以前脑子发热买了个filco, 主要是蓝牙功能很不错, 但设置有点麻烦, 以下是网上的资料记录下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">首先，切换设备的快捷键，同时按下 ctrl+alt+fn，然后松开，再立刻按 1~4，代表了当前在用指定</span><br><span class="line">数字的蓝牙通道连接设备。</span><br><span class="line">其次，键盘背面的复位按键，是清除当前蓝牙通道连接的设备，让当前通道进入配对状态。</span><br><span class="line">而不是把所有四个通道都清除（因为这个误解，我困惑了很久）</span><br><span class="line">第三，在切换到通道后，如果蓝灯慢速闪烁 10 秒，说明原来的通道已经占用。蓝灯快闪 60 秒，</span><br><span class="line">说明正在等待配对。</span><br><span class="line"></span><br><span class="line">接下来的连接过程就比较简单了。</span><br><span class="line">1、切换到指定通道。如果是蓝灯慢闪，就按一下键盘背后的复位键</span><br><span class="line">2、确保键盘出于配对状态，再在电脑或者手机上进行连接 /配对， 这个过程就和其他蓝牙键盘没有</span><br><span class="line">区别了</span><br><span class="line">3、配对成功后的检查。试一下本通道可以正常操作，再切换到其他通道，确认其他通道依然正常，</span><br><span class="line">和新增配对设备之前没有变化。</span><br></pre></td></tr></table></figure></p><h2 id="mac-switch-between-applications"><a href="#mac-switch-between-applications" class="headerlink" title="mac switch between applications"></a>mac switch between applications</h2><p>最近一直都使用linux(主要是ubuntu), mac作为一个宿主机，在上面也是用虚拟机，但在里面使用<br>windows的时候也想要用命令行或vim等工具，但在里面再去装cmder又感觉是多此一举，所以可以<br>在mac的终端vim中编写，但应用打开较多时，使用command tab就比较麻烦，网上查找了下mac上<br>application switcher原生支持的快捷键，使用起来对于基本操作需求还是很方便的—除了<br>在switcher中查找的功能, 这个感觉还是要下载一个第三方工具.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command + tab   按住command打开switcher，按tab切换到下一个应用</span><br><span class="line">command + shift + tab / command + `   switcher中切换到上一个应用，其中command + ` 单独按  </span><br><span class="line">               是在同应用中切换不同窗口，如浏览器等，非常好用</span><br><span class="line">command + q    在switcher中关闭switcher中选中的图标应用</span><br><span class="line">command + m    minify the selected application</span><br><span class="line">commmand + 1  在switcher中显示该应用所有的窗口，包括上面最小化的窗口</span><br></pre></td></tr></table></figure></p><p>以上快捷键虽然好用，但真正好用的还是专门的第三方app: Context,</p><ol><li>ctrl + space  弹出switcher窗口，并可以搜索，command + j/k 可以上下切换</li><li>设置中可以对最小化和被隐藏的窗口设置是否显示和列表位置</li></ol><p>windows中类似的工具推荐switcheroo, 它有同样的搜索列表页面，可以搜索当前打开的应用，<br>将弹出的快捷键由alt +space(和spot light冲突)改为alt + s，使用默认的alt + tab，<br>释放alt键时即切换(同原生功能一样)，因为listary默认也是alt + s,可以双击ctrl键弹出listary。</p><p>总结:</p><ol><li>ctrl + space切换输入法快捷键保持不变，这点可以修改但会引起很多问题。</li><li>mac中command + tab键弹出列表页面，单独按command + space可以搜索switcher，spotlight仍然<br>是alt + space.</li><li>windows中alt + tab键弹出列表页面，单独按alt + s可以搜索，双击ctrl可以弹出listary,当<br>windows系统不在虚拟机中时, 因为原生按键是alt + tab, 所以可以使用alt + space(switchroo),<br>alt + s(listary), 不使用win键。<br>注:<br>contexts在搜索列表页面中可以使用command + q退出相应的程序，方便快捷。<br>搜索列表中后面有相应的标签，搜索里面可以输入相应的英文，加快过滤结果。<br>再注: 通过以上快捷键的配置，mac里面还是以command键主导，command +space, tab操作，alt+space<br>spotlight, windows里面以alt键主导，alt + space, tab操作，alt +s listary.</li></ol><h2 id="zathura-invert-colors"><a href="#zathura-invert-colors" class="headerlink" title="zathura invert colors"></a>zathura invert colors</h2><p>linux zathura is a wonderful pdf reader, its invert color default shortcut key is<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + r</span><br></pre></td></tr></table></figure></p><h2 id="sticky-keys-for-capital-letter"><a href="#sticky-keys-for-capital-letter" class="headerlink" title="sticky keys for capital letter"></a>sticky keys for capital letter</h2><p>There has been a long time since last editing my blogs, actually I am focusing on<br>my touch typing recently, earlier days I switch to workman layout and using it<br>in work, but when using it for coding, I found it not too different with qwerty<br>layout, the ; , - = all on the rightest side and make my right pinky finger pain!<br>All these years I look at the keyboard and type these special characters!!!<br>I need to reduce the workload of my right pinky finger! So I find the<br>dvorak programmer(dvp)! pure dvorak is not good as workman for me as i key is not<br>good in dvorak, but dvp is awesome for its ; , ‘ symbols! </p><p>So I change the layout variant to dvp in X11, and find a ahk script for dvp in<br>windows(lucky!), and keep practicing … and find capital case letter typing is<br>quite slow! Then I google it and find Sticky key for this usage!</p><p>simply put it, sticky key make typing capitale letters no need to keep pressing<br>shift key all the time, we just need to press it once and release it, then the<br>next letter auto capitalised and become lowercase again afterwards!</p><p>this way is quite straightforward and fast. No need to keep pressing and all<br>upper and lower case letters are hit with one hitting.</p><p>X11:<br>vim ~/.xkb/symbols/evdoublebind<br>add<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace key &lt;LFSH&gt; &#123; [ ISO_Level2_Latch ] &#125;;</span><br><span class="line">replace key &lt;RTSH&gt; &#123; [ ISO_Level2_Latch ] &#125;;</span><br></pre></td></tr></table></figure></p><p>vim /usr/share/X11/xkb/compat/basic<br>add<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interpret ISO_Level2_Latch+AnyOf(all) &#123;</span><br><span class="line">    useModMapMods=level1;</span><br><span class="line">    action= LatchMods(modifiers=Shift,clearLocks,latchToLock);</span><br><span class="line">&#125;;</span><br><span class="line">interpret ISO_Level2_Latch+AnyOfOrNone(all) &#123;</span><br><span class="line">    action= LatchMods(modifiers=Shift,clearLocks,latchToLock);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>after testing, single hit shift make next character upper case or the upper<br>character of key such as number row keys, and double hitting shift lock shift<br>function and hit any shift once again cancel it.</p><p>ps: using the shift lock function make inputing many numbers sequentially quite<br>conveniently! Best for 86 keys layout keyboard without numberPad.</p><p>windows system:<br>start menu -&gt; control panel -&gt; little icon -&gt; easy to use computer<br>enable sticky keys, default hitting 5 times shift keys enable it,<br>remember disable closing shift keys when pressing double shift together.</p><p>PS: sticky key essentially are “extending” the instant hitting of modifier keys,<br>so it conflicts with double-role keys. In X11, space is ctrl(stable) and only make<br>shift as sticky to type capitalized letter is quite OK, and bigCtrl in windows system<br>is unstable and system own sticky key is global-not just shift keys, so the bigCtrl<br>can not be used in reality. So we can just make capslock as ctrl, hope ahk is stable<br>for doing this.  (to be tested)</p><h2 id="dvp-layout-practical-solution"><a href="#dvp-layout-practical-solution" class="headerlink" title="dvp layout practical solution"></a>dvp layout practical solution</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">windows without vmware:</span><br><span class="line">  </span><br><span class="line">  1. install dvp layout</span><br><span class="line">  2. switch u and i using keytweak</span><br><span class="line">  3. change system regedit for chinese input with dvp layout</span><br><span class="line">     2020-11-20 20:09:56 added: </span><br><span class="line">        HKEY_LOCAL_MACHINE/SYSTEM?CurrentControlSet/Control/Keyboard Layouts/00000804</span><br><span class="line">          layout file from KBDUS.DLL to kbddvp.dll</span><br><span class="line">  4. enable sticky key function</span><br><span class="line"></span><br><span class="line">linux X11:</span><br><span class="line">  1. using workman script to change layout to dvp.</span><br><span class="line">  2. edit x11 symbols us dvorak switch u and i.</span><br><span class="line">  3. using evdoublebind to get bigCtrl-&gt;space-ctrl</span><br><span class="line">  4. edit .xkb/symbols/evdoublebind to make only shift sticky, also </span><br><span class="line">     need to edit compact/basic (check x11 wiki)</span><br><span class="line">  5. fcitx-configtool change chinese input layout</span><br><span class="line">  </span><br><span class="line">  ps: as we have bigCtrl here, no need to make ctrl sticky again!</span><br></pre></td></tr></table></figure><h2 id="windows-bash-copy-and-paste"><a href="#windows-bash-copy-and-paste" class="headerlink" title="windows bash copy and paste"></a>windows bash copy and paste</h2><p>new company use windows server 2012 as web server, so the basic deployment is copy and<br>paste files, such as tomcat war files and node dist files, and I need to back up the old<br>files each time for safety, so we need to make it automatic. And we use bat file and<br>xcopy command.</p><figure class="highlight plain"><figcaption><span>off</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for /F &quot;usebackq tokens=1,2 delims==&quot; %%i in (`wmic os get LocalDateTime /VALUE 2^&gt;NUL`) do if &apos;.%%i.&apos;==&apos;.LocalDateTime.&apos; set ldt=%%j</span><br><span class="line">set yyyy=%ldt:~0,4%</span><br><span class="line">set mm=%ldt:~4,2%</span><br><span class="line">set dd=%ldt:~6,2%</span><br><span class="line">start cmd /k &quot;xcopy H:\wtt\t1\* H:\wtt\%mm%-%dd%-%yyyy% /e /s /y /i&quot;</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><p>/e: Copies all subdirectories, even if they are empty.<br>/s: Copies directories and subdirectories, unless they are empty.<br>If you omit /s, xcopy works within a single directory.<br>/y: Suppresses prompting to confirm that you want to overwrite an existing destination file.<br>/i: If Source is a directory or contains wildcards and Destination does not exist, xcopy assumes Destination specifies a directory name and creates a new directory. Then, xcopy copies all specified files into the new directory. By default, xcopy prompts you to specify whether Destination is a file or a directory.</p><p>delete a directory contents and all of its sub directories:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RD /S /Q &quot;H:\wtt\11-23-2020&quot;</span><br></pre></td></tr></table></figure></p><p>/S      Removes all directories and files in the specified directory<br>        in addition to the directory itself.  Used to remove a directory<br>        tree.</p><p>/Q      Quiet mode, do not ask if ok to remove a directory tree with /S</p><p>this command will delete the directory itself, sometimes we want to keep the directory,<br>so we can use command such as “MD H:\wtt\11-23-2020” to recreate it.</p><h2 id="excel复制内容到文本自动有双引号"><a href="#excel复制内容到文本自动有双引号" class="headerlink" title="excel复制内容到文本自动有双引号"></a>excel复制内容到文本自动有双引号</h2><p>as the title says, the resolution is add one new column, use formula: =clean(D2), the D2<br>is the original column, in this way, the content will remove double quotation marks,<br>and the original alt + enter carriages will also be removed, too.<br>PS: it is useful for one-line-string field for table insertion script.</p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201901311.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己总结的工具小技巧: Eclipse, Sublime Text, IntelliJ Idea, Maven, Vim, Babun, Git,&lt;br&gt;Windows10,Karabiner&lt;br&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://www.taoblog.cn/categories/Tool/"/>
    
    
      <category term="Git" scheme="http://www.taoblog.cn/tags/Git/"/>
    
      <category term="Vim" scheme="http://www.taoblog.cn/tags/Vim/"/>
    
      <category term="IntelliJ Idea" scheme="http://www.taoblog.cn/tags/IntelliJ-Idea/"/>
    
      <category term="Eclipse" scheme="http://www.taoblog.cn/tags/Eclipse/"/>
    
      <category term="Sublime Text" scheme="http://www.taoblog.cn/tags/Sublime-Text/"/>
    
      <category term="Maven" scheme="http://www.taoblog.cn/tags/Maven/"/>
    
      <category term="Babun" scheme="http://www.taoblog.cn/tags/Babun/"/>
    
      <category term="Windows10" scheme="http://www.taoblog.cn/tags/Windows10/"/>
    
      <category term="MacOS" scheme="http://www.taoblog.cn/tags/MacOS/"/>
    
      <category term="Karabiner" scheme="http://www.taoblog.cn/tags/Karabiner/"/>
    
      <category term="CORS" scheme="http://www.taoblog.cn/tags/CORS/"/>
    
      <category term="Shell" scheme="http://www.taoblog.cn/tags/Shell/"/>
    
      <category term="Ubantu" scheme="http://www.taoblog.cn/tags/Ubantu/"/>
    
      <category term="Vmware workstation" scheme="http://www.taoblog.cn/tags/Vmware-workstation/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习笔记</title>
    <link href="http://www.taoblog.cn/post/7bee19a4/"/>
    <id>http://www.taoblog.cn/post/7bee19a4/</id>
    <published>2019-01-30T09:17:17.000Z</published>
    <updated>2020-09-29T07:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>spring boot, SpringCloud, Actuator, Eureka, ribbon, Feign, hystrix, zuul,<br>sleuth, spring cloud config, jdk, spring boot与spring cloud版本问题, linux,<br>tomcat<br><a id="more"></a></p><h3 id="springBoot简介"><a href="#springBoot简介" class="headerlink" title="springBoot简介"></a>springBoot简介</h3><h4 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h4><p>springboot 按不同的功能模块将需要的jar包整合为一个起始包,如web应用，jpa，微服务等不同模块<br>所需要的jar包统一封装起来,不用手工管理具体的jar包。</p><p>springboot的版本号决定了starter依赖包的版本号，而starter依赖包的版本号决定了其聚合的依赖<br>包的版本号，其内部版本都是经过测试的，没有冲突问题的。</p><h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>springboot使用条件化bean的方法判断classpath中是否有相应的jar包，若有，它会在项目运行时<br>自动生成对应的实例bean.</p><p>如项目classpth中用了h2,自动配置会自动创建一个H2数据库bean；<br>classpath中有springMVC(由webStarter依赖而来),它会自动配置dispatcherServlet并启用springMVC;<br>classpath中有tomcat(webStarter依赖而来),它会自动启动一个tomcat容器。</p><p>如果想要自定义配置，可以显式自己的spring配置，或通过环境变量，属性文件等进行调整。</p><h4 id="Actuator监控工具"><a href="#Actuator监控工具" class="headerlink" title="Actuator监控工具"></a>Actuator监控工具</h4><p>提供了各个端点对应用情况进行监控。<br>由于安全问题，springboot 2.0版本将所有端点都移动到/actuator后，且只暴露了info和health<br>2个端口，其余端口需要在项目配置文件中进行配置才可以访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br></pre></td></tr></table></figure></p><h4 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h4><p>略</p><p>注： 最简单的springboot项目hello world需要配置controller,使用@RestController(内含<br>@ResponseBody)来输出Hello World.</p><p> 2020-04-07 14:01:58 添加:<br>使用idea启动springboot项目之前好好的,突然报错failed to determine a suitable driver class,<br>可driver-class的配置没有修改, 经网上搜索发现target/classes包中没有将application.yml等配置<br>文件打入包中, 删除target后重新编译项目就ok了, 应该是idea的问题,这里记录下, 以防以后碰到<br>同样问题.</p><h3 id="springCloud微服务"><a href="#springCloud微服务" class="headerlink" title="springCloud微服务"></a>springCloud微服务</h3><h4 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h4><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201902181.png" class="full-image"></p><h4 id="服务注册中心Eureka"><a href="#服务注册中心Eureka" class="headerlink" title="服务注册中心Eureka"></a>服务注册中心Eureka</h4><p>服务发现架构:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201902182.png" class="full-image"></p><p>Eureka架构:<br>Region and availability zone:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201902183.png" class="full-image"></p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201902184.png" class="full-image"></p><ol><li><p>Eureka Client是一个java客户端，用于简化与Eureka Server交互。</p></li><li><p>微服务启动后，会周期性（默认30秒）向Eureka Server发送心跳续约自己的租期。</p></li><li><p>如果Eureka Server一定时间没有收到某个微服务实例的心跳，会注销该实例，默认90秒，<br>但如果短时间内大量实例丢失，Eureka Server会进入自我保护模式，不会注销任何实例。</p></li><li><p>Eureka Server同时也是client,不同server间通过复制方式同步服务注册表中的数据。</p></li><li><p>Eureka client会缓存服务注册表中的信息。它可以降低Eureka server的压力，<br>同时Eureka server挂掉了它也可以利用缓存完成调用。</p></li></ol><h5 id="Eureka高可用"><a href="#Eureka高可用" class="headerlink" title="Eureka高可用"></a>Eureka高可用</h5><p>实战：</p><ol><li>建立Eureka服务器<ol><li>依赖<artifactid>spring-cloud-starter-netflix-eureka-server</artifactid></li><li>配置文件Eureka</li><li>@EnableEurekaServer</li></ol></li><li>提供者注册到Eureka<ol><li>依赖<artifactid>spring-cloud-starter-netflix-eureka-client</artifactid></li><li>配置文件：项目名作为Eureka实例名及注册到的Eureka实例</li><li>@EnableEurekaClient或@EnableDiscoveryClient</li></ol></li></ol><h4 id="负载均衡ribbon"><a href="#负载均衡ribbon" class="headerlink" title="负载均衡ribbon"></a>负载均衡ribbon</h4><p>ribbon与eureka联合使用</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201902185.png" class="full-image"></p><h5 id="可以脱离Eureka使用ribbon实现负载均衡"><a href="#可以脱离Eureka使用ribbon实现负载均衡" class="headerlink" title="可以脱离Eureka使用ribbon实现负载均衡"></a>可以脱离Eureka使用ribbon实现负载均衡</h5><h5 id="可以自定义负载均衡规则"><a href="#可以自定义负载均衡规则" class="headerlink" title="可以自定义负载均衡规则"></a>可以自定义负载均衡规则</h5><p>实战：</p><ol><li>依赖spring-cloud-starter-netflix-ribbon,该依赖已经包含在<br>spring-cloud-starter-netflix-eureka-client中，所以无需重复引入。</li><li>@loadBalanced</li><li>请求地址改为<code>http://servicename/</code>, ribbon 与 eureka配合使用时，<br>会将虚拟主机名映射成服务地址。</li></ol><h4 id="请求客户端Feign"><a href="#请求客户端Feign" class="headerlink" title="请求客户端Feign"></a>请求客户端Feign</h4><p>声明式，模板化的http客户端</p><p>实战:</p><ol><li>依赖spring-cloud-starter-openfeign</li><li>创建Feign接口，添加@FeignClient注解</li><li>将Feign接口注入到controller中进行调用</li><li>修改启动类，添加@EnableFeignClients注解</li></ol><h5 id="Feign内部实现了客户端负载均衡"><a href="#Feign内部实现了客户端负载均衡" class="headerlink" title="Feign内部实现了客户端负载均衡"></a>Feign内部实现了客户端负载均衡</h5><h5 id="可以使用Feign自带的注解"><a href="#可以使用Feign自带的注解" class="headerlink" title="可以使用Feign自带的注解"></a>可以使用Feign自带的注解</h5><h5 id="可以自己手动定义一个Feign"><a href="#可以自己手动定义一个Feign" class="headerlink" title="可以自己手动定义一个Feign"></a>可以自己手动定义一个Feign</h5><h5 id="Feign对继承的支持"><a href="#Feign对继承的支持" class="headerlink" title="Feign对继承的支持"></a>Feign对继承的支持</h5><h5 id="Feign对请求响应信息压缩的支持"><a href="#Feign对请求响应信息压缩的支持" class="headerlink" title="Feign对请求响应信息压缩的支持"></a>Feign对请求响应信息压缩的支持</h5><h5 id="Feign日志（Feign的日志打印只会对Debug级别做出响应）"><a href="#Feign日志（Feign的日志打印只会对Debug级别做出响应）" class="headerlink" title="Feign日志（Feign的日志打印只会对Debug级别做出响应）"></a>Feign日志（Feign的日志打印只会对Debug级别做出响应）</h5><ol><li>定义日志配置类</li><li>修改Feign接口，指定配置类</li><li>配置文件中指定Feign接口日志级别为debug。</li></ol><h5 id="Feign多参数请求"><a href="#Feign多参数请求" class="headerlink" title="Feign多参数请求"></a>Feign多参数请求</h5><ol><li>多参数get请求</li><li>多参数post请求</li></ol><h4 id="容错处理-断路器hystrix"><a href="#容错处理-断路器hystrix" class="headerlink" title="容错处理-断路器hystrix"></a>容错处理-断路器hystrix</h4><p>雪崩效应:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201902186.png" class="full-image"></p><p>断路器原理:</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201902187.png" class="full-image"></p><p>实战：</p><ol><li>依赖spring-cloud-starter-netflix-hystrix</li><li>启动类上添加@EnableCircuitBreaker或@EnableHystrix。</li><li>controller方法上添加@HystrixCommand(fallbackMethod = “XXXFallBack”)</li></ol><h5 id="springCloud默认为Feign整合了Hystrix"><a href="#springCloud默认为Feign整合了Hystrix" class="headerlink" title="springCloud默认为Feign整合了Hystrix"></a>springCloud默认为Feign整合了Hystrix</h5><p>只要hystrix在项目的classpath中，Feign默认会用断路器包裹所有方法</p><h5 id="hystrix监控"><a href="#hystrix监控" class="headerlink" title="hystrix监控"></a>hystrix监控</h5><h5 id="hystrix监控使用Hystrix-Dashboard可视化监控数据"><a href="#hystrix监控使用Hystrix-Dashboard可视化监控数据" class="headerlink" title="hystrix监控使用Hystrix Dashboard可视化监控数据"></a>hystrix监控使用Hystrix Dashboard可视化监控数据</h5><h5 id="使用Turbine聚合Hystrix监控数据"><a href="#使用Turbine聚合Hystrix监控数据" class="headerlink" title="使用Turbine聚合Hystrix监控数据"></a>使用Turbine聚合Hystrix监控数据</h5><h4 id="网关处理zuul"><a href="#网关处理zuul" class="headerlink" title="网关处理zuul"></a>网关处理zuul</h4><p>请求过滤，身份认证，请求与响应信息的格式化等处理信息，还可以进行微服务聚合操作<br>（通过RxJava响应式编程实现）。</p><p>实战：</p><ol><li>依赖spring-cloud-starter-netflix-zuul</li><li>启动类上添加@EnableZuulProxy， 它声明了一个Zuul代理，使用ribbon定位微服务，<br>同时整合了hystrix。</li><li>编写配置文件注册到eureka。</li></ol><h4 id="配置服务器spring-cloud-config"><a href="#配置服务器spring-cloud-config" class="headerlink" title="配置服务器spring cloud config"></a>配置服务器spring cloud config</h4><p>多个微服务的配置进行统一管理，实际上就是通过将配置统一放到git仓库中，安照一定规则进行使用。</p><h4 id="微服务跟踪spring-cloud-sleuth"><a href="#微服务跟踪spring-cloud-sleuth" class="headerlink" title="微服务跟踪spring cloud sleuth"></a>微服务跟踪spring cloud sleuth</h4><p>记录微服务运行情况的日志工具。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>springboot想要部署到生产服务器中需要打成war包，并生成需要的servlet启动类。</p><ol><li>配置SpringBootServletInitializer类的子类。</li><li>修改maven打包方式为war。</li><li>执行maven package命令。</li><li>同一个tomcat部署多个不同端口的项目</li></ol><h4 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h4><p>在实际应用过程中，springboot, jdk, springcloud的版本问题造成了很多困扰，这里总结一下:</p><ol><li>springboot 2.0以后要求是jdk 1.8, jdk 1.7只能适用于springboot2.0以前的版本，不然内部自动<br>引用的jar包会产生版本问题。</li><li>springcloud Finchley版本需要和springboot 2.0版本合作,更早的boot版本也会出现问题。</li></ol><h4 id="springboot集成mybatis-数据库使用mysql"><a href="#springboot集成mybatis-数据库使用mysql" class="headerlink" title="springboot集成mybatis, 数据库使用mysql"></a>springboot集成mybatis, 数据库使用mysql</h4><p>此项目在微服务microservice-provider-user项目基础上修改。</p><ol><li><p>pom.xml中添加mybatis,mysql依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring Boot Mybatis 依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;mybatis-spring-boot&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- MySQL 连接驱动依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;mysql-connector&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件application.yml中添加数据库和mybatis配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: microservice-provider-user</span><br><span class="line">  datasource:                           # 指定数据源</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springbootdb?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">mybatis:</span><br><span class="line">  typeAliasesPackage: com.itmuch.cloud.study.entity    # 实体类</span><br><span class="line">  mapperLocations: classpath:mapper/*.xml             # mapper配置文件</span><br></pre></td></tr></table></figure></li><li><p>编写UserDao,UserService,UserServiceImpl(@Service),UserMapper.xml</p></li><li>最后发现UserServiceImpl注入UserDao报错，在UserApplication类上加上注解<blockquote><p>@MapperScan(“com.itmuch.cloud.study.dao”)</p></blockquote></li></ol><p>Done!</p><h4 id="工作中发现的问题"><a href="#工作中发现的问题" class="headerlink" title="工作中发现的问题"></a>工作中发现的问题</h4><ol><li>Feign发送请求时，由于bean属性的首字母是大写的，如UserName, feign打印日志发现发送的<br>json属性为userName,后来经过搜索，发现可以在setter方法上用@JsonProperty注解，但这需要加<br>很多个，更方便的是在bean类上加注解,(看注解源码知道这叫PascalCaseStrategy)<blockquote><p>@JsonNaming(PropertyNamingStrategy.UpperCamelCaseStrategy.class)</p></blockquote></li></ol><p>注：有个全大写的属性字段如MULLINE,只使用@JsonNaming注解时发现发送的json属性是Mulline,<br>看UpperCamelCaseStrategy的源码知道在该策略执行前该字段已经被转化为全部小写，因为只有这<br>一个全大写字段，其他字段扔使用PascalStrategy,所以在SetMULLINE方法上使用@JsonProperty<br>注解即可。<br>另：在字段上使用@JsonProperty注解发现会产生2个相同的json属性，一个小写，一个大写</p><ol start="2"><li>tbd</li></ol><h4 id="springcloud-config-server"><a href="#springcloud-config-server" class="headerlink" title="springcloud config server"></a>springcloud config server</h4><ol><li>新建配置文件git仓库，master分支下新建2个文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pra-request.yml</span><br><span class="line">pra-request-prd.yml</span><br></pre></td></tr></table></figure></li></ol><p>新建分支dev,修改2个文件，push到仓库中</p><ol start="2"><li><p>server app 配置</p><ol><li>添加spring-cloud-config-server依赖</li><li>启动类上注解@EnableConfigServer</li><li><p>修改application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server.port: 8888</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">      name: pra-config-server</span><br><span class="line">  cloud:</span><br><span class="line">      config:</span><br><span class="line">          server:</span><br><span class="line">              git:</span><br><span class="line">                  uri: http://xx.xx.xx.xx/wutaotao/configrepo.git</span><br><span class="line">                  clone-on-start: true</span><br><span class="line">                  force-pull: true      # 强制更新</span><br><span class="line">                  basedir: D:\\code\\pra-config-server-dir  </span><br><span class="line">                    #克隆的仓库由临时目录config-repo-XXX改为指定目录</span><br><span class="line">              health:</span><br><span class="line">                repositories:</span><br><span class="line">                  a:</span><br><span class="line">                    label: dev</span><br><span class="line">                    name: pra-request</span><br><span class="line">                    profiles: prod</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">      org.springframework.cloud: debug</span><br><span class="line">      org.springframework.boot: debug</span><br><span class="line"># 为了显示health端点详细信息，需要进行额外配置</span><br><span class="line">management.security.enabled: false  # 1.5.1版本后只需要写这一句就可以</span><br><span class="line"># boot 2.0.0版本以后需要这样写</span><br><span class="line">management:</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: &quot;ALWAYS&quot;</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: *</span><br></pre></td></tr></table></figure></li><li><p>启动应用，访问端点，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 默认master分支</span><br><span class="line">http://localhost:8888/pra-request/default</span><br><span class="line">http://localhost:8888/pra-request/prod</span><br><span class="line">http://localhost:8888/pra-request-default.yml</span><br><span class="line">http://localhost:8888/pra-request-prod.yml</span><br><span class="line"></span><br><span class="line"># 指定dev分支</span><br><span class="line"># http://localhost:8888/dev/pra-request/default  （不支持）</span><br><span class="line">http://localhost:8888/dev/pra-request-default.yml</span><br><span class="line">http://localhost:8888/dev/pra-request-prod.yml</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>修改某个文件后再次通过config-server访问可以发现修改能够查询成功，说明进行请求时，config-<br>server会自动拉取代码仓库的最新配置。</p><ol start="3"><li><p>client app</p><ol><li>添加spring-cloud-starter-config，spring-boot-starter-actuator依赖。</li><li>删除application.yml，将其中属性分流到bootstrap.yml和配置仓库中去。</li><li>新增bootstrap.yml（该文档比application.yml先加载，但它优先级比application.yml低，<br>经测试同名属性以application.yml中为准）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: pra-request</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      uri: http://localhost:8888/</span><br><span class="line">      profile: default</span><br><span class="line">      label: master</span><br></pre></td></tr></table></figure></li></ol></li><li><p>注册到Eureka上。</p><ol><li>config-server注册到Eureka上，config-server也是一个普通的spring-boot应用，根据环境<br>不同，可以写application.yml和application-prod.yml。<br>添加starter-eureka依赖，添加@DiscoveryClient注解，yml中添加eureka地址即可。</li><li>pra-request注册到Eureka上，经测试发现从配置中心取回的属性数据会覆盖客户端自己在<br>application.yml中配置的属性，如端口号等。文档里写可以通过在config-server里设置属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.config.allowOverride: true</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>来授权允许客户端覆盖配置中心的配置。<br>所以，在客户端-这里为pra-request里完全可以删除application.yml文件，完全以配置仓库里的为<br>准，bootstrap.yml中保留可以注册到eureka中心并能定位到需要的yml配置文件的属性，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">      name: pra-request     # 需要来定位配置文件&#123;application&#125;</span><br><span class="line">  cloud:</span><br><span class="line">      config:</span><br><span class="line">          profile: default   # 需要来定位配置文件&#123;profile&#125;</span><br><span class="line">          label: master     # 需要来定位配置文件&#123;label&#125;</span><br><span class="line">          discovery:</span><br><span class="line">              enabled: true</span><br><span class="line">              service-id: pra-config-server</span><br><span class="line">          fail-fast: true     # 配置中心连不上时迅速报错，实测报错由19秒提高到3秒</span><br><span class="line"></span><br><span class="line">eureka:                               # 本身注册到eureka并寻找注册中心</span><br><span class="line">  client:</span><br><span class="line">      serviceUrl:</span><br><span class="line">          defaultZone: http://localhost:9090/eureka/</span><br><span class="line">  instance:</span><br><span class="line">      prefer-ip-address: true</span><br></pre></td></tr></table></figure></p><p>此时，仓库中的配置文件暂时有端口号，profile值，数据库链接，日志级别等。</p><h4 id="springcloud-sleuth"><a href="#springcloud-sleuth" class="headerlink" title="springcloud sleuth"></a>springcloud sleuth</h4><p>span:<br>  cs: client-sent 客户端发送    span 开始<br>  sr: server-received 服务器接受<br>  ss: server-sent 服务器发送<br>  cr: client-received  客户端接受  span结束<br>即从客户端出发，开始发送请求到接收到响应的整个过程是一个span.</p><p>从官方文档上来看，span有物理span和逻辑span的区别，<br>物理span即将网络延迟和服务器处理分成2个span,而上面span的定义就是逻辑的span，整个请求和<br>响应的过程就是一个逻辑span.</p><p>集成zipkin:<br>server:（因为这是日志收集的服务器，不是微服务的一部分，所以不应该注册到Eureka上，可以配合<br>springcloud stream和rabbit mq来使用消息中间件）</p><ol><li><p>新建项目zipkin-server,添加依赖<br>zipkin-server, zipkin-autoconfig-ui</p></li><li><p>启动类上使用@EnableZipkinServer注解</p></li><li>application.yml中添加server.port: 9411</li></ol><p>client:</p><ol><li>spring-cloud-sleuth-starter的基础上添加依赖spring-cloud-sleuth-zipkin</li><li>application.yml添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http://localhost:9411</span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">      percentage: 1.0   # 采样为100%</span><br></pre></td></tr></table></figure></li></ol><p>这里客户端对于zipkin server的地址是写死的，可以使用rabbitMQ来避免写死，这里省略。</p><h4 id="web"><a href="#web" class="headerlink" title="web"></a>web</h4><p><a href="https://git.dev.tencent.com/wutaotao/springboot-web-jsp.git" target="_blank" rel="noopener">项目源码</a><br>开发工具： idea<br>环境： springboot jsp<br>服务器: war包部署到tomcat中</p><ol><li>下载tomcat9 windows64位binary包，解压即可。</li><li>新建springboot项目，选择web启动依赖即可。</li><li><p>pom.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;microservice-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- 解析jstl标签 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>在src/main下新建webapp文件夹存放jsp文件，这里我统一放在webapp/page/test下</p></li><li>新建webcontroller作简单处理和跳转到相应jsp中，实体类book,启动类WebApplication,<br>它需要继承SpringBootServletInitializer类，重写config方法，将<code>return builder</code>改为<br><code>return builder.source(WebApplication.class)</code>即可。</li><li><p>新建application.yml文件，定义jsp视图的前缀和后缀，springmvc渲染视图需要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  mvc:</span><br><span class="line">    view:</span><br><span class="line">      prefix: /page/test/</span><br><span class="line">      sufix: .jsp</span><br></pre></td></tr></table></figure></li><li><p>到这里一个简单的springboot整合jsp就完成了，下面要在idea中配置tomcat。<br>参考<a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/jrebel-setup.md" target="_blank" rel="noopener">idea tutorial with jrebel</a></p><ol><li>在toolbar中选择edit configuration</li><li>application server中选择tomcat解压后的安装路径</li><li>填写after launch后自动打开的url地址</li><li><p>在deployment中选择artifact: war exploded, 下面的application context置为空（访问路径<br>不带项目名），删掉下面build artifact前的build<br>注：这个artifact可以在project structure中看到</p></li><li><p>返回server,<code>on update action</code>和新出现的<code>on frame deactivation</code>中都选择update classes<br>and resources`</p></li><li>jre默认1.8，http port 8080</li><li>apply后以debug启动项目，发现改变jsp后不用重新编译，重启，保存即可生效，改变方法内代码<br>重新编译后也能生效！但改变方法参数重新编译后提示<code>hot swap failed</code>,说明它还不支持，改用<br>jrebel debug启动，发现改变参数重新编译成功！这里并没有生成rebel.xml文件。</li><li>至此，springboot整合jsp的开发环境就搭建成功了！下面打个war包在linux环境下安装tomcat<br>启动项目看看。</li></ol></li></ol><h4 id="linux安装tomcat并启动服务供外界访问"><a href="#linux安装tomcat并启动服务供外界访问" class="headerlink" title="linux安装tomcat并启动服务供外界访问"></a>linux安装tomcat并启动服务供外界访问</h4><p>to be continued</p><h4 id="springboot整合spring-security"><a href="#springboot整合spring-security" class="headerlink" title="springboot整合spring security"></a>springboot整合spring security</h4><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201901301.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;spring boot, SpringCloud, Actuator, Eureka, ribbon, Feign, hystrix, zuul,&lt;br&gt;sleuth, spring cloud config, jdk, spring boot与spring cloud版本问题, linux,&lt;br&gt;tomcat&lt;br&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://www.taoblog.cn/categories/SpringCloud/"/>
    
    
      <category term="SpringBoot" scheme="http://www.taoblog.cn/tags/SpringBoot/"/>
    
      <category term="SpringCloud" scheme="http://www.taoblog.cn/tags/SpringCloud/"/>
    
      <category term="Linux" scheme="http://www.taoblog.cn/tags/Linux/"/>
    
      <category term="Tomcat" scheme="http://www.taoblog.cn/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="http://www.taoblog.cn/post/47caaf1e/"/>
    <id>http://www.taoblog.cn/post/47caaf1e/</id>
    <published>2019-01-22T13:51:18.000Z</published>
    <updated>2019-09-15T02:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>markdown基本语法<br><a id="more"></a><br>这里介绍的是基本markdown语法，使用工具为Typora.</p><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>​    1-6个#号，后接空格</p><p>​    <code>## 标题</code></p><h5 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h5><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><ol><li><p>加粗</p><p><code>**重点概念**</code></p><p>123<strong>我是重点</strong>456</p></li><li><p>删除线</p><p><code>~~我被删了~~</code></p><p>123<del>我被删了</del></p></li></ol><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>   <code>&gt; 4 = 2* 2</code></p><blockquote><p>4 = 2 * 2</p></blockquote><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><p>   URL需要输入完整，不能漏掉<code>http://XXX/</code></p><p>  <code>[去百度](http://www.baidu.com/)</code></p><p>  <a href="http://www.baidu.com/" target="_blank" rel="noopener">去百度</a></p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>   <code>![图片名](图片存放目录)</code></p><p>   <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/maya.jpg" alt="maya"></p><h4 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h4><ol><li><p>单行</p><p>`one line code`</p><p><code>one line code</code></p></li><li><p>多行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\```js\</span><br><span class="line">var s = &apos;hello world&apos;;</span><br><span class="line">alert(s);</span><br><span class="line">\```\</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello world'</span>;</span><br><span class="line">alert(s);</span><br></pre></td></tr></table></figure></li></ol><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>   输完一点后，Typora中直接回车即可出现第二点，不用手动空格。</p><p>   <code>1. 第一点</code></p><ol><li>第一点</li><li>第二点</li></ol><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>​    <code>---</code></p><hr><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>Typora中的表格语法手工输入较麻烦，有2种方法。</p><pre><code>1. 使用其工具自带快捷键ctrl+t,注意输入第一行表头时选择居中，这样下面的内容就不用再重复选择了。（注意行数包括了表头）2. 也可以直接输入表头`|序号|姓名|分数|`，再统一调为居中后，再加上若干需要的行，需要多次点击下方加入一行，也较麻烦，可以确定大概行数最好</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 序号 | 姓名 | 分数 |</span><br><span class="line">| :--: | :--: | :--: |</span><br><span class="line">| 1 | 吴涛涛 | 100 |</span><br><span class="line">| 2 | 王二 | 77 |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">姓名</th><th style="text-align:center">分数</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">张三</td><td style="text-align:center">77</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">王二</td><td style="text-align:center">66</td></tr></tbody></table><h4 id="完成任务清单"><a href="#完成任务清单" class="headerlink" title="完成任务清单"></a>完成任务清单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [x] 任务A</span><br><span class="line">- [ ] 任务B # -space[space]space任务B  一共有3个空格</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 任务A</li><li style="list-style: none"><input type="checkbox"> 任务B</li></ul><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>​    有的平台不支持</p><p>​    <code>[toc]</code><br><code>[TOC]</code> 略去展示效果</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>  还是引用代码块的语法，不过语言类型可以选择2个js包，一个是flowchart.js,它适用于画流程图，<br>  其他的时序图可以选择mermaid(美人鱼)，技术博客一般还是普通流程图用的多,掌握flow就可以。<br>  以下是网上一个写的比较好例子。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 首先，像定义变量一样将所有的节点定义出来，包括变量名，变量类型，节点显示名称</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">cond1=&gt;condition: 条件1</span><br><span class="line">opy1=&gt;operation: 操作1</span><br><span class="line">opn1=&gt;operation: 操作2</span><br><span class="line">cond2=&gt;condition: 条件2</span><br><span class="line">io1=&gt;inputoutput: 输出1</span><br><span class="line">io2=&gt;inputoutput: 输出2</span><br><span class="line">// 指定流程的流转反向，通过括号给出判断条件和相对位置</span><br><span class="line">st-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;opy1-&gt;io1-&gt;e</span><br><span class="line">cond1(no)-&gt;opn1(right)-&gt;cond2</span><br><span class="line">cond2(yes)-&gt;io2-&gt;e</span><br><span class="line">cond2(no)-&gt;cond1</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">cond1=&gt;condition: 条件1</span><br><span class="line">opy1=&gt;operation: 操作1</span><br><span class="line">opn1=&gt;operation: 操作2</span><br><span class="line">cond2=&gt;condition: 条件2</span><br><span class="line">io1=&gt;inputoutput: 输出1</span><br><span class="line">io2=&gt;inputoutput: 输出2</span><br><span class="line">st-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;opy1-&gt;io1-&gt;e</span><br><span class="line">cond1(no)-&gt;opn1(right)-&gt;cond2</span><br><span class="line">cond2(yes)-&gt;io2-&gt;e</span><br><span class="line">cond2(no)-&gt;cond1</span><br></pre></td></tr></table></figure><p>写的过程中无法调试，最好是在typora中边写边查看效果，逐步完善，节点类型如start,end,<br>operation,condition,inputoutput等单词注意不要写错。<br>另外： typora支持目录生成[TOC]和流程图，github好像不支持。<br>在引用文字&gt;和有序列表时需要空一行来实现排版效果，不能多也不能少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. sd</span><br><span class="line"></span><br><span class="line">   1. sd</span><br><span class="line"></span><br><span class="line">   2. df</span><br><span class="line"></span><br><span class="line">   3. df</span><br><span class="line"></span><br><span class="line">2. df</span><br><span class="line"></span><br><span class="line">3. df</span><br></pre></td></tr></table></figure></p><p>2019.03.16注：插入表格时也需要在表格上方空一行来实现渲染效果。</p><p><hr><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://wutaotaospace.oss-cn-beijing.aliyuncs.com/image/201901292.jpg" class="full-image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;markdown基本语法&lt;br&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://www.taoblog.cn/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://www.taoblog.cn/tags/Markdown/"/>
    
  </entry>
  
</feed>
